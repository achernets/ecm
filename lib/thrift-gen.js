/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*jshint evil:true*/

/**
 * The Thrift namespace houses the Apache Thrift JavaScript library
 * elements providing JavaScript bindings for the Apache Thrift RPC
 * system. End users will typically only directly make use of the
 * Transport (TXHRTransport/TWebSocketTransport) and Protocol
 * (TJSONPRotocol/TBinaryProtocol) constructors.
 *
 * Object methods beginning with a __ (e.g. __onOpen()) are internal
 * and should not be called outside of the object's own methods.
 *
 * This library creates one global object: Thrift
 * Code in this library must never create additional global identifiers,
 * all features must be scoped within the Thrift namespace.
 * @namespace
 * @example
 *     var transport = new Thrift.Transport('http://localhost:8585');
 *     var protocol  = new Thrift.Protocol(transport);
 *     var client = new MyThriftSvcClient(protocol);
 *     var result = client.MyMethod();
 */
var Thrift = {
    /**
     * Thrift JavaScript library version.
     * @readonly
     * @const {string} Version
     * @memberof Thrift
     */
    Version: '0.11.0',

    /**
     * Thrift IDL type string to Id mapping.
     * @readonly
     * @property {number}  STOP   - End of a set of fields.
     * @property {number}  VOID   - No value (only legal for return types).
     * @property {number}  BOOL   - True/False integer.
     * @property {number}  BYTE   - Signed 8 bit integer.
     * @property {number}  I08    - Signed 8 bit integer.
     * @property {number}  DOUBLE - 64 bit IEEE 854 floating point.
     * @property {number}  I16    - Signed 16 bit integer.
     * @property {number}  I32    - Signed 32 bit integer.
     * @property {number}  I64    - Signed 64 bit integer.
     * @property {number}  STRING - Array of bytes representing a string of characters.
     * @property {number}  UTF7   - Array of bytes representing a string of UTF7 encoded characters.
     * @property {number}  STRUCT - A multifield type.
     * @property {number}  MAP    - A collection type (map/associative-array/dictionary).
     * @property {number}  SET    - A collection type (unordered and without repeated values).
     * @property {number}  LIST   - A collection type (unordered).
     * @property {number}  UTF8   - Array of bytes representing a string of UTF8 encoded characters.
     * @property {number}  UTF16  - Array of bytes representing a string of UTF16 encoded characters.
     */
    Type: {
        STOP: 0,
        VOID: 1,
        BOOL: 2,
        BYTE: 3,
        I08: 3,
        DOUBLE: 4,
        I16: 6,
        I32: 8,
        I64: 10,
        STRING: 11,
        UTF7: 11,
        STRUCT: 12,
        MAP: 13,
        SET: 14,
        LIST: 15,
        UTF8: 16,
        UTF16: 17
    },

    /**
     * Thrift RPC message type string to Id mapping.
     * @readonly
     * @property {number}  CALL      - RPC call sent from client to server.
     * @property {number}  REPLY     - RPC call normal response from server to client.
     * @property {number}  EXCEPTION - RPC call exception response from server to client.
     * @property {number}  ONEWAY    - Oneway RPC call from client to server with no response.
     */
    MessageType: {
        CALL: 1,
        REPLY: 2,
        EXCEPTION: 3,
        ONEWAY: 4
    },

    /**
     * Utility function returning the count of an object's own properties.
     * @param {object} obj - Object to test.
     * @returns {number} number of object's own properties
     */
    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }
        return length;
    },

    /**
     * Utility function to establish prototype inheritance.
     * @see {@link http://javascript.crockford.com/prototypal.html|Prototypal Inheritance}
     * @param {function} constructor - Contstructor function to set as derived.
     * @param {function} superConstructor - Contstructor function to set as base.
     * @param {string} [name] - Type name to set as name property in derived prototype.
     */
    inherits: function(constructor, superConstructor, name) {
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
      constructor.prototype.name = name || '';
    }
};

/**
 * Initializes a Thrift TException instance.
 * @constructor
 * @augments Error
 * @param {string} message - The TException message (distinct from the Error message).
 * @classdesc TException is the base class for all Thrift exceptions types.
 */
Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error, 'TException');

/**
 * Returns the message set on the exception.
 * @readonly
 * @returns {string} exception message
 */
Thrift.TException.prototype.getMessage = function() {
    return this.message;
};

/**
 * Thrift Application Exception type string to Id mapping.
 * @readonly
 * @property {number}  UNKNOWN                 - Unknown/undefined.
 * @property {number}  UNKNOWN_METHOD          - Client attempted to call a method unknown to the server.
 * @property {number}  INVALID_MESSAGE_TYPE    - Client passed an unknown/unsupported MessageType.
 * @property {number}  WRONG_METHOD_NAME       - Unused.
 * @property {number}  BAD_SEQUENCE_ID         - Unused in Thrift RPC, used to flag proprietary sequence number errors.
 * @property {number}  MISSING_RESULT          - Raised by a server processor if a handler fails to supply the required return result.
 * @property {number}  INTERNAL_ERROR          - Something bad happened.
 * @property {number}  PROTOCOL_ERROR          - The protocol layer failed to serialize or deserialize data.
 * @property {number}  INVALID_TRANSFORM       - Unused.
 * @property {number}  INVALID_PROTOCOL        - The protocol (or version) is not supported.
 * @property {number}  UNSUPPORTED_CLIENT_TYPE - Unused.
 */
Thrift.TApplicationExceptionType = {
    UNKNOWN: 0,
    UNKNOWN_METHOD: 1,
    INVALID_MESSAGE_TYPE: 2,
    WRONG_METHOD_NAME: 3,
    BAD_SEQUENCE_ID: 4,
    MISSING_RESULT: 5,
    INTERNAL_ERROR: 6,
    PROTOCOL_ERROR: 7,
    INVALID_TRANSFORM: 8,
    INVALID_PROTOCOL: 9,
    UNSUPPORTED_CLIENT_TYPE: 10
};

/**
 * Initializes a Thrift TApplicationException instance.
 * @constructor
 * @augments Thrift.TException
 * @param {string} message - The TApplicationException message (distinct from the Error message).
 * @param {Thrift.TApplicationExceptionType} [code] - The TApplicationExceptionType code.
 * @classdesc TApplicationException is the exception class used to propagate exceptions from an RPC server back to a calling client.
*/
Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = typeof code === 'number' ? code : 0;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException, 'TApplicationException');

/**
 * Read a TApplicationException from the supplied protocol.
 * @param {object} input - The input protocol to read from.
 */
Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

/**
 * Wite a TApplicationException to the supplied protocol.
 * @param {object} output - The output protocol to write to.
 */
Thrift.TApplicationException.prototype.write = function(output) {
    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

/**
 * Returns the application exception code set on the exception.
 * @readonly
 * @returns {Thrift.TApplicationExceptionType} exception code
 */
Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

Thrift.TProtocolExceptionType = {
    UNKNOWN: 0,
    INVALID_DATA: 1,
    NEGATIVE_SIZE: 2,
    SIZE_LIMIT: 3,
    BAD_VERSION: 4,
    NOT_IMPLEMENTED: 5,
    DEPTH_LIMIT: 6
};

Thrift.TProtocolException = function TProtocolException(type, message) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.type = type;
    this.message = message;
};
Thrift.inherits(Thrift.TProtocolException, Thrift.TException, 'TProtocolException');

/**
 * Constructor Function for the XHR transport.
 * If you do not specify a url then you must handle XHR operations on
 * your own. This type can also be constructed using the Transport alias
 * for backward compatibility.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O
 * between RPC clients and servers. The JavaScript TXHRTransport object
 * uses Http[s]/XHR. Target servers must implement the http[s] transport
 * (see: node.js example server_http.js).
 * @example
 *     var transport = new Thrift.TXHRTransport("http://localhost:8585");
 */
Thrift.Transport = Thrift.TXHRTransport = function(url, options) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;
    this.useCORS = (options && options.useCORS);
    this.customHeaders = options ? (options.customHeaders ? options.customHeaders : {}): {};
    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.TXHRTransport.prototype = {
    /**
     * Gets the browser specific XmlHttpRequest Object.
     * @returns {object} the browser XHR interface object
     */
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support XHR.";
    },

    /**
     * Sends the current XRH request if the transport was created with a URL
     * and the async parameter is false. If the transport was not created with
     * a URL, or the async parameter is True and no callback is provided, or
     * the URL is an empty string, the current send buffer is returned.
     * @param {object} async - If true the current send buffer is returned.
     * @param {object} callback - Optional async completion callback
     * @returns {undefined|string} Nothing or the current send buffer.
     * @throws {string} If XHR fails.
     */
    flush: function(async, callback) {
        var self = this;
        if ((async && !callback) || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/vnd.apache.thrift.json; charset=utf-8');
        }

        if (callback) {
            //Ignore XHR callbacks until the data arrives, then call the
            //  client's callback
            xreq.onreadystatechange =
              (function() {
                var clientCallback = callback;
                return function() {
                  if (this.readyState == 4 && this.status == 200) {
                    self.setRecvBuffer(this.responseText);
                    clientCallback();
                  }
                };
              }());

            // detect net::ERR_CONNECTION_REFUSED and call the callback.
            xreq.onerror =
                (function() {
                  var clientCallback = callback;
                  return function() {
                      clientCallback();
                  };
                }());

        }

        xreq.open('POST', this.url, !!async);

        // add custom headers
        Object.keys(self.customHeaders).forEach(function(prop) {
            xreq.setRequestHeader(prop, self.customHeaders[prop]);
        });

        if (xreq.setRequestHeader) {
            xreq.setRequestHeader('Accept', 'application/vnd.apache.thrift.json; charset=utf-8');
            xreq.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
        }

        xreq.send(this.send_buf);
        if (async && callback) {
            return;
        }

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Creates a jQuery XHR object to be used for a Thrift server call.
     * @param {object} client - The Thrift Service client object generated by the IDL compiler.
     * @param {object} postData - The message to send to the server.
     * @param {function} args - The original call arguments with the success call back at the end.
     * @param {function} recv_method - The Thrift Service Client receive method for the call.
     * @returns {object} A new jQuery XHR object.
     * @throws {string} If the jQuery version is prior to 1.5 or if jQuery is not found.
     */
    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        var thriftTransport = this;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            contentType: 'text/plain',
            dataType: 'text thrift',
            converters: {
                'text thrift' : function(responseData) {
                    thriftTransport.setRecvBuffer(responseData);
                    var value = recv_method.call(client);
                    return value;
                }
            },
            context: client,
            success: jQuery.makeArray(args).pop()
        });

        return jqXHR;
    },

    /**
     * Sets the buffer to provide the protocol when deserializing.
     * @param {string} buf - The buffer to supply the protocol.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open, XHR always returns true.
     * @readonly
     * @returns {boolean} Always True.
     */
    isOpen: function() {
        return true;
    },

    /**
     * Opens the transport connection, with XHR this is a nop.
     */
    open: function() {},

    /**
     * Closes the transport connection, with XHR this is a nop.
     */
    close: function() {},

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */
    getSendBuffer: function() {
        return this.send_buf;
    }

};


/**
 * Constructor Function for the WebSocket transport.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O
 * between RPC clients and servers. The JavaScript TWebSocketTransport object
 * uses the WebSocket protocol. Target servers must implement WebSocket.
 * (see: node.js example server_http.js).
 * @example
 *   var transport = new Thrift.TWebSocketTransport("http://localhost:8585");
 */
Thrift.TWebSocketTransport = function(url) {
    this.__reset(url);
};

Thrift.TWebSocketTransport.prototype = {
    __reset: function(url) {
      this.url = url;             //Where to connect
      this.socket = null;         //The web socket
      this.callbacks = [];        //Pending callbacks
      this.send_pending = [];     //Buffers/Callback pairs waiting to be sent
      this.send_buf = '';         //Outbound data, immutable until sent
      this.recv_buf = '';         //Inbound data
      this.rb_wpos = 0;           //Network write position in receive buffer
      this.rb_rpos = 0;           //Client read position in receive buffer
    },

    /**
     * Sends the current WS request and registers callback. The async
     * parameter is ignored (WS flush is always async) and the callback
     * function parameter is required.
     * @param {object} async - Ignored.
     * @param {object} callback - The client completion callback.
     * @returns {undefined|string} Nothing (undefined)
     */
    flush: function(async, callback) {
      var self = this;
      if (this.isOpen()) {
        //Send data and register a callback to invoke the client callback
        this.socket.send(this.send_buf);
        this.callbacks.push((function() {
          var clientCallback = callback;
          return function(msg) {
            self.setRecvBuffer(msg);
            clientCallback();
          };
        }()));
        if(callback) {
          this.callbacks.push((function() {
            var clientCallback = callback;
            return function(msg) {
              self.setRecvBuffer(msg);
              clientCallback();
            };
          }()));
        }
      } else {
        //Queue the send to go out __onOpen
        this.send_pending.push({
          buf: this.send_buf,
          cb: callback
        });
      }
    },

    __onOpen: function() {
       var self = this;
       if (this.send_pending.length > 0) {
          //If the user made calls before the connection was fully
          //open, send them now
          this.send_pending.forEach(function(elem) {
             this.socket.send(elem.buf);
             this.callbacks.push((function() {
               var clientCallback = elem.cb;
               return function(msg) {
                  self.setRecvBuffer(msg);
                  clientCallback();
               };
             }()));
          });
          this.send_pending = [];
       }
    },

    __onClose: function(evt) {
      this.__reset(this.url);
    },

    __onMessage: function(evt) {
      if (this.callbacks.length) {
        this.callbacks.shift()(evt.data);
      }
    },

    __onError: function(evt) {
      console.log('Thrift WebSocket Error: ' + evt.toString());
      this.socket.close();
    },

    /**
     * Sets the buffer to use when receiving server responses.
     * @param {string} buf - The buffer to receive server responses.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open
     * @readonly
     * @returns {boolean}
     */
    isOpen: function() {
        return this.socket && this.socket.readyState == this.socket.OPEN;
    },

    /**
     * Opens the transport connection
     */
    open: function() {
      //If OPEN/CONNECTING/CLOSING ignore additional opens
      if (this.socket && this.socket.readyState != this.socket.CLOSED) {
        return;
      }
      //If there is no socket or the socket is closed:
      this.socket = new WebSocket(this.url);
      this.socket.onopen = this.__onOpen.bind(this);
      this.socket.onmessage = this.__onMessage.bind(this);
      this.socket.onerror = this.__onError.bind(this);
      this.socket.onclose = this.__onClose.bind(this);
    },

    /**
     * Closes the transport connection
     */
    close: function() {
      this.socket.close();
    },

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */
    getSendBuffer: function() {
        return this.send_buf;
    }

};

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} transport - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross
 * language RPC. The Protocol type is the JavaScript browser implementation
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
Thrift.TJSONProtocol = Thrift.Protocol = function(transport) {
    this.tstack = [];
    this.tpos = [];
    this.transport = transport;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
 Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {
    /**
     * Returns the underlying transport.
     * @readonly
     * @returns {Thrift.Transport} The underlying transport.
     */
    getTransport: function() {
        return this.transport;
    },

    /**
     * Serializes the beginning of a Thrift RPC message.
     * @param {string} name - The service method to call.
     * @param {Thrift.MessageType} messageType - The type of method call.
     * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
     */
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    /**
     * Serializes the end of a Thrift RPC message.
     */
    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    /**
     * Serializes the beginning of a struct.
     * @param {string} name - The name of the struct.
     */
    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    /**
     * Serializes the end of a struct.
     */
    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    /**
     * Serializes the beginning of a struct field.
     * @param {string} name - The name of the field.
     * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
     * @param {number} fieldId - The field's unique identifier.
     */
    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    /**
     * Serializes the end of a field.
     */
    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    /**
     * Serializes the end of the set of fields for a struct.
     */
    writeFieldStop: function() {
        //na
    },

    /**
     * Serializes the beginning of a map collection.
     * @param {Thrift.Type} keyType - The data type of the key.
     * @param {Thrift.Type} valType - The data type of the value.
     * @param {number} [size] - The number of elements in the map (ignored).
     */
    writeMapBegin: function(keyType, valType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    /**
     * Serializes the end of a map.
     */
    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a list collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a list.
     */
    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a set collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a set.
     */
    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /** Serializes a boolean */
    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    /** Serializes a number */
    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    /** Serializes a number */
    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    /** Serializes a number */
    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    /** Serializes a number */
    writeI64: function(i64) {
        this.tstack.push(i64);
    },

    /** Serializes a number */
    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    /** Serializes a string */
    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash
                    escapedString += '\\\\'; // write out as double backslash
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    /** Serializes a string */
    writeBinary: function(binary) {
        var str = '';
        if (typeof binary == 'string') {
            str = binary;
        } else if (binary instanceof Uint8Array) {
            var arr = binary;
            for (var i = 0; i < arr.length; ++i) {
                str += String.fromCharCode(arr[i]);
            }
        } else {
            throw new TypeError('writeBinary only accepts String or Uint8Array.');
        }
        this.tstack.push('"' + btoa(str) + '"');
    },

    /**
       @class
       @name AnonReadMessageBeginReturn
       @property {string} fname - The name of the service method.
       @property {Thrift.MessageType} mtype - The type of message call.
       @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
     */
    /**
     * Deserializes the beginning of a message.
     * @returns {AnonReadMessageBeginReturn}
     */
    readMessageBegin: function() {
        this.rstack = [];
        this.rpos = [];

        if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function') {
            this.robj = JSON.parse(this.transport.readAll());
        } else if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(this.transport.readAll());
        } else {
            this.robj = eval(this.transport.readAll());
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    /** Deserializes the end of a message. */
    readMessageEnd: function() {
    },

    /**
     * Deserializes the beginning of a struct.
     * @param {string} [name] - The name of the struct (ignored)
     * @returns {object} - An object with an empty string fname property
     */
    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    /** Deserializes the end of a struct. */
    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    /**
       @class
       @name AnonReadFieldBeginReturn
       @property {string} fname - The name of the field (always '').
       @property {Thrift.Type} ftype - The data type of the field.
       @property {number} fid - The unique identifier of the field.
     */
    /**
     * Deserializes the beginning of a field.
     * @returns {AnonReadFieldBeginReturn}
     */
    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    /** Deserializes the end of a field. */
    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    /**
       @class
       @name AnonReadMapBeginReturn
       @property {Thrift.Type} ktype - The data type of the key.
       @property {Thrift.Type} vtype - The data type of the value.
       @property {number} size - The number of elements in the map.
     */
    /**
     * Deserializes the beginning of a map.
     * @returns {AnonReadMapBeginReturn}
     */
    readMapBegin: function() {
        var map = this.rstack.pop();
        var first = map.shift();
        if (first instanceof Array) {
          this.rstack.push(map);
          map = first;
          first = map.shift();
        }

        var r = {};
        r.ktype = Thrift.Protocol.RType[first];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();


        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    /** Deserializes the end of a map. */
    readMapEnd: function() {
        this.readFieldEnd();
    },

    /**
       @class
       @name AnonReadColBeginReturn
       @property {Thrift.Type} etype - The data type of the element.
       @property {number} size - The number of elements in the collection.
     */
    /**
     * Deserializes the beginning of a list.
     * @returns {AnonReadColBeginReturn}
     */
    readListBegin: function() {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list.shift());

        return r;
    },

    /** Deserializes the end of a list. */
    readListEnd: function() {
        this.readFieldEnd();
    },

    /**
     * Deserializes the beginning of a set.
     * @returns {AnonReadColBeginReturn}
     */
    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    /** Deserializes the end of a set. */
    readSetEnd: function() {
        return this.readListEnd();
    },

    /** Returns an object with a value property set to
     *  False unless the next number in the protocol buffer
     *  is 1, in which case the value property is True */
    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readByte: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI16: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                r.value = f.shift();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI64: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readDouble: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readString: function() {
        var r = this.readI32();
        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readBinary: function() {
        var r = this.readI32();
        r.value = atob(r.value);
        return r;
    },

    /**
     * Method to arbitrarily skip over data */
    skip: function(type) {
        var ret, i;
        switch (type) {
            case Thrift.Type.STOP:
                return null;

            case Thrift.Type.BOOL:
                return this.readBool();

            case Thrift.Type.BYTE:
                return this.readByte();

            case Thrift.Type.I16:
                return this.readI16();

            case Thrift.Type.I32:
                return this.readI32();

            case Thrift.Type.I64:
                return this.readI64();

            case Thrift.Type.DOUBLE:
                return this.readDouble();

            case Thrift.Type.STRING:
                return this.readString();

            case Thrift.Type.STRUCT:
                this.readStructBegin();
                while (true) {
                    ret = this.readFieldBegin();
                    if (ret.ftype == Thrift.Type.STOP) {
                        break;
                    }
                    this.skip(ret.ftype);
                    this.readFieldEnd();
                }
                this.readStructEnd();
                return null;

            case Thrift.Type.MAP:
                ret = this.readMapBegin();
                for (i = 0; i < ret.size; i++) {
                    if (i > 0) {
                        if (this.rstack.length > this.rpos[this.rpos.length - 1] + 1) {
                            this.rstack.pop();
                        }
                    }
                    this.skip(ret.ktype);
                    this.skip(ret.vtype);
                }
                this.readMapEnd();
                return null;

            case Thrift.Type.SET:
                ret = this.readSetBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readSetEnd();
                return null;

            case Thrift.Type.LIST:
                ret = this.readListBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readListEnd();
                return null;
        }
    }
};


/**
 * Initializes a MutilplexProtocol Implementation as a Wrapper for Thrift.Protocol
 * @constructor
 */
Thrift.MultiplexProtocol = function(srvName, trans, strictRead, strictWrite) {
    Thrift.Protocol.call(this, trans, strictRead, strictWrite);
    this.serviceName = srvName;
};
Thrift.inherits(Thrift.MultiplexProtocol, Thrift.Protocol, 'multiplexProtocol');

/** Override writeMessageBegin method of prototype*/
Thrift.MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {

    if (type === Thrift.MessageType.CALL || type === Thrift.MessageType.ONEWAY) {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, this.serviceName + ':' + name, type, seqid);
    } else {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
};

Thrift.Multiplexer = function() {
    this.seqid = 0;
};

/** Instantiates a multiplexed client for a specific service
 * @constructor
 * @param {String} serviceName - The transport to serialize to/from.
 * @param {Thrift.ServiceClient} SCl - The Service Client Class
 * @param {Thrift.Transport} transport - Thrift.Transport instance which provides remote host:port
 * @example
 *    var mp = new Thrift.Multiplexer();
 *    var transport = new Thrift.Transport("http://localhost:9090/foo.thrift");
 *    var protocol = new Thrift.Protocol(transport);
 *    var client = mp.createClient('AuthService', AuthServiceClient, transport);
*/
Thrift.Multiplexer.prototype.createClient = function(serviceName, SCl, transport) {
    if (SCl.Client) {
        SCl = SCl.Client;
    }
    var self = this;
    SCl.prototype.new_seqid = function() {
        self.seqid += 1;
        return self.seqid;
    };
    var client = new SCl(new Thrift.MultiplexProtocol(serviceName, transport));

    return client;
};



var copyList, copyMap;

copyList = function(lst, types) {

  if (!lst) {return lst; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var len = lst.length, result = [], i, val;
  for (i = 0; i < len; i++) {
    val = lst[i];
    if (type === null) {
      result.push(val);
    }
    else if (type === copyMap || type === copyList) {
      result.push(type(val, types.slice(1)));
    }
    else {
      result.push(new Type(val));
    }
  }
  return result;
};

copyMap = function(obj, types) {

  if (!obj) {return obj; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var result = {}, val;
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      val = obj[prop];
      if (type === null) {
        result[prop] = val;
      }
      else if (type === copyMap || type === copyList) {
        result[prop] = type(val, types.slice(1));
      }
      else {
        result[prop] = new Type(val);
      }
    }
  }
  return result;
};

Thrift.copyMap = copyMap;
Thrift.copyList = copyList;
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

AccountGroupService_createOrUpdateAccountGroup_args = class {
  constructor(args) {
    this.token = null;
    this.accountGroup = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accountGroup !== undefined && args.accountGroup !== null) {
        this.accountGroup = new AccountGroup(args.accountGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accountGroup = new AccountGroup();
          this.accountGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_createOrUpdateAccountGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accountGroup !== null && this.accountGroup !== undefined) {
      output.writeFieldBegin('accountGroup', Thrift.Type.STRUCT, 2);
      this.accountGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupService_createOrUpdateAccountGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AccountGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AccountGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_createOrUpdateAccountGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupService_getAccountGroup_args = class {
  constructor(args) {
    this.token = null;
    this.accountGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_getAccountGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupService_getAccountGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AccountGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AccountGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_getAccountGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupService_getAllAccountGroup_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_getAllAccountGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupService_getAllAccountGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [AccountGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new AccountGroup();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroupService_getAllAccountGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroupServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  createOrUpdateAccountGroup (token, accountGroup) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateAccountGroup(token, accountGroup, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateAccountGroup (token, accountGroup, callback) {
    const params = {
      token: token,
      accountGroup: accountGroup
    };
    const args = new AccountGroupService_createOrUpdateAccountGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateAccountGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateAccountGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateAccountGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountGroupService_createOrUpdateAccountGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateAccountGroup failed: unknown result';
  }

  getAccountGroup (token, accountGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAccountGroup(token, accountGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAccountGroup (token, accountGroupId, callback) {
    const params = {
      token: token,
      accountGroupId: accountGroupId
    };
    const args = new AccountGroupService_getAccountGroup_args(params);
    try {
      this.output.writeMessageBegin('getAccountGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAccountGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAccountGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountGroupService_getAccountGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAccountGroup failed: unknown result';
  }

  getAllAccountGroup (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllAccountGroup(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllAccountGroup (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AccountGroupService_getAllAccountGroup_args(params);
    try {
      this.output.writeMessageBegin('getAllAccountGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllAccountGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllAccountGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountGroupService_getAllAccountGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllAccountGroup failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

AccountService_createOrUpdateAccount_args = class {
  constructor(args) {
    this.token = null;
    this.account = null;
    this.securityKey = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.securityKey !== undefined && args.securityKey !== null) {
        this.securityKey = args.securityKey;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.securityKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_createOrUpdateAccount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 2);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.securityKey !== null && this.securityKey !== undefined) {
      output.writeFieldBegin('securityKey', Thrift.Type.STRING, 3);
      output.writeString(this.securityKey);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountService_createOrUpdateAccount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Account(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Account();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_createOrUpdateAccount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountService_getAccount_args = class {
  constructor(args) {
    this.token = null;
    this.accountId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_getAccount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 2);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountService_getAccount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Account(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Account();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_getAccount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountService_getAllAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_getAllAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountService_getAllAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Account]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new Account();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountService_getAllAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  createOrUpdateAccount (token, account, securityKey, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateAccount(token, account, securityKey, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateAccount (token, account, securityKey, password, callback) {
    const params = {
      token: token,
      account: account,
      securityKey: securityKey,
      password: password
    };
    const args = new AccountService_createOrUpdateAccount_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateAccount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateAccount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateAccount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountService_createOrUpdateAccount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateAccount failed: unknown result';
  }

  getAccount (token, accountId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAccount(token, accountId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAccount (token, accountId, callback) {
    const params = {
      token: token,
      accountId: accountId
    };
    const args = new AccountService_getAccount_args(params);
    try {
      this.output.writeMessageBegin('getAccount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAccount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAccount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountService_getAccount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAccount failed: unknown result';
  }

  getAllAccounts (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllAccounts(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllAccounts (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AccountService_getAllAccounts_args(params);
    try {
      this.output.writeMessageBegin('getAllAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AccountService_getAllAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllAccounts failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

AdminService_createOrUpdateFileStorage_args = class {
  constructor(args) {
    this.token = null;
    this.fileStorage = null;
    this.password = null;
    this.accountsToAdd = null;
    this.accountsToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fileStorage !== undefined && args.fileStorage !== null) {
        this.fileStorage = new FileStorage(args.fileStorage);
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.accountsToAdd !== undefined && args.accountsToAdd !== null) {
        this.accountsToAdd = Thrift.copyList(args.accountsToAdd, [Account]);
      }
      if (args.accountsToRemove !== undefined && args.accountsToRemove !== null) {
        this.accountsToRemove = Thrift.copyList(args.accountsToRemove, [Account]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.fileStorage = new FileStorage();
          this.fileStorage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.accountsToAdd = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new Account();
            elem28.read(input);
            this.accountsToAdd.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.accountsToRemove = [];
          const _rtmp330 = input.readListBegin();
          const _size29 = _rtmp330.size || 0;
          for (let _i31 = 0; _i31 < _size29; ++_i31) {
            let elem32 = null;
            elem32 = new Account();
            elem32.read(input);
            this.accountsToRemove.push(elem32);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdateFileStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fileStorage !== null && this.fileStorage !== undefined) {
      output.writeFieldBegin('fileStorage', Thrift.Type.STRUCT, 2);
      this.fileStorage.write(output);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.accountsToAdd !== null && this.accountsToAdd !== undefined) {
      output.writeFieldBegin('accountsToAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.accountsToAdd.length);
      for (let iter33 in this.accountsToAdd) {
        if (this.accountsToAdd.hasOwnProperty(iter33)) {
          iter33 = this.accountsToAdd[iter33];
          iter33.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accountsToRemove !== null && this.accountsToRemove !== undefined) {
      output.writeFieldBegin('accountsToRemove', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.accountsToRemove.length);
      for (let iter34 in this.accountsToRemove) {
        if (this.accountsToRemove.hasOwnProperty(iter34)) {
          iter34 = this.accountsToRemove[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_createOrUpdateFileStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new FileStorage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new FileStorage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdateFileStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllFileStorages_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllFileStorages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllFileStorages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [FileStorage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new FileStorage();
            elem38.read(input);
            this.success.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllFileStorages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter39 in this.success) {
        if (this.success.hasOwnProperty(iter39)) {
          iter39 = this.success[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllFileStorages_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllFileStorages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllFileStorages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllFileStorages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeFileStorages_args = class {
  constructor(args) {
    this.token = null;
    this.fileStorageIds = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fileStorageIds !== undefined && args.fileStorageIds !== null) {
        this.fileStorageIds = Thrift.copyList(args.fileStorageIds, [null]);
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.fileStorageIds = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = input.readString().value;
            this.fileStorageIds.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeFileStorages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fileStorageIds !== null && this.fileStorageIds !== undefined) {
      output.writeFieldBegin('fileStorageIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.fileStorageIds.length);
      for (let iter44 in this.fileStorageIds) {
        if (this.fileStorageIds.hasOwnProperty(iter44)) {
          iter44 = this.fileStorageIds[iter44];
          output.writeString(iter44);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeFileStorages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeFileStorages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_moveAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.fileStorageId = null;
    this.onlyLatest = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.fileStorageId !== undefined && args.fileStorageId !== null) {
        this.fileStorageId = args.fileStorageId;
      }
      if (args.onlyLatest !== undefined && args.onlyLatest !== null) {
        this.onlyLatest = args.onlyLatest;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileStorageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.onlyLatest = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_moveAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.fileStorageId !== null && this.fileStorageId !== undefined) {
      output.writeFieldBegin('fileStorageId', Thrift.Type.STRING, 3);
      output.writeString(this.fileStorageId);
      output.writeFieldEnd();
    }
    if (this.onlyLatest !== null && this.onlyLatest !== undefined) {
      output.writeFieldBegin('onlyLatest', Thrift.Type.BOOL, 4);
      output.writeBool(this.onlyLatest);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_moveAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_moveAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_createOrUpdateNews_args = class {
  constructor(args) {
    this.token = null;
    this.news = null;
    this.accountIDsToAdd = null;
    this.accountIDsToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.news !== undefined && args.news !== null) {
        this.news = new News(args.news);
      }
      if (args.accountIDsToAdd !== undefined && args.accountIDsToAdd !== null) {
        this.accountIDsToAdd = Thrift.copyList(args.accountIDsToAdd, [null]);
      }
      if (args.accountIDsToRemove !== undefined && args.accountIDsToRemove !== null) {
        this.accountIDsToRemove = Thrift.copyList(args.accountIDsToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.news = new News();
          this.news.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.accountIDsToAdd = [];
          const _rtmp346 = input.readSetBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = input.readString().value;
            this.accountIDsToAdd.push(elem48);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.SET) {
          this.accountIDsToRemove = [];
          const _rtmp350 = input.readSetBegin();
          const _size49 = _rtmp350.size || 0;
          for (let _i51 = 0; _i51 < _size49; ++_i51) {
            let elem52 = null;
            elem52 = input.readString().value;
            this.accountIDsToRemove.push(elem52);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdateNews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.news !== null && this.news !== undefined) {
      output.writeFieldBegin('news', Thrift.Type.STRUCT, 2);
      this.news.write(output);
      output.writeFieldEnd();
    }
    if (this.accountIDsToAdd !== null && this.accountIDsToAdd !== undefined) {
      output.writeFieldBegin('accountIDsToAdd', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIDsToAdd.length);
      for (let iter53 in this.accountIDsToAdd) {
        if (this.accountIDsToAdd.hasOwnProperty(iter53)) {
          iter53 = this.accountIDsToAdd[iter53];
          output.writeString(iter53);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.accountIDsToRemove !== null && this.accountIDsToRemove !== undefined) {
      output.writeFieldBegin('accountIDsToRemove', Thrift.Type.SET, 4);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIDsToRemove.length);
      for (let iter54 in this.accountIDsToRemove) {
        if (this.accountIDsToRemove.hasOwnProperty(iter54)) {
          iter54 = this.accountIDsToRemove[iter54];
          output.writeString(iter54);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_createOrUpdateNews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new News(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new News();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdateNews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeNews_args = class {
  constructor(args) {
    this.token = null;
    this.newsId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.newsId !== undefined && args.newsId !== null) {
        this.newsId = args.newsId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.newsId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeNews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.newsId !== null && this.newsId !== undefined) {
      output.writeFieldBegin('newsId', Thrift.Type.STRING, 2);
      output.writeString(this.newsId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeNews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeNews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllExternalModules_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllExternalModules_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllExternalModules_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ExternalModule]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = new ExternalModule();
            elem58.read(input);
            this.success.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllExternalModules_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter59 in this.success) {
        if (this.success.hasOwnProperty(iter59)) {
          iter59 = this.success[iter59];
          iter59.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllExternalModules_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllExternalModules_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllExternalModules_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllExternalModules_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_registerExternalModule_args = class {
  constructor(args) {
    this.token = null;
    this.url = null;
    this.newUser = null;
    this.newUserLogin = null;
    this.adminPassword = null;
    this.protocolType = null;
    this.secretKey = null;
    this.addAccount = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.url !== undefined && args.url !== null) {
        this.url = args.url;
      }
      if (args.newUser !== undefined && args.newUser !== null) {
        this.newUser = new UserOrGroup(args.newUser);
      }
      if (args.newUserLogin !== undefined && args.newUserLogin !== null) {
        this.newUserLogin = args.newUserLogin;
      }
      if (args.adminPassword !== undefined && args.adminPassword !== null) {
        this.adminPassword = args.adminPassword;
      }
      if (args.protocolType !== undefined && args.protocolType !== null) {
        this.protocolType = args.protocolType;
      }
      if (args.secretKey !== undefined && args.secretKey !== null) {
        this.secretKey = args.secretKey;
      }
      if (args.addAccount !== undefined && args.addAccount !== null) {
        this.addAccount = Thrift.copyList(args.addAccount, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.url = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.newUser = new UserOrGroup();
          this.newUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.newUserLogin = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.adminPassword = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.protocolType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.secretKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.SET) {
          this.addAccount = [];
          const _rtmp361 = input.readSetBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = input.readString().value;
            this.addAccount.push(elem63);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_registerExternalModule_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.url !== null && this.url !== undefined) {
      output.writeFieldBegin('url', Thrift.Type.STRING, 2);
      output.writeString(this.url);
      output.writeFieldEnd();
    }
    if (this.newUser !== null && this.newUser !== undefined) {
      output.writeFieldBegin('newUser', Thrift.Type.STRUCT, 3);
      this.newUser.write(output);
      output.writeFieldEnd();
    }
    if (this.newUserLogin !== null && this.newUserLogin !== undefined) {
      output.writeFieldBegin('newUserLogin', Thrift.Type.STRING, 4);
      output.writeString(this.newUserLogin);
      output.writeFieldEnd();
    }
    if (this.adminPassword !== null && this.adminPassword !== undefined) {
      output.writeFieldBegin('adminPassword', Thrift.Type.STRING, 5);
      output.writeString(this.adminPassword);
      output.writeFieldEnd();
    }
    if (this.protocolType !== null && this.protocolType !== undefined) {
      output.writeFieldBegin('protocolType', Thrift.Type.I32, 6);
      output.writeI32(this.protocolType);
      output.writeFieldEnd();
    }
    if (this.secretKey !== null && this.secretKey !== undefined) {
      output.writeFieldBegin('secretKey', Thrift.Type.STRING, 7);
      output.writeString(this.secretKey);
      output.writeFieldEnd();
    }
    if (this.addAccount !== null && this.addAccount !== undefined) {
      output.writeFieldBegin('addAccount', Thrift.Type.SET, 8);
      output.writeSetBegin(Thrift.Type.STRING, this.addAccount.length);
      for (let iter64 in this.addAccount) {
        if (this.addAccount.hasOwnProperty(iter64)) {
          iter64 = this.addAccount[iter64];
          output.writeString(iter64);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_registerExternalModule_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ExternalModule(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ExternalModule();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_registerExternalModule_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeExternalModule_args = class {
  constructor(args) {
    this.token = null;
    this.extModuleId = null;
    this.url = null;
    this.protocolType = null;
    this.secretKey = null;
    this.addAccountIds = null;
    this.deleteAccountIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.extModuleId !== undefined && args.extModuleId !== null) {
        this.extModuleId = args.extModuleId;
      }
      if (args.url !== undefined && args.url !== null) {
        this.url = args.url;
      }
      if (args.protocolType !== undefined && args.protocolType !== null) {
        this.protocolType = args.protocolType;
      }
      if (args.secretKey !== undefined && args.secretKey !== null) {
        this.secretKey = args.secretKey;
      }
      if (args.addAccountIds !== undefined && args.addAccountIds !== null) {
        this.addAccountIds = Thrift.copyList(args.addAccountIds, [null]);
      }
      if (args.deleteAccountIds !== undefined && args.deleteAccountIds !== null) {
        this.deleteAccountIds = Thrift.copyList(args.deleteAccountIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.extModuleId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.url = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.protocolType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.secretKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.SET) {
          this.addAccountIds = [];
          const _rtmp366 = input.readSetBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = input.readString().value;
            this.addAccountIds.push(elem68);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.deleteAccountIds = [];
          const _rtmp370 = input.readSetBegin();
          const _size69 = _rtmp370.size || 0;
          for (let _i71 = 0; _i71 < _size69; ++_i71) {
            let elem72 = null;
            elem72 = input.readString().value;
            this.deleteAccountIds.push(elem72);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeExternalModule_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.extModuleId !== null && this.extModuleId !== undefined) {
      output.writeFieldBegin('extModuleId', Thrift.Type.STRING, 2);
      output.writeString(this.extModuleId);
      output.writeFieldEnd();
    }
    if (this.url !== null && this.url !== undefined) {
      output.writeFieldBegin('url', Thrift.Type.STRING, 3);
      output.writeString(this.url);
      output.writeFieldEnd();
    }
    if (this.protocolType !== null && this.protocolType !== undefined) {
      output.writeFieldBegin('protocolType', Thrift.Type.I32, 4);
      output.writeI32(this.protocolType);
      output.writeFieldEnd();
    }
    if (this.secretKey !== null && this.secretKey !== undefined) {
      output.writeFieldBegin('secretKey', Thrift.Type.STRING, 5);
      output.writeString(this.secretKey);
      output.writeFieldEnd();
    }
    if (this.addAccountIds !== null && this.addAccountIds !== undefined) {
      output.writeFieldBegin('addAccountIds', Thrift.Type.SET, 6);
      output.writeSetBegin(Thrift.Type.STRING, this.addAccountIds.length);
      for (let iter73 in this.addAccountIds) {
        if (this.addAccountIds.hasOwnProperty(iter73)) {
          iter73 = this.addAccountIds[iter73];
          output.writeString(iter73);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.deleteAccountIds !== null && this.deleteAccountIds !== undefined) {
      output.writeFieldBegin('deleteAccountIds', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.STRING, this.deleteAccountIds.length);
      for (let iter74 in this.deleteAccountIds) {
        if (this.deleteAccountIds.hasOwnProperty(iter74)) {
          iter74 = this.deleteAccountIds[iter74];
          output.writeString(iter74);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeExternalModule_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ExternalModule(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ExternalModule();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeExternalModule_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_refreshExternalModule_args = class {
  constructor(args) {
    this.token = null;
    this.extModuleId = null;
    this.removeDeletedStages = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.extModuleId !== undefined && args.extModuleId !== null) {
        this.extModuleId = args.extModuleId;
      }
      if (args.removeDeletedStages !== undefined && args.removeDeletedStages !== null) {
        this.removeDeletedStages = args.removeDeletedStages;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.extModuleId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.removeDeletedStages = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_refreshExternalModule_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.extModuleId !== null && this.extModuleId !== undefined) {
      output.writeFieldBegin('extModuleId', Thrift.Type.STRING, 2);
      output.writeString(this.extModuleId);
      output.writeFieldEnd();
    }
    if (this.removeDeletedStages !== null && this.removeDeletedStages !== undefined) {
      output.writeFieldBegin('removeDeletedStages', Thrift.Type.BOOL, 3);
      output.writeBool(this.removeDeletedStages);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_refreshExternalModule_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ExternalModule(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ExternalModule();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_refreshExternalModule_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeExternalModule_args = class {
  constructor(args) {
    this.token = null;
    this.extModuleId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.extModuleId !== undefined && args.extModuleId !== null) {
        this.extModuleId = args.extModuleId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.extModuleId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeExternalModule_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.extModuleId !== null && this.extModuleId !== undefined) {
      output.writeFieldBegin('extModuleId', Thrift.Type.STRING, 2);
      output.writeString(this.extModuleId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeExternalModule_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeExternalModule_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_pingExternalModule_args = class {
  constructor(args) {
    this.token = null;
    this.extModuleId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.extModuleId !== undefined && args.extModuleId !== null) {
        this.extModuleId = args.extModuleId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.extModuleId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_pingExternalModule_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.extModuleId !== null && this.extModuleId !== undefined) {
      output.writeFieldBegin('extModuleId', Thrift.Type.STRING, 2);
      output.writeString(this.extModuleId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_pingExternalModule_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_pingExternalModule_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllDocumentAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllDocumentAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllDocumentAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp376 = input.readListBegin();
          const _size75 = _rtmp376.size || 0;
          for (let _i77 = 0; _i77 < _size75; ++_i77) {
            let elem78 = null;
            elem78 = new Attachment();
            elem78.read(input);
            this.success.push(elem78);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllDocumentAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter79 in this.success) {
        if (this.success.hasOwnProperty(iter79)) {
          iter79 = this.success[iter79];
          iter79.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllFilledDocumentPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllFilledDocumentPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllFilledDocumentPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = new DocumentPatternStage();
            elem83.read(input);
            this.success.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllFilledDocumentPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter84 in this.success) {
        if (this.success.hasOwnProperty(iter84)) {
          iter84 = this.success[iter84];
          iter84.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_resetDocumentForceMoveError_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_resetDocumentForceMoveError_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_resetDocumentForceMoveError_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_resetDocumentForceMoveError_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeExecutorForPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.patternIds = null;
    this.userOrGroup = null;
    this.usersOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternIds !== undefined && args.patternIds !== null) {
        this.patternIds = Thrift.copyList(args.patternIds, [null]);
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.patternIds = [];
          const _rtmp386 = input.readListBegin();
          const _size85 = _rtmp386.size || 0;
          for (let _i87 = 0; _i87 < _size85; ++_i87) {
            let elem88 = null;
            elem88 = input.readString().value;
            this.patternIds.push(elem88);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp390 = input.readListBegin();
          const _size89 = _rtmp390.size || 0;
          for (let _i91 = 0; _i91 < _size89; ++_i91) {
            let elem92 = null;
            elem92 = new UserOrGroup();
            elem92.read(input);
            this.usersOrGroups.push(elem92);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeExecutorForPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternIds !== null && this.patternIds !== undefined) {
      output.writeFieldBegin('patternIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.patternIds.length);
      for (let iter93 in this.patternIds) {
        if (this.patternIds.hasOwnProperty(iter93)) {
          iter93 = this.patternIds[iter93];
          output.writeString(iter93);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 3);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter94 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter94)) {
          iter94 = this.usersOrGroups[iter94];
          iter94.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeExecutorForPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeExecutorForPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_setUserPublicKey_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.publicKey = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = args.publicKey;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.publicKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_setUserPublicKey_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRING, 3);
      output.writeString(this.publicKey);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_setUserPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_setUserPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeUserPublicKey_args = class {
  constructor(args) {
    this.token = null;
    this.keyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.keyId !== undefined && args.keyId !== null) {
        this.keyId = args.keyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.keyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeUserPublicKey_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.keyId !== null && this.keyId !== undefined) {
      output.writeFieldBegin('keyId', Thrift.Type.STRING, 2);
      output.writeString(this.keyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeUserPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeUserPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUsersRelativeToAccount_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUsersRelativeToAccount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUsersRelativeToAccount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserAcc]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp396 = input.readListBegin();
          const _size95 = _rtmp396.size || 0;
          for (let _i97 = 0; _i97 < _size95; ++_i97) {
            let elem98 = null;
            elem98 = new UserAcc();
            elem98.read(input);
            this.success.push(elem98);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUsersRelativeToAccount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter99 in this.success) {
        if (this.success.hasOwnProperty(iter99)) {
          iter99 = this.success[iter99];
          iter99.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllUsersRelativeToAccount_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllUsersRelativeToAccount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllUsersRelativeToAccount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllUsersRelativeToAccount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeUserAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.accountIdsToAdd = null;
    this.accountIdsToRemove = null;
    this.accountMainId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.accountIdsToAdd !== undefined && args.accountIdsToAdd !== null) {
        this.accountIdsToAdd = Thrift.copyList(args.accountIdsToAdd, [null]);
      }
      if (args.accountIdsToRemove !== undefined && args.accountIdsToRemove !== null) {
        this.accountIdsToRemove = Thrift.copyList(args.accountIdsToRemove, [null]);
      }
      if (args.accountMainId !== undefined && args.accountMainId !== null) {
        this.accountMainId = args.accountMainId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.accountIdsToAdd = [];
          const _rtmp3101 = input.readSetBegin();
          const _size100 = _rtmp3101.size || 0;
          for (let _i102 = 0; _i102 < _size100; ++_i102) {
            let elem103 = null;
            elem103 = input.readString().value;
            this.accountIdsToAdd.push(elem103);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.SET) {
          this.accountIdsToRemove = [];
          const _rtmp3105 = input.readSetBegin();
          const _size104 = _rtmp3105.size || 0;
          for (let _i106 = 0; _i106 < _size104; ++_i106) {
            let elem107 = null;
            elem107 = input.readString().value;
            this.accountIdsToRemove.push(elem107);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.accountMainId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeUserAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.accountIdsToAdd !== null && this.accountIdsToAdd !== undefined) {
      output.writeFieldBegin('accountIdsToAdd', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIdsToAdd.length);
      for (let iter108 in this.accountIdsToAdd) {
        if (this.accountIdsToAdd.hasOwnProperty(iter108)) {
          iter108 = this.accountIdsToAdd[iter108];
          output.writeString(iter108);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.accountIdsToRemove !== null && this.accountIdsToRemove !== undefined) {
      output.writeFieldBegin('accountIdsToRemove', Thrift.Type.SET, 4);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIdsToRemove.length);
      for (let iter109 in this.accountIdsToRemove) {
        if (this.accountIdsToRemove.hasOwnProperty(iter109)) {
          iter109 = this.accountIdsToRemove[iter109];
          output.writeString(iter109);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.accountMainId !== null && this.accountMainId !== undefined) {
      output.writeFieldBegin('accountMainId', Thrift.Type.STRING, 5);
      output.writeString(this.accountMainId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeUserAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeUserAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_runScheduler_args = class {
  constructor(args) {
    this.token = null;
    this.oName = null;
    this.wait = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.wait !== undefined && args.wait !== null) {
        this.wait = args.wait;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.wait = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_runScheduler_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.wait !== null && this.wait !== undefined) {
      output.writeFieldBegin('wait', Thrift.Type.BOOL, 3);
      output.writeBool(this.wait);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_runScheduler_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_runScheduler_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeEncryptKey_args = class {
  constructor(args) {
    this.token = null;
    this.key = null;
    this.accountId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeEncryptKey_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_changeEncryptKey_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_changeEncryptKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUsersExt_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUsersExt_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUsersExt_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserExt]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3111 = input.readListBegin();
          const _size110 = _rtmp3111.size || 0;
          for (let _i112 = 0; _i112 < _size110; ++_i112) {
            let elem113 = null;
            elem113 = new UserExt();
            elem113.read(input);
            this.success.push(elem113);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUsersExt_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter114 in this.success) {
        if (this.success.hasOwnProperty(iter114)) {
          iter114 = this.success[iter114];
          iter114.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllUsersExt_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllUsersExt_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllUsersExt_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllUsersExt_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUserNotifications_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.unreadOnly = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.unreadOnly !== undefined && args.unreadOnly !== null) {
        this.unreadOnly = args.unreadOnly;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.unreadOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUserNotifications_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.unreadOnly !== null && this.unreadOnly !== undefined) {
      output.writeFieldBegin('unreadOnly', Thrift.Type.BOOL, 3);
      output.writeBool(this.unreadOnly);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllUserNotifications_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationQueue]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3116 = input.readListBegin();
          const _size115 = _rtmp3116.size || 0;
          for (let _i117 = 0; _i117 < _size115; ++_i117) {
            let elem118 = null;
            elem118 = new NotificationQueue();
            elem118.read(input);
            this.success.push(elem118);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllUserNotifications_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter119 in this.success) {
        if (this.success.hasOwnProperty(iter119)) {
          iter119 = this.success[iter119];
          iter119.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllNotifications_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllNotifications_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllNotifications_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationQueue]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3121 = input.readListBegin();
          const _size120 = _rtmp3121.size || 0;
          for (let _i122 = 0; _i122 < _size120; ++_i122) {
            let elem123 = null;
            elem123 = new NotificationQueue();
            elem123.read(input);
            this.success.push(elem123);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllNotifications_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter124 in this.success) {
        if (this.success.hasOwnProperty(iter124)) {
          iter124 = this.success[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_moveDocumentOnOtherPatternStage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.resetMoveError = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.resetMoveError !== undefined && args.resetMoveError !== null) {
        this.resetMoveError = args.resetMoveError;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.resetMoveError = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_moveDocumentOnOtherPatternStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.resetMoveError !== null && this.resetMoveError !== undefined) {
      output.writeFieldBegin('resetMoveError', Thrift.Type.BOOL, 4);
      output.writeBool(this.resetMoveError);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_moveDocumentOnOtherPatternStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_moveDocumentOnOtherPatternStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllSessions_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllSessions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllSessions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [AuthSession]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3126 = input.readListBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            let elem128 = null;
            elem128 = new AuthSession();
            elem128.read(input);
            this.success.push(elem128);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllSessions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter129 in this.success) {
        if (this.success.hasOwnProperty(iter129)) {
          iter129 = this.success[iter129];
          iter129.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllSessions_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllSessions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllSessions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllSessions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_confirmUserPublicKey_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    this.confirm = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.confirm !== undefined && args.confirm !== null) {
        this.confirm = args.confirm;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.confirm = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_confirmUserPublicKey_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.confirm !== null && this.confirm !== undefined) {
      output.writeFieldBegin('confirm', Thrift.Type.BOOL, 3);
      output.writeBool(this.confirm);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_confirmUserPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_confirmUserPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_closeSession_args = class {
  constructor(args) {
    this.token = null;
    this.sessionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.sessionId !== undefined && args.sessionId !== null) {
        this.sessionId = args.sessionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.sessionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_closeSession_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.sessionId !== null && this.sessionId !== undefined) {
      output.writeFieldBegin('sessionId', Thrift.Type.STRING, 2);
      output.writeString(this.sessionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_closeSession_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_closeSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_copyPersonalAccess_args = class {
  constructor(args) {
    this.token = null;
    this.copyPersonalAccessSettings = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.copyPersonalAccessSettings !== undefined && args.copyPersonalAccessSettings !== null) {
        this.copyPersonalAccessSettings = new CopyPersonalAccessSettings(args.copyPersonalAccessSettings);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.copyPersonalAccessSettings = new CopyPersonalAccessSettings();
          this.copyPersonalAccessSettings.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_copyPersonalAccess_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.copyPersonalAccessSettings !== null && this.copyPersonalAccessSettings !== undefined) {
      output.writeFieldBegin('copyPersonalAccessSettings', Thrift.Type.STRUCT, 2);
      this.copyPersonalAccessSettings.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_copyPersonalAccess_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_copyPersonalAccess_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllLicenses_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllLicenses_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllLicenses_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [License]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3131 = input.readListBegin();
          const _size130 = _rtmp3131.size || 0;
          for (let _i132 = 0; _i132 < _size130; ++_i132) {
            let elem133 = null;
            elem133 = new License();
            elem133.read(input);
            this.success.push(elem133);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllLicenses_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter134 in this.success) {
        if (this.success.hasOwnProperty(iter134)) {
          iter134 = this.success[iter134];
          iter134.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllLicenses_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllLicenses_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllLicenses_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllLicenses_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_uploadLicenses_args = class {
  constructor(args) {
    this.token = null;
    this.fileContentBytes = null;
    this.accountGroup = null;
    this.account = null;
    this.autoAssignment = null;
    this.autoAssignmentOrder = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
      if (args.accountGroup !== undefined && args.accountGroup !== null) {
        this.accountGroup = new AccountGroup(args.accountGroup);
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.autoAssignment !== undefined && args.autoAssignment !== null) {
        this.autoAssignment = args.autoAssignment;
      }
      if (args.autoAssignmentOrder !== undefined && args.autoAssignmentOrder !== null) {
        this.autoAssignmentOrder = args.autoAssignmentOrder;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accountGroup = new AccountGroup();
          this.accountGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.autoAssignment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.autoAssignmentOrder = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_uploadLicenses_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 2);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    if (this.accountGroup !== null && this.accountGroup !== undefined) {
      output.writeFieldBegin('accountGroup', Thrift.Type.STRUCT, 3);
      this.accountGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 4);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.autoAssignment !== null && this.autoAssignment !== undefined) {
      output.writeFieldBegin('autoAssignment', Thrift.Type.BOOL, 5);
      output.writeBool(this.autoAssignment);
      output.writeFieldEnd();
    }
    if (this.autoAssignmentOrder !== null && this.autoAssignmentOrder !== undefined) {
      output.writeFieldBegin('autoAssignmentOrder', Thrift.Type.I32, 6);
      output.writeI32(this.autoAssignmentOrder);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_uploadLicenses_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [License]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3136 = input.readListBegin();
          const _size135 = _rtmp3136.size || 0;
          for (let _i137 = 0; _i137 < _size135; ++_i137) {
            let elem138 = null;
            elem138 = new License();
            elem138.read(input);
            this.success.push(elem138);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_uploadLicenses_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter139 in this.success) {
        if (this.success.hasOwnProperty(iter139)) {
          iter139 = this.success[iter139];
          iter139.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeLicenses_args = class {
  constructor(args) {
    this.token = null;
    this.lkeys = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.lkeys !== undefined && args.lkeys !== null) {
        this.lkeys = Thrift.copyList(args.lkeys, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.lkeys = [];
          const _rtmp3141 = input.readListBegin();
          const _size140 = _rtmp3141.size || 0;
          for (let _i142 = 0; _i142 < _size140; ++_i142) {
            let elem143 = null;
            elem143 = input.readString().value;
            this.lkeys.push(elem143);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeLicenses_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.lkeys !== null && this.lkeys !== undefined) {
      output.writeFieldBegin('lkeys', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.lkeys.length);
      for (let iter144 in this.lkeys) {
        if (this.lkeys.hasOwnProperty(iter144)) {
          iter144 = this.lkeys[iter144];
          output.writeString(iter144);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_removeLicenses_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_removeLicenses_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_updateLicense_args = class {
  constructor(args) {
    this.token = null;
    this.license = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.license !== undefined && args.license !== null) {
        this.license = new License(args.license);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.license = new License();
          this.license.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_updateLicense_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.license !== null && this.license !== undefined) {
      output.writeFieldBegin('license', Thrift.Type.STRUCT, 2);
      this.license.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_updateLicense_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new License(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new License();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_updateLicense_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_releaseLicence_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_releaseLicence_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_releaseLicence_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_releaseLicence_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_createOrUpdate_args = class {
  constructor(args) {
    this.token = null;
    this.dictionary = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.dictionary !== undefined && args.dictionary !== null) {
        this.dictionary = new CharMatchingDictionary(args.dictionary);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.dictionary = new CharMatchingDictionary();
          this.dictionary.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.dictionary !== null && this.dictionary !== undefined) {
      output.writeFieldBegin('dictionary', Thrift.Type.STRUCT, 2);
      this.dictionary.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_createOrUpdate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new CharMatchingDictionary(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new CharMatchingDictionary();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_createOrUpdate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllCharMatchingDictionaries_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllCharMatchingDictionaries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllCharMatchingDictionaries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CharMatchingDictionary]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3146 = input.readListBegin();
          const _size145 = _rtmp3146.size || 0;
          for (let _i147 = 0; _i147 < _size145; ++_i147) {
            let elem148 = null;
            elem148 = new CharMatchingDictionary();
            elem148.read(input);
            this.success.push(elem148);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllCharMatchingDictionaries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter149 in this.success) {
        if (this.success.hasOwnProperty(iter149)) {
          iter149 = this.success[iter149];
          iter149.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_deleteCharMatchingDictionary_args = class {
  constructor(args) {
    this.token = null;
    this.dictionary = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.dictionary !== undefined && args.dictionary !== null) {
        this.dictionary = args.dictionary;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.dictionary = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_deleteCharMatchingDictionary_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.dictionary !== null && this.dictionary !== undefined) {
      output.writeFieldBegin('dictionary', Thrift.Type.STRING, 2);
      output.writeString(this.dictionary);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_deleteCharMatchingDictionary_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_deleteCharMatchingDictionary_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getTranslations_args = class {
  constructor(args) {
    this.token = null;
    this.langCode = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getTranslations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 2);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getTranslations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getTranslations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_setTranslations_args = class {
  constructor(args) {
    this.token = null;
    this.langCode = null;
    this.langFile = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
      if (args.langFile !== undefined && args.langFile !== null) {
        this.langFile = args.langFile;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.langFile = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_setTranslations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 2);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    if (this.langFile !== null && this.langFile !== undefined) {
      output.writeFieldBegin('langFile', Thrift.Type.STRING, 3);
      output.writeBinary(this.langFile);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_setTranslations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_setTranslations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getDroolLogFile_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getDroolLogFile_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 3);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getDroolLogFile_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getDroolLogFile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_cryptValue_args = class {
  constructor(args) {
    this.token = null;
    this.value = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_cryptValue_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 2);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_cryptValue_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_cryptValue_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllJobTasks_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllJobTasks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getAllJobTasks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [JobTask]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3151 = input.readListBegin();
          const _size150 = _rtmp3151.size || 0;
          for (let _i152 = 0; _i152 < _size150; ++_i152) {
            let elem153 = null;
            elem153 = new JobTask();
            elem153.read(input);
            this.success.push(elem153);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getAllJobTasks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter154 in this.success) {
        if (this.success.hasOwnProperty(iter154)) {
          iter154 = this.success[iter154];
          iter154.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllJobTasks_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllJobTasks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_getCountAllJobTasks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_getCountAllJobTasks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_deleteJobTask_args = class {
  constructor(args) {
    this.token = null;
    this.jobTaskId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.jobTaskId !== undefined && args.jobTaskId !== null) {
        this.jobTaskId = args.jobTaskId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.jobTaskId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_deleteJobTask_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.jobTaskId !== null && this.jobTaskId !== undefined) {
      output.writeFieldBegin('jobTaskId', Thrift.Type.STRING, 2);
      output.writeString(this.jobTaskId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_deleteJobTask_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_deleteJobTask_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_rebuildAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_rebuildAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminService_rebuildAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AdminService_rebuildAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AdminServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  createOrUpdateFileStorage (token, fileStorage, password, accountsToAdd, accountsToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateFileStorage(token, fileStorage, password, accountsToAdd, accountsToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateFileStorage (token, fileStorage, password, accountsToAdd, accountsToRemove, callback) {
    const params = {
      token: token,
      fileStorage: fileStorage,
      password: password,
      accountsToAdd: accountsToAdd,
      accountsToRemove: accountsToRemove
    };
    const args = new AdminService_createOrUpdateFileStorage_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateFileStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateFileStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateFileStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_createOrUpdateFileStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateFileStorage failed: unknown result';
  }

  getAllFileStorages (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllFileStorages(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllFileStorages (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllFileStorages_args(params);
    try {
      this.output.writeMessageBegin('getAllFileStorages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllFileStorages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllFileStorages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllFileStorages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllFileStorages failed: unknown result';
  }

  getCountAllFileStorages (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllFileStorages(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllFileStorages (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllFileStorages_args(params);
    try {
      this.output.writeMessageBegin('getCountAllFileStorages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllFileStorages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllFileStorages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllFileStorages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllFileStorages failed: unknown result';
  }

  removeFileStorages (token, fileStorageIds, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeFileStorages(token, fileStorageIds, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeFileStorages (token, fileStorageIds, password, callback) {
    const params = {
      token: token,
      fileStorageIds: fileStorageIds,
      password: password
    };
    const args = new AdminService_removeFileStorages_args(params);
    try {
      this.output.writeMessageBegin('removeFileStorages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeFileStorages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeFileStorages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_removeFileStorages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeFileStorages failed: unknown result';
  }

  moveAttachment (token, docId, fileStorageId, onlyLatest) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_moveAttachment(token, docId, fileStorageId, onlyLatest, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_moveAttachment (token, docId, fileStorageId, onlyLatest, callback) {
    const params = {
      token: token,
      docId: docId,
      fileStorageId: fileStorageId,
      onlyLatest: onlyLatest
    };
    const args = new AdminService_moveAttachment_args(params);
    try {
      this.output.writeMessageBegin('moveAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_moveAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_moveAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_moveAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'moveAttachment failed: unknown result';
  }

  createOrUpdateNews (token, news, accountIDsToAdd, accountIDsToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateNews(token, news, accountIDsToAdd, accountIDsToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateNews (token, news, accountIDsToAdd, accountIDsToRemove, callback) {
    const params = {
      token: token,
      news: news,
      accountIDsToAdd: accountIDsToAdd,
      accountIDsToRemove: accountIDsToRemove
    };
    const args = new AdminService_createOrUpdateNews_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateNews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateNews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateNews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_createOrUpdateNews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateNews failed: unknown result';
  }

  removeNews (token, newsId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeNews(token, newsId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeNews (token, newsId, callback) {
    const params = {
      token: token,
      newsId: newsId
    };
    const args = new AdminService_removeNews_args(params);
    try {
      this.output.writeMessageBegin('removeNews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeNews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeNews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_removeNews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeNews failed: unknown result';
  }

  getAllExternalModules (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllExternalModules(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllExternalModules (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllExternalModules_args(params);
    try {
      this.output.writeMessageBegin('getAllExternalModules', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllExternalModules();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllExternalModules () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllExternalModules_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllExternalModules failed: unknown result';
  }

  getCountAllExternalModules (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllExternalModules(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllExternalModules (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllExternalModules_args(params);
    try {
      this.output.writeMessageBegin('getCountAllExternalModules', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllExternalModules();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllExternalModules () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllExternalModules_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllExternalModules failed: unknown result';
  }

  registerExternalModule (token, url, newUser, newUserLogin, adminPassword, protocolType, secretKey, addAccount) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_registerExternalModule(token, url, newUser, newUserLogin, adminPassword, protocolType, secretKey, addAccount, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_registerExternalModule (token, url, newUser, newUserLogin, adminPassword, protocolType, secretKey, addAccount, callback) {
    const params = {
      token: token,
      url: url,
      newUser: newUser,
      newUserLogin: newUserLogin,
      adminPassword: adminPassword,
      protocolType: protocolType,
      secretKey: secretKey,
      addAccount: addAccount
    };
    const args = new AdminService_registerExternalModule_args(params);
    try {
      this.output.writeMessageBegin('registerExternalModule', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_registerExternalModule();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_registerExternalModule () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_registerExternalModule_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'registerExternalModule failed: unknown result';
  }

  changeExternalModule (token, extModuleId, url, protocolType, secretKey, addAccountIds, deleteAccountIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeExternalModule(token, extModuleId, url, protocolType, secretKey, addAccountIds, deleteAccountIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeExternalModule (token, extModuleId, url, protocolType, secretKey, addAccountIds, deleteAccountIds, callback) {
    const params = {
      token: token,
      extModuleId: extModuleId,
      url: url,
      protocolType: protocolType,
      secretKey: secretKey,
      addAccountIds: addAccountIds,
      deleteAccountIds: deleteAccountIds
    };
    const args = new AdminService_changeExternalModule_args(params);
    try {
      this.output.writeMessageBegin('changeExternalModule', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeExternalModule();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeExternalModule () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_changeExternalModule_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeExternalModule failed: unknown result';
  }

  refreshExternalModule (token, extModuleId, removeDeletedStages) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_refreshExternalModule(token, extModuleId, removeDeletedStages, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_refreshExternalModule (token, extModuleId, removeDeletedStages, callback) {
    const params = {
      token: token,
      extModuleId: extModuleId,
      removeDeletedStages: removeDeletedStages
    };
    const args = new AdminService_refreshExternalModule_args(params);
    try {
      this.output.writeMessageBegin('refreshExternalModule', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_refreshExternalModule();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_refreshExternalModule () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_refreshExternalModule_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'refreshExternalModule failed: unknown result';
  }

  removeExternalModule (token, extModuleId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeExternalModule(token, extModuleId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeExternalModule (token, extModuleId, password, callback) {
    const params = {
      token: token,
      extModuleId: extModuleId,
      password: password
    };
    const args = new AdminService_removeExternalModule_args(params);
    try {
      this.output.writeMessageBegin('removeExternalModule', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeExternalModule();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeExternalModule () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_removeExternalModule_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeExternalModule failed: unknown result';
  }

  pingExternalModule (token, extModuleId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_pingExternalModule(token, extModuleId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_pingExternalModule (token, extModuleId, callback) {
    const params = {
      token: token,
      extModuleId: extModuleId
    };
    const args = new AdminService_pingExternalModule_args(params);
    try {
      this.output.writeMessageBegin('pingExternalModule', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_pingExternalModule();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_pingExternalModule () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_pingExternalModule_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'pingExternalModule failed: unknown result';
  }

  getAllDocumentAttachments (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentAttachments(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentAttachments (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllDocumentAttachments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllDocumentAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentAttachments failed: unknown result';
  }

  getAllFilledDocumentPatternStages (token, fillDocPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllFilledDocumentPatternStages(token, fillDocPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllFilledDocumentPatternStages (token, fillDocPatternId, filter, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      filter: filter
    };
    const args = new AdminService_getAllFilledDocumentPatternStages_args(params);
    try {
      this.output.writeMessageBegin('getAllFilledDocumentPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllFilledDocumentPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllFilledDocumentPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllFilledDocumentPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllFilledDocumentPatternStages failed: unknown result';
  }

  resetDocumentForceMoveError (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_resetDocumentForceMoveError(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_resetDocumentForceMoveError (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new AdminService_resetDocumentForceMoveError_args(params);
    try {
      this.output.writeMessageBegin('resetDocumentForceMoveError', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_resetDocumentForceMoveError();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_resetDocumentForceMoveError () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_resetDocumentForceMoveError_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'resetDocumentForceMoveError failed: unknown result';
  }

  changeExecutorForPatternStages (token, patternIds, userOrGroup, usersOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeExecutorForPatternStages(token, patternIds, userOrGroup, usersOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeExecutorForPatternStages (token, patternIds, userOrGroup, usersOrGroups, callback) {
    const params = {
      token: token,
      patternIds: patternIds,
      userOrGroup: userOrGroup,
      usersOrGroups: usersOrGroups
    };
    const args = new AdminService_changeExecutorForPatternStages_args(params);
    try {
      this.output.writeMessageBegin('changeExecutorForPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeExecutorForPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeExecutorForPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_changeExecutorForPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeExecutorForPatternStages failed: unknown result';
  }

  setUserPublicKey (token, userId, publicKey, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setUserPublicKey(token, userId, publicKey, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setUserPublicKey (token, userId, publicKey, password, callback) {
    const params = {
      token: token,
      userId: userId,
      publicKey: publicKey,
      password: password
    };
    const args = new AdminService_setUserPublicKey_args(params);
    try {
      this.output.writeMessageBegin('setUserPublicKey', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setUserPublicKey();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setUserPublicKey () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_setUserPublicKey_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setUserPublicKey failed: unknown result';
  }

  removeUserPublicKey (token, keyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeUserPublicKey(token, keyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeUserPublicKey (token, keyId, password, callback) {
    const params = {
      token: token,
      keyId: keyId,
      password: password
    };
    const args = new AdminService_removeUserPublicKey_args(params);
    try {
      this.output.writeMessageBegin('removeUserPublicKey', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeUserPublicKey();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeUserPublicKey () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_removeUserPublicKey_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeUserPublicKey failed: unknown result';
  }

  getAllUsersRelativeToAccount (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUsersRelativeToAccount(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUsersRelativeToAccount (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllUsersRelativeToAccount_args(params);
    try {
      this.output.writeMessageBegin('getAllUsersRelativeToAccount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUsersRelativeToAccount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUsersRelativeToAccount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllUsersRelativeToAccount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUsersRelativeToAccount failed: unknown result';
  }

  getCountAllUsersRelativeToAccount (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUsersRelativeToAccount(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUsersRelativeToAccount (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllUsersRelativeToAccount_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUsersRelativeToAccount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUsersRelativeToAccount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUsersRelativeToAccount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllUsersRelativeToAccount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUsersRelativeToAccount failed: unknown result';
  }

  changeUserAccounts (token, userId, accountIdsToAdd, accountIdsToRemove, accountMainId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeUserAccounts(token, userId, accountIdsToAdd, accountIdsToRemove, accountMainId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeUserAccounts (token, userId, accountIdsToAdd, accountIdsToRemove, accountMainId, callback) {
    const params = {
      token: token,
      userId: userId,
      accountIdsToAdd: accountIdsToAdd,
      accountIdsToRemove: accountIdsToRemove,
      accountMainId: accountMainId
    };
    const args = new AdminService_changeUserAccounts_args(params);
    try {
      this.output.writeMessageBegin('changeUserAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeUserAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeUserAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_changeUserAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeUserAccounts failed: unknown result';
  }

  runScheduler (token, oName, wait) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_runScheduler(token, oName, wait, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_runScheduler (token, oName, wait, callback) {
    const params = {
      token: token,
      oName: oName,
      wait: wait
    };
    const args = new AdminService_runScheduler_args(params);
    try {
      this.output.writeMessageBegin('runScheduler', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_runScheduler();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_runScheduler () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_runScheduler_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'runScheduler failed: unknown result';
  }

  changeEncryptKey (token, key, accountId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeEncryptKey(token, key, accountId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeEncryptKey (token, key, accountId, password, callback) {
    const params = {
      token: token,
      key: key,
      accountId: accountId,
      password: password
    };
    const args = new AdminService_changeEncryptKey_args(params);
    try {
      this.output.writeMessageBegin('changeEncryptKey', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeEncryptKey();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeEncryptKey () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_changeEncryptKey_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeEncryptKey failed: unknown result';
  }

  getAllUsersExt (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUsersExt(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUsersExt (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllUsersExt_args(params);
    try {
      this.output.writeMessageBegin('getAllUsersExt', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUsersExt();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUsersExt () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllUsersExt_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUsersExt failed: unknown result';
  }

  getCountAllUsersExt (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUsersExt(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUsersExt (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllUsersExt_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUsersExt', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUsersExt();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUsersExt () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllUsersExt_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUsersExt failed: unknown result';
  }

  getAllUserNotifications (token, userId, unreadOnly, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUserNotifications(token, userId, unreadOnly, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUserNotifications (token, userId, unreadOnly, filter, callback) {
    const params = {
      token: token,
      userId: userId,
      unreadOnly: unreadOnly,
      filter: filter
    };
    const args = new AdminService_getAllUserNotifications_args(params);
    try {
      this.output.writeMessageBegin('getAllUserNotifications', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUserNotifications();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUserNotifications () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllUserNotifications_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUserNotifications failed: unknown result';
  }

  getAllNotifications (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNotifications(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNotifications (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllNotifications_args(params);
    try {
      this.output.writeMessageBegin('getAllNotifications', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNotifications();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNotifications () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllNotifications_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNotifications failed: unknown result';
  }

  moveDocumentOnOtherPatternStage (token, documentId, stageId, resetMoveError) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_moveDocumentOnOtherPatternStage(token, documentId, stageId, resetMoveError, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_moveDocumentOnOtherPatternStage (token, documentId, stageId, resetMoveError, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      resetMoveError: resetMoveError
    };
    const args = new AdminService_moveDocumentOnOtherPatternStage_args(params);
    try {
      this.output.writeMessageBegin('moveDocumentOnOtherPatternStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_moveDocumentOnOtherPatternStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_moveDocumentOnOtherPatternStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_moveDocumentOnOtherPatternStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'moveDocumentOnOtherPatternStage failed: unknown result';
  }

  getAllSessions (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSessions(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSessions (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllSessions_args(params);
    try {
      this.output.writeMessageBegin('getAllSessions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSessions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSessions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllSessions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSessions failed: unknown result';
  }

  getCountAllSessions (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllSessions(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllSessions (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllSessions_args(params);
    try {
      this.output.writeMessageBegin('getCountAllSessions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllSessions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllSessions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllSessions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllSessions failed: unknown result';
  }

  confirmUserPublicKey (token, id, confirm) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_confirmUserPublicKey(token, id, confirm, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_confirmUserPublicKey (token, id, confirm, callback) {
    const params = {
      token: token,
      id: id,
      confirm: confirm
    };
    const args = new AdminService_confirmUserPublicKey_args(params);
    try {
      this.output.writeMessageBegin('confirmUserPublicKey', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_confirmUserPublicKey();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_confirmUserPublicKey () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_confirmUserPublicKey_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'confirmUserPublicKey failed: unknown result';
  }

  closeSession (token, sessionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_closeSession(token, sessionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_closeSession (token, sessionId, callback) {
    const params = {
      token: token,
      sessionId: sessionId
    };
    const args = new AdminService_closeSession_args(params);
    try {
      this.output.writeMessageBegin('closeSession', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_closeSession();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_closeSession () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_closeSession_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'closeSession failed: unknown result';
  }

  copyPersonalAccess (token, copyPersonalAccessSettings) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_copyPersonalAccess(token, copyPersonalAccessSettings, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_copyPersonalAccess (token, copyPersonalAccessSettings, callback) {
    const params = {
      token: token,
      copyPersonalAccessSettings: copyPersonalAccessSettings
    };
    const args = new AdminService_copyPersonalAccess_args(params);
    try {
      this.output.writeMessageBegin('copyPersonalAccess', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_copyPersonalAccess();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_copyPersonalAccess () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_copyPersonalAccess_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'copyPersonalAccess failed: unknown result';
  }

  getAllLicenses (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllLicenses(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllLicenses (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllLicenses_args(params);
    try {
      this.output.writeMessageBegin('getAllLicenses', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllLicenses();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllLicenses () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllLicenses_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllLicenses failed: unknown result';
  }

  getCountAllLicenses (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllLicenses(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllLicenses (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllLicenses_args(params);
    try {
      this.output.writeMessageBegin('getCountAllLicenses', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllLicenses();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllLicenses () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllLicenses_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllLicenses failed: unknown result';
  }

  uploadLicenses (token, fileContentBytes, accountGroup, account, autoAssignment, autoAssignmentOrder) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadLicenses(token, fileContentBytes, accountGroup, account, autoAssignment, autoAssignmentOrder, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadLicenses (token, fileContentBytes, accountGroup, account, autoAssignment, autoAssignmentOrder, callback) {
    const params = {
      token: token,
      fileContentBytes: fileContentBytes,
      accountGroup: accountGroup,
      account: account,
      autoAssignment: autoAssignment,
      autoAssignmentOrder: autoAssignmentOrder
    };
    const args = new AdminService_uploadLicenses_args(params);
    try {
      this.output.writeMessageBegin('uploadLicenses', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadLicenses();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadLicenses () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_uploadLicenses_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadLicenses failed: unknown result';
  }

  removeLicenses (token, lkeys) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeLicenses(token, lkeys, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeLicenses (token, lkeys, callback) {
    const params = {
      token: token,
      lkeys: lkeys
    };
    const args = new AdminService_removeLicenses_args(params);
    try {
      this.output.writeMessageBegin('removeLicenses', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeLicenses();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeLicenses () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_removeLicenses_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeLicenses failed: unknown result';
  }

  updateLicense (token, license) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateLicense(token, license, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateLicense (token, license, callback) {
    const params = {
      token: token,
      license: license
    };
    const args = new AdminService_updateLicense_args(params);
    try {
      this.output.writeMessageBegin('updateLicense', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateLicense();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateLicense () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_updateLicense_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateLicense failed: unknown result';
  }

  releaseLicence (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_releaseLicence(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_releaseLicence (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new AdminService_releaseLicence_args(params);
    try {
      this.output.writeMessageBegin('releaseLicence', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_releaseLicence();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_releaseLicence () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_releaseLicence_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'releaseLicence failed: unknown result';
  }

  createOrUpdate (token, dictionary) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdate(token, dictionary, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdate (token, dictionary, callback) {
    const params = {
      token: token,
      dictionary: dictionary
    };
    const args = new AdminService_createOrUpdate_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_createOrUpdate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdate failed: unknown result';
  }

  getAllCharMatchingDictionaries (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllCharMatchingDictionaries(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllCharMatchingDictionaries (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllCharMatchingDictionaries_args(params);
    try {
      this.output.writeMessageBegin('getAllCharMatchingDictionaries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllCharMatchingDictionaries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllCharMatchingDictionaries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllCharMatchingDictionaries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllCharMatchingDictionaries failed: unknown result';
  }

  deleteCharMatchingDictionary (token, dictionary) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteCharMatchingDictionary(token, dictionary, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteCharMatchingDictionary (token, dictionary, callback) {
    const params = {
      token: token,
      dictionary: dictionary
    };
    const args = new AdminService_deleteCharMatchingDictionary_args(params);
    try {
      this.output.writeMessageBegin('deleteCharMatchingDictionary', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteCharMatchingDictionary();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteCharMatchingDictionary () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_deleteCharMatchingDictionary_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteCharMatchingDictionary failed: unknown result';
  }

  getTranslations (token, langCode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTranslations(token, langCode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTranslations (token, langCode, callback) {
    const params = {
      token: token,
      langCode: langCode
    };
    const args = new AdminService_getTranslations_args(params);
    try {
      this.output.writeMessageBegin('getTranslations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTranslations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTranslations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getTranslations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTranslations failed: unknown result';
  }

  setTranslations (token, langCode, langFile) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setTranslations(token, langCode, langFile, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setTranslations (token, langCode, langFile, callback) {
    const params = {
      token: token,
      langCode: langCode,
      langFile: langFile
    };
    const args = new AdminService_setTranslations_args(params);
    try {
      this.output.writeMessageBegin('setTranslations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setTranslations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setTranslations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_setTranslations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setTranslations failed: unknown result';
  }

  getDroolLogFile (token, docId, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDroolLogFile(token, docId, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDroolLogFile (token, docId, policy, callback) {
    const params = {
      token: token,
      docId: docId,
      policy: policy
    };
    const args = new AdminService_getDroolLogFile_args(params);
    try {
      this.output.writeMessageBegin('getDroolLogFile', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDroolLogFile();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDroolLogFile () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getDroolLogFile_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDroolLogFile failed: unknown result';
  }

  cryptValue (token, value) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_cryptValue(token, value, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_cryptValue (token, value, callback) {
    const params = {
      token: token,
      value: value
    };
    const args = new AdminService_cryptValue_args(params);
    try {
      this.output.writeMessageBegin('cryptValue', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_cryptValue();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_cryptValue () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_cryptValue_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'cryptValue failed: unknown result';
  }

  getAllJobTasks (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllJobTasks(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllJobTasks (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getAllJobTasks_args(params);
    try {
      this.output.writeMessageBegin('getAllJobTasks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllJobTasks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllJobTasks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getAllJobTasks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllJobTasks failed: unknown result';
  }

  getCountAllJobTasks (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllJobTasks(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllJobTasks (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new AdminService_getCountAllJobTasks_args(params);
    try {
      this.output.writeMessageBegin('getCountAllJobTasks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllJobTasks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllJobTasks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_getCountAllJobTasks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllJobTasks failed: unknown result';
  }

  deleteJobTask (token, jobTaskId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteJobTask(token, jobTaskId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteJobTask (token, jobTaskId, callback) {
    const params = {
      token: token,
      jobTaskId: jobTaskId
    };
    const args = new AdminService_deleteJobTask_args(params);
    try {
      this.output.writeMessageBegin('deleteJobTask', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteJobTask();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteJobTask () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_deleteJobTask_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteJobTask failed: unknown result';
  }

  rebuildAttachment (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_rebuildAttachment(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_rebuildAttachment (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new AdminService_rebuildAttachment_args(params);
    try {
      this.output.writeMessageBegin('rebuildAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_rebuildAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_rebuildAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AdminService_rebuildAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'rebuildAttachment failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

AggregationDataService_getDocumentData_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.requiredData = null;
    this.policy = null;
    this.decrypt = null;
    this.executorsPortion = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.requiredData !== undefined && args.requiredData !== null) {
        this.requiredData = Thrift.copyList(args.requiredData, [null]);
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
      if (args.decrypt !== undefined && args.decrypt !== null) {
        this.decrypt = args.decrypt;
      }
      if (args.executorsPortion !== undefined && args.executorsPortion !== null) {
        this.executorsPortion = args.executorsPortion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.requiredData = [];
          const _rtmp368 = input.readSetBegin();
          const _size67 = _rtmp368.size || 0;
          for (let _i69 = 0; _i69 < _size67; ++_i69) {
            let elem70 = null;
            elem70 = input.readI32().value;
            this.requiredData.push(elem70);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.decrypt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.executorsPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getDocumentData_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.requiredData !== null && this.requiredData !== undefined) {
      output.writeFieldBegin('requiredData', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.I32, this.requiredData.length);
      for (let iter71 in this.requiredData) {
        if (this.requiredData.hasOwnProperty(iter71)) {
          iter71 = this.requiredData[iter71];
          output.writeI32(iter71);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    if (this.decrypt !== null && this.decrypt !== undefined) {
      output.writeFieldBegin('decrypt', Thrift.Type.BOOL, 5);
      output.writeBool(this.decrypt);
      output.writeFieldEnd();
    }
    if (this.executorsPortion !== null && this.executorsPortion !== undefined) {
      output.writeFieldBegin('executorsPortion', Thrift.Type.I32, 6);
      output.writeI32(this.executorsPortion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getDocumentData_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AggregationDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AggregationDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getDocumentData_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getAllRegistries_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.forAdmin = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.forAdmin !== undefined && args.forAdmin !== null) {
        this.forAdmin = args.forAdmin;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.forAdmin = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getAllRegistries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.forAdmin !== null && this.forAdmin !== undefined) {
      output.writeFieldBegin('forAdmin', Thrift.Type.BOOL, 3);
      output.writeBool(this.forAdmin);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getAllRegistries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Registry]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp373 = input.readListBegin();
          const _size72 = _rtmp373.size || 0;
          for (let _i74 = 0; _i74 < _size72; ++_i74) {
            let elem75 = null;
            elem75 = new Registry();
            elem75.read(input);
            this.success.push(elem75);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getAllRegistries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter76 in this.success) {
        if (this.success.hasOwnProperty(iter76)) {
          iter76 = this.success[iter76];
          iter76.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getCountAllRegistries_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.forAdmin = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.forAdmin !== undefined && args.forAdmin !== null) {
        this.forAdmin = args.forAdmin;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.forAdmin = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getCountAllRegistries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.forAdmin !== null && this.forAdmin !== undefined) {
      output.writeFieldBegin('forAdmin', Thrift.Type.BOOL, 3);
      output.writeBool(this.forAdmin);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getCountAllRegistries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getCountAllRegistries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getRegistryById_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    this.requiredData = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.requiredData !== undefined && args.requiredData !== null) {
        this.requiredData = Thrift.copyList(args.requiredData, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.requiredData = [];
          const _rtmp378 = input.readSetBegin();
          const _size77 = _rtmp378.size || 0;
          for (let _i79 = 0; _i79 < _size77; ++_i79) {
            let elem80 = null;
            elem80 = input.readI32().value;
            this.requiredData.push(elem80);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getRegistryById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.requiredData !== null && this.requiredData !== undefined) {
      output.writeFieldBegin('requiredData', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.I32, this.requiredData.length);
      for (let iter81 in this.requiredData) {
        if (this.requiredData.hasOwnProperty(iter81)) {
          iter81 = this.requiredData[iter81];
          output.writeI32(iter81);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_getRegistryById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Registry(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Registry();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_getRegistryById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_removeRegistry_args = class {
  constructor(args) {
    this.token = null;
    this.registryId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.registryId !== undefined && args.registryId !== null) {
        this.registryId = args.registryId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.registryId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_removeRegistry_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.registryId !== null && this.registryId !== undefined) {
      output.writeFieldBegin('registryId', Thrift.Type.STRING, 2);
      output.writeString(this.registryId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_removeRegistry_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_removeRegistry_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_createOrUpdateRegistry_args = class {
  constructor(args) {
    this.token = null;
    this.registry = null;
    this.userOrGroupList = null;
    this.accountList = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.registry !== undefined && args.registry !== null) {
        this.registry = new Registry(args.registry);
      }
      if (args.userOrGroupList !== undefined && args.userOrGroupList !== null) {
        this.userOrGroupList = Thrift.copyList(args.userOrGroupList, [UserOrGroup]);
      }
      if (args.accountList !== undefined && args.accountList !== null) {
        this.accountList = Thrift.copyList(args.accountList, [Account]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.registry = new Registry();
          this.registry.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroupList = [];
          const _rtmp383 = input.readListBegin();
          const _size82 = _rtmp383.size || 0;
          for (let _i84 = 0; _i84 < _size82; ++_i84) {
            let elem85 = null;
            elem85 = new UserOrGroup();
            elem85.read(input);
            this.userOrGroupList.push(elem85);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.accountList = [];
          const _rtmp387 = input.readListBegin();
          const _size86 = _rtmp387.size || 0;
          for (let _i88 = 0; _i88 < _size86; ++_i88) {
            let elem89 = null;
            elem89 = new Account();
            elem89.read(input);
            this.accountList.push(elem89);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_createOrUpdateRegistry_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.registry !== null && this.registry !== undefined) {
      output.writeFieldBegin('registry', Thrift.Type.STRUCT, 2);
      this.registry.write(output);
      output.writeFieldEnd();
    }
    if (this.userOrGroupList !== null && this.userOrGroupList !== undefined) {
      output.writeFieldBegin('userOrGroupList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroupList.length);
      for (let iter90 in this.userOrGroupList) {
        if (this.userOrGroupList.hasOwnProperty(iter90)) {
          iter90 = this.userOrGroupList[iter90];
          iter90.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accountList !== null && this.accountList !== undefined) {
      output.writeFieldBegin('accountList', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.accountList.length);
      for (let iter91 in this.accountList) {
        if (this.accountList.hasOwnProperty(iter91)) {
          iter91 = this.accountList[iter91];
          iter91.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_createOrUpdateRegistry_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Registry(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Registry();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_createOrUpdateRegistry_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_compareJiraTime_args = class {
  constructor(args) {
    this.jiraTime1 = null;
    this.jiraTime2 = null;
    if (args) {
      if (args.jiraTime1 !== undefined && args.jiraTime1 !== null) {
        this.jiraTime1 = args.jiraTime1;
      }
      if (args.jiraTime2 !== undefined && args.jiraTime2 !== null) {
        this.jiraTime2 = args.jiraTime2;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.jiraTime1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.jiraTime2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_compareJiraTime_args');
    if (this.jiraTime1 !== null && this.jiraTime1 !== undefined) {
      output.writeFieldBegin('jiraTime1', Thrift.Type.STRING, 1);
      output.writeString(this.jiraTime1);
      output.writeFieldEnd();
    }
    if (this.jiraTime2 !== null && this.jiraTime2 !== undefined) {
      output.writeFieldBegin('jiraTime2', Thrift.Type.STRING, 2);
      output.writeString(this.jiraTime2);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataService_compareJiraTime_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDataService_compareJiraTime_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDataServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getDocumentData (token, documentId, requiredData, policy, decrypt, executorsPortion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentData(token, documentId, requiredData, policy, decrypt, executorsPortion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentData (token, documentId, requiredData, policy, decrypt, executorsPortion, callback) {
    const params = {
      token: token,
      documentId: documentId,
      requiredData: requiredData,
      policy: policy,
      decrypt: decrypt,
      executorsPortion: executorsPortion
    };
    const args = new AggregationDataService_getDocumentData_args(params);
    try {
      this.output.writeMessageBegin('getDocumentData', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentData();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentData () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_getDocumentData_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentData failed: unknown result';
  }

  getAllRegistries (token, filter, forAdmin) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllRegistries(token, filter, forAdmin, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllRegistries (token, filter, forAdmin, callback) {
    const params = {
      token: token,
      filter: filter,
      forAdmin: forAdmin
    };
    const args = new AggregationDataService_getAllRegistries_args(params);
    try {
      this.output.writeMessageBegin('getAllRegistries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllRegistries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllRegistries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_getAllRegistries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllRegistries failed: unknown result';
  }

  getCountAllRegistries (token, filter, forAdmin) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllRegistries(token, filter, forAdmin, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllRegistries (token, filter, forAdmin, callback) {
    const params = {
      token: token,
      filter: filter,
      forAdmin: forAdmin
    };
    const args = new AggregationDataService_getCountAllRegistries_args(params);
    try {
      this.output.writeMessageBegin('getCountAllRegistries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllRegistries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllRegistries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_getCountAllRegistries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllRegistries failed: unknown result';
  }

  getRegistryById (token, id, requiredData) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getRegistryById(token, id, requiredData, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getRegistryById (token, id, requiredData, callback) {
    const params = {
      token: token,
      id: id,
      requiredData: requiredData
    };
    const args = new AggregationDataService_getRegistryById_args(params);
    try {
      this.output.writeMessageBegin('getRegistryById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getRegistryById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getRegistryById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_getRegistryById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getRegistryById failed: unknown result';
  }

  removeRegistry (token, registryId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeRegistry(token, registryId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeRegistry (token, registryId, callback) {
    const params = {
      token: token,
      registryId: registryId
    };
    const args = new AggregationDataService_removeRegistry_args(params);
    try {
      this.output.writeMessageBegin('removeRegistry', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeRegistry();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeRegistry () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_removeRegistry_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeRegistry failed: unknown result';
  }

  createOrUpdateRegistry (token, registry, userOrGroupList, accountList) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateRegistry(token, registry, userOrGroupList, accountList, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateRegistry (token, registry, userOrGroupList, accountList, callback) {
    const params = {
      token: token,
      registry: registry,
      userOrGroupList: userOrGroupList,
      accountList: accountList
    };
    const args = new AggregationDataService_createOrUpdateRegistry_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateRegistry', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateRegistry();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateRegistry () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_createOrUpdateRegistry_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateRegistry failed: unknown result';
  }

  compareJiraTime (jiraTime1, jiraTime2) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_compareJiraTime(jiraTime1, jiraTime2, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_compareJiraTime (jiraTime1, jiraTime2, callback) {
    const params = {
      jiraTime1: jiraTime1,
      jiraTime2: jiraTime2
    };
    const args = new AggregationDataService_compareJiraTime_args(params);
    try {
      this.output.writeMessageBegin('compareJiraTime', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_compareJiraTime();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_compareJiraTime () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AggregationDataService_compareJiraTime_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'compareJiraTime failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

AuthService_authenticate_args = class {
  constructor(args) {
    this.login = null;
    this.password = null;
    this.device = null;
    this.ip = null;
    this.findOpened = null;
    this.langCode = null;
    this.cacheVersion = null;
    if (args) {
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.device !== undefined && args.device !== null) {
        this.device = new Device(args.device);
      }
      if (args.ip !== undefined && args.ip !== null) {
        this.ip = args.ip;
      }
      if (args.findOpened !== undefined && args.findOpened !== null) {
        this.findOpened = args.findOpened;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
      if (args.cacheVersion !== undefined && args.cacheVersion !== null) {
        this.cacheVersion = args.cacheVersion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.device = new Device();
          this.device.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.ip = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.findOpened = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.cacheVersion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticate_args');
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 1);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 2);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.device !== null && this.device !== undefined) {
      output.writeFieldBegin('device', Thrift.Type.STRUCT, 3);
      this.device.write(output);
      output.writeFieldEnd();
    }
    if (this.ip !== null && this.ip !== undefined) {
      output.writeFieldBegin('ip', Thrift.Type.STRING, 4);
      output.writeString(this.ip);
      output.writeFieldEnd();
    }
    if (this.findOpened !== null && this.findOpened !== undefined) {
      output.writeFieldBegin('findOpened', Thrift.Type.BOOL, 5);
      output.writeBool(this.findOpened);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 6);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    if (this.cacheVersion !== null && this.cacheVersion !== undefined) {
      output.writeFieldBegin('cacheVersion', Thrift.Type.I32, 7);
      output.writeI32(this.cacheVersion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_authenticate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AuthSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AuthSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_authenticateGuest_args = class {
  constructor(args) {
    this.guestId = null;
    this.password = null;
    this.ip = null;
    this.langCode = null;
    if (args) {
      if (args.guestId !== undefined && args.guestId !== null) {
        this.guestId = args.guestId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.ip !== undefined && args.ip !== null) {
        this.ip = args.ip;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.guestId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ip = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticateGuest_args');
    if (this.guestId !== null && this.guestId !== undefined) {
      output.writeFieldBegin('guestId', Thrift.Type.STRING, 1);
      output.writeString(this.guestId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 2);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.ip !== null && this.ip !== undefined) {
      output.writeFieldBegin('ip', Thrift.Type.STRING, 3);
      output.writeString(this.ip);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 4);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_authenticateGuest_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AuthSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AuthSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticateGuest_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_refreshAuthSession_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_refreshAuthSession_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_refreshAuthSession_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AuthSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AuthSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_refreshAuthSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_isAuthSessionExpired_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_isAuthSessionExpired_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_isAuthSessionExpired_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_isAuthSessionExpired_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_changePassword_args = class {
  constructor(args) {
    this.token = null;
    this.oldPassword = null;
    this.password = null;
    this.confirmation = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.oldPassword !== undefined && args.oldPassword !== null) {
        this.oldPassword = args.oldPassword;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.confirmation !== undefined && args.confirmation !== null) {
        this.confirmation = args.confirmation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oldPassword = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.confirmation = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_changePassword_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.oldPassword !== null && this.oldPassword !== undefined) {
      output.writeFieldBegin('oldPassword', Thrift.Type.STRING, 2);
      output.writeString(this.oldPassword);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.confirmation !== null && this.confirmation !== undefined) {
      output.writeFieldBegin('confirmation', Thrift.Type.STRING, 4);
      output.writeString(this.confirmation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_changePassword_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_changePassword_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_requestResetPassword_args = class {
  constructor(args) {
    this.token = null;
    this.login = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_requestResetPassword_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 2);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_requestResetPassword_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_requestResetPassword_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_finishResetPassword_args = class {
  constructor(args) {
    this.login = null;
    this.confirmationCode = null;
    this.password = null;
    this.confirmation = null;
    if (args) {
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.confirmationCode !== undefined && args.confirmationCode !== null) {
        this.confirmationCode = args.confirmationCode;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.confirmation !== undefined && args.confirmation !== null) {
        this.confirmation = args.confirmation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.confirmationCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.confirmation = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_finishResetPassword_args');
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 1);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.confirmationCode !== null && this.confirmationCode !== undefined) {
      output.writeFieldBegin('confirmationCode', Thrift.Type.STRING, 2);
      output.writeString(this.confirmationCode);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.confirmation !== null && this.confirmation !== undefined) {
      output.writeFieldBegin('confirmation', Thrift.Type.STRING, 4);
      output.writeString(this.confirmation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_finishResetPassword_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AuthSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AuthSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_finishResetPassword_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_logout_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_logout_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_logout_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_logout_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_authenticateAs_args = class {
  constructor(args) {
    this.token = null;
    this.toUserId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toUserId !== undefined && args.toUserId !== null) {
        this.toUserId = args.toUserId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.toUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticateAs_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toUserId !== null && this.toUserId !== undefined) {
      output.writeFieldBegin('toUserId', Thrift.Type.STRING, 2);
      output.writeString(this.toUserId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_authenticateAs_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new AuthSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new AuthSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_authenticateAs_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_getInfo_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_getInfo_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_getInfo_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp311 = input.readMapBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            if (_i12 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key13 = null;
            let val14 = null;
            key13 = input.readString().value;
            val14 = input.readString().value;
            this.success[key13] = val14;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_getInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter15 in this.success) {
        if (this.success.hasOwnProperty(kiter15)) {
          let viter16 = this.success[kiter15];
          output.writeString(kiter15);
          output.writeString(viter16);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_extendSession_args = class {
  constructor(args) {
    this.token = null;
    this.keyword = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.keyword !== undefined && args.keyword !== null) {
        this.keyword = args.keyword;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.keyword = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_extendSession_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.keyword !== null && this.keyword !== undefined) {
      output.writeFieldBegin('keyword', Thrift.Type.STRING, 2);
      output.writeString(this.keyword);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_extendSession_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_extendSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_getAllLanguages_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_getAllLanguages_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_getAllLanguages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp318 = input.readMapBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            if (_i19 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key20 = null;
            let val21 = null;
            key20 = input.readString().value;
            val21 = input.readString().value;
            this.success[key20] = val21;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_getAllLanguages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter22 in this.success) {
        if (this.success.hasOwnProperty(kiter22)) {
          let viter23 = this.success[kiter22];
          output.writeString(kiter22);
          output.writeString(viter23);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_generateNewTokenForLang_args = class {
  constructor(args) {
    this.token = null;
    this.newLang = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.newLang !== undefined && args.newLang !== null) {
        this.newLang = args.newLang;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.newLang = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_generateNewTokenForLang_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.newLang !== null && this.newLang !== undefined) {
      output.writeFieldBegin('newLang', Thrift.Type.STRING, 2);
      output.writeString(this.newLang);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthService_generateNewTokenForLang_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthService_generateNewTokenForLang_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  authenticate (login, password, device, ip, findOpened, langCode, cacheVersion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_authenticate(login, password, device, ip, findOpened, langCode, cacheVersion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_authenticate (login, password, device, ip, findOpened, langCode, cacheVersion, callback) {
    const params = {
      login: login,
      password: password,
      device: device,
      ip: ip,
      findOpened: findOpened,
      langCode: langCode,
      cacheVersion: cacheVersion
    };
    const args = new AuthService_authenticate_args(params);
    try {
      this.output.writeMessageBegin('authenticate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_authenticate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_authenticate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_authenticate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'authenticate failed: unknown result';
  }

  authenticateGuest (guestId, password, ip, langCode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_authenticateGuest(guestId, password, ip, langCode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_authenticateGuest (guestId, password, ip, langCode, callback) {
    const params = {
      guestId: guestId,
      password: password,
      ip: ip,
      langCode: langCode
    };
    const args = new AuthService_authenticateGuest_args(params);
    try {
      this.output.writeMessageBegin('authenticateGuest', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_authenticateGuest();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_authenticateGuest () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_authenticateGuest_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'authenticateGuest failed: unknown result';
  }

  refreshAuthSession (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_refreshAuthSession(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_refreshAuthSession (token, callback) {
    const params = {
      token: token
    };
    const args = new AuthService_refreshAuthSession_args(params);
    try {
      this.output.writeMessageBegin('refreshAuthSession', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_refreshAuthSession();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_refreshAuthSession () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_refreshAuthSession_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'refreshAuthSession failed: unknown result';
  }

  isAuthSessionExpired (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_isAuthSessionExpired(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_isAuthSessionExpired (token, callback) {
    const params = {
      token: token
    };
    const args = new AuthService_isAuthSessionExpired_args(params);
    try {
      this.output.writeMessageBegin('isAuthSessionExpired', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_isAuthSessionExpired();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_isAuthSessionExpired () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_isAuthSessionExpired_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'isAuthSessionExpired failed: unknown result';
  }

  changePassword (token, oldPassword, password, confirmation) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changePassword(token, oldPassword, password, confirmation, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changePassword (token, oldPassword, password, confirmation, callback) {
    const params = {
      token: token,
      oldPassword: oldPassword,
      password: password,
      confirmation: confirmation
    };
    const args = new AuthService_changePassword_args(params);
    try {
      this.output.writeMessageBegin('changePassword', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changePassword();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changePassword () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_changePassword_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changePassword failed: unknown result';
  }

  requestResetPassword (token, login) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_requestResetPassword(token, login, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_requestResetPassword (token, login, callback) {
    const params = {
      token: token,
      login: login
    };
    const args = new AuthService_requestResetPassword_args(params);
    try {
      this.output.writeMessageBegin('requestResetPassword', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_requestResetPassword();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_requestResetPassword () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_requestResetPassword_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'requestResetPassword failed: unknown result';
  }

  finishResetPassword (login, confirmationCode, password, confirmation) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_finishResetPassword(login, confirmationCode, password, confirmation, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_finishResetPassword (login, confirmationCode, password, confirmation, callback) {
    const params = {
      login: login,
      confirmationCode: confirmationCode,
      password: password,
      confirmation: confirmation
    };
    const args = new AuthService_finishResetPassword_args(params);
    try {
      this.output.writeMessageBegin('finishResetPassword', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_finishResetPassword();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_finishResetPassword () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_finishResetPassword_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'finishResetPassword failed: unknown result';
  }

  logout (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_logout(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_logout (token, callback) {
    const params = {
      token: token
    };
    const args = new AuthService_logout_args(params);
    try {
      this.output.writeMessageBegin('logout', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_logout();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_logout () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_logout_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'logout failed: unknown result';
  }

  authenticateAs (token, toUserId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_authenticateAs(token, toUserId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_authenticateAs (token, toUserId, callback) {
    const params = {
      token: token,
      toUserId: toUserId
    };
    const args = new AuthService_authenticateAs_args(params);
    try {
      this.output.writeMessageBegin('authenticateAs', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_authenticateAs();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_authenticateAs () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_authenticateAs_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'authenticateAs failed: unknown result';
  }

  getInfo () {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getInfo((error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getInfo (callback) {
    const args = new AuthService_getInfo_args();
    try {
      this.output.writeMessageBegin('getInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_getInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.success) {
      return result.success;
    }
    throw 'getInfo failed: unknown result';
  }

  extendSession (token, keyword) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_extendSession(token, keyword, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_extendSession (token, keyword, callback) {
    const params = {
      token: token,
      keyword: keyword
    };
    const args = new AuthService_extendSession_args(params);
    try {
      this.output.writeMessageBegin('extendSession', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_extendSession();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_extendSession () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_extendSession_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'extendSession failed: unknown result';
  }

  getAllLanguages () {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllLanguages((error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllLanguages (callback) {
    const args = new AuthService_getAllLanguages_args();
    try {
      this.output.writeMessageBegin('getAllLanguages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllLanguages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllLanguages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_getAllLanguages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllLanguages failed: unknown result';
  }

  generateNewTokenForLang (token, newLang) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateNewTokenForLang(token, newLang, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateNewTokenForLang (token, newLang, callback) {
    const params = {
      token: token,
      newLang: newLang
    };
    const args = new AuthService_generateNewTokenForLang_args(params);
    try {
      this.output.writeMessageBegin('generateNewTokenForLang', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateNewTokenForLang();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateNewTokenForLang () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new AuthService_generateNewTokenForLang_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateNewTokenForLang failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

CalendarService_getAllEvents_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.usersOrGroups = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new UserOrGroup();
            elem8.read(input);
            this.usersOrGroups.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllEvents_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter9 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter9)) {
          iter9 = this.usersOrGroups[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllEvents_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CalendarEvent]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new CalendarEvent();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllEvents_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteEvent_args = class {
  constructor(args) {
    this.token = null;
    this.eventId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.eventId !== undefined && args.eventId !== null) {
        this.eventId = args.eventId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.eventId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteEvent_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.eventId !== null && this.eventId !== undefined) {
      output.writeFieldBegin('eventId', Thrift.Type.STRING, 2);
      output.writeString(this.eventId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteEvent_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteEvent_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateEvent_args = class {
  constructor(args) {
    this.token = null;
    this.event = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.event !== undefined && args.event !== null) {
        this.event = new CalendarEvent(args.event);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.event = new CalendarEvent();
          this.event.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateEvent_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.event !== null && this.event !== undefined) {
      output.writeFieldBegin('event', Thrift.Type.STRUCT, 2);
      this.event.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateEvent_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new CalendarEvent(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new CalendarEvent();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateEvent_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllDeadlines_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.usersOrGroups = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new UserOrGroup();
            elem18.read(input);
            this.usersOrGroups.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllDeadlines_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter19 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter19)) {
          iter19 = this.usersOrGroups[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllDeadlines_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Deadline]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new Deadline();
            elem23.read(input);
            this.success.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllDeadlines_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter24 in this.success) {
        if (this.success.hasOwnProperty(iter24)) {
          iter24 = this.success[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllDeadlines_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.usersOrGroups = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new UserOrGroup();
            elem28.read(input);
            this.usersOrGroups.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllDeadlines_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter29 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter29)) {
          iter29 = this.usersOrGroups[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllDeadlines_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllDeadlines_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllGroupedDeadlines_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.usersOrGroups = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new UserOrGroup();
            elem33.read(input);
            this.usersOrGroups.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllGroupedDeadlines_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter34 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter34)) {
          iter34 = this.usersOrGroups[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllGroupedDeadlines_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp336 = input.readMapBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            if (_i37 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key38 = null;
            let val39 = null;
            key38 = input.readI64().value;
            val39 = input.readI64().value;
            this.success[key38] = val39;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllGroupedDeadlines_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I64, Thrift.Type.I64, Thrift.objectLength(this.success));
      for (let kiter40 in this.success) {
        if (this.success.hasOwnProperty(kiter40)) {
          let viter41 = this.success[kiter40];
          output.writeI64(kiter40);
          output.writeI64(viter41);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllAreas_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllAreas_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllAreas_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Area]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp343 = input.readListBegin();
          const _size42 = _rtmp343.size || 0;
          for (let _i44 = 0; _i44 < _size42; ++_i44) {
            let elem45 = null;
            elem45 = new Area();
            elem45.read(input);
            this.success.push(elem45);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllAreas_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter46 in this.success) {
        if (this.success.hasOwnProperty(iter46)) {
          iter46 = this.success[iter46];
          iter46.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllAreas_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllAreas_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllAreas_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllAreas_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateArea_args = class {
  constructor(args) {
    this.token = null;
    this.area = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.area !== undefined && args.area !== null) {
        this.area = new Area(args.area);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.area = new Area();
          this.area.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateArea_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.area !== null && this.area !== undefined) {
      output.writeFieldBegin('area', Thrift.Type.STRUCT, 2);
      this.area.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateArea_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Area(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Area();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateArea_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteArea_args = class {
  constructor(args) {
    this.token = null;
    this.areaId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteArea_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 2);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteArea_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteArea_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllReassignments_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllReassignments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllReassignments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentReassign]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp348 = input.readListBegin();
          const _size47 = _rtmp348.size || 0;
          for (let _i49 = 0; _i49 < _size47; ++_i49) {
            let elem50 = null;
            elem50 = new DocumentReassign();
            elem50.read(input);
            this.success.push(elem50);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllReassignments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter51 in this.success) {
        if (this.success.hasOwnProperty(iter51)) {
          iter51 = this.success[iter51];
          iter51.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllMaterialResources_args = class {
  constructor(args) {
    this.token = null;
    this.areaId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllMaterialResources_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 2);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllMaterialResources_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [MaterialResource]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp353 = input.readListBegin();
          const _size52 = _rtmp353.size || 0;
          for (let _i54 = 0; _i54 < _size52; ++_i54) {
            let elem55 = null;
            elem55 = new MaterialResource();
            elem55.read(input);
            this.success.push(elem55);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllMaterialResources_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter56 in this.success) {
        if (this.success.hasOwnProperty(iter56)) {
          iter56 = this.success[iter56];
          iter56.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllMaterialResources_args = class {
  constructor(args) {
    this.token = null;
    this.areaId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllMaterialResources_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 2);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getCountAllMaterialResources_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getCountAllMaterialResources_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateMaterialResource_args = class {
  constructor(args) {
    this.token = null;
    this.materialResource = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.materialResource !== undefined && args.materialResource !== null) {
        this.materialResource = new MaterialResource(args.materialResource);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.materialResource = new MaterialResource();
          this.materialResource.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateMaterialResource_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.materialResource !== null && this.materialResource !== undefined) {
      output.writeFieldBegin('materialResource', Thrift.Type.STRUCT, 2);
      this.materialResource.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateMaterialResource_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MaterialResource(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MaterialResource();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateMaterialResource_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteMaterialResource_args = class {
  constructor(args) {
    this.token = null;
    this.materialResourceId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.materialResourceId !== undefined && args.materialResourceId !== null) {
        this.materialResourceId = args.materialResourceId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.materialResourceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteMaterialResource_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.materialResourceId !== null && this.materialResourceId !== undefined) {
      output.writeFieldBegin('materialResourceId', Thrift.Type.STRING, 2);
      output.writeString(this.materialResourceId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteMaterialResource_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteMaterialResource_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_moveMaterialResource_args = class {
  constructor(args) {
    this.token = null;
    this.resourceId = null;
    this.areaId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.resourceId !== undefined && args.resourceId !== null) {
        this.resourceId = args.resourceId;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.resourceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_moveMaterialResource_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.resourceId !== null && this.resourceId !== undefined) {
      output.writeFieldBegin('resourceId', Thrift.Type.STRING, 2);
      output.writeString(this.resourceId);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 3);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_moveMaterialResource_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MaterialResource(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MaterialResource();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_moveMaterialResource_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllMeetings_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.usersOrGroups = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp358 = input.readListBegin();
          const _size57 = _rtmp358.size || 0;
          for (let _i59 = 0; _i59 < _size57; ++_i59) {
            let elem60 = null;
            elem60 = new UserOrGroup();
            elem60.read(input);
            this.usersOrGroups.push(elem60);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllMeetings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter61 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter61)) {
          iter61 = this.usersOrGroups[iter61];
          iter61.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllMeetings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Meeting]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp363 = input.readListBegin();
          const _size62 = _rtmp363.size || 0;
          for (let _i64 = 0; _i64 < _size62; ++_i64) {
            let elem65 = null;
            elem65 = new Meeting();
            elem65.read(input);
            this.success.push(elem65);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllMeetings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter66 in this.success) {
        if (this.success.hasOwnProperty(iter66)) {
          iter66 = this.success[iter66];
          iter66.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getTinyMeetings_args = class {
  constructor(args) {
    this.token = null;
    this.beginDate = null;
    this.endDate = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getTinyMeetings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 2);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getTinyMeetings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Meeting]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp368 = input.readListBegin();
          const _size67 = _rtmp368.size || 0;
          for (let _i69 = 0; _i69 < _size67; ++_i69) {
            let elem70 = null;
            elem70 = new Meeting();
            elem70.read(input);
            this.success.push(elem70);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getTinyMeetings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter71 in this.success) {
        if (this.success.hasOwnProperty(iter71)) {
          iter71 = this.success[iter71];
          iter71.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateMeeting_args = class {
  constructor(args) {
    this.token = null;
    this.meeting = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meeting !== undefined && args.meeting !== null) {
        this.meeting = new Meeting(args.meeting);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.meeting = new Meeting();
          this.meeting.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateMeeting_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meeting !== null && this.meeting !== undefined) {
      output.writeFieldBegin('meeting', Thrift.Type.STRUCT, 2);
      this.meeting.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateMeeting_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Meeting(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Meeting();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateMeeting_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getMeetingById_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getMeetingById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getMeetingById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Meeting(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Meeting();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getMeetingById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteMeeting_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteMeeting_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_deleteMeeting_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_deleteMeeting_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_setMeetingViewed_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    this.viewed = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_setMeetingViewed_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 3);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_setMeetingViewed_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_setMeetingViewed_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_searchForMaterialResources_args = class {
  constructor(args) {
    this.token = null;
    this.areaId = null;
    this.beginDate = null;
    this.endDate = null;
    this.resourceType = null;
    this.personsCount = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.resourceType !== undefined && args.resourceType !== null) {
        this.resourceType = args.resourceType;
      }
      if (args.personsCount !== undefined && args.personsCount !== null) {
        this.personsCount = args.personsCount;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.resourceType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.personsCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_searchForMaterialResources_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 2);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 3);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 4);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.resourceType !== null && this.resourceType !== undefined) {
      output.writeFieldBegin('resourceType', Thrift.Type.I32, 5);
      output.writeI32(this.resourceType);
      output.writeFieldEnd();
    }
    if (this.personsCount !== null && this.personsCount !== undefined) {
      output.writeFieldBegin('personsCount', Thrift.Type.I64, 6);
      output.writeI64(this.personsCount);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 7);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_searchForMaterialResources_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [MaterialResource]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp373 = input.readListBegin();
          const _size72 = _rtmp373.size || 0;
          for (let _i74 = 0; _i74 < _size72; ++_i74) {
            let elem75 = null;
            elem75 = new MaterialResource();
            elem75.read(input);
            this.success.push(elem75);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_searchForMaterialResources_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter76 in this.success) {
        if (this.success.hasOwnProperty(iter76)) {
          iter76 = this.success[iter76];
          iter76.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAvailabilityCalendar_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    this.beginDate = null;
    this.endDate = null;
    this.userIds = null;
    this.resourceIds = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.beginDate !== undefined && args.beginDate !== null) {
        this.beginDate = args.beginDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
      if (args.resourceIds !== undefined && args.resourceIds !== null) {
        this.resourceIds = Thrift.copyList(args.resourceIds, [null]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.beginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp378 = input.readListBegin();
          const _size77 = _rtmp378.size || 0;
          for (let _i79 = 0; _i79 < _size77; ++_i79) {
            let elem80 = null;
            elem80 = input.readString().value;
            this.userIds.push(elem80);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.resourceIds = [];
          const _rtmp382 = input.readListBegin();
          const _size81 = _rtmp382.size || 0;
          for (let _i83 = 0; _i83 < _size81; ++_i83) {
            let elem84 = null;
            elem84 = input.readString().value;
            this.resourceIds.push(elem84);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAvailabilityCalendar_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.beginDate !== null && this.beginDate !== undefined) {
      output.writeFieldBegin('beginDate', Thrift.Type.I64, 3);
      output.writeI64(this.beginDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 4);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter85 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter85)) {
          iter85 = this.userIds[iter85];
          output.writeString(iter85);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.resourceIds !== null && this.resourceIds !== undefined) {
      output.writeFieldBegin('resourceIds', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.resourceIds.length);
      for (let iter86 in this.resourceIds) {
        if (this.resourceIds.hasOwnProperty(iter86)) {
          iter86 = this.resourceIds[iter86];
          output.writeString(iter86);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 7);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAvailabilityCalendar_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CalendarBusinessEvent]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp388 = input.readListBegin();
          const _size87 = _rtmp388.size || 0;
          for (let _i89 = 0; _i89 < _size87; ++_i89) {
            let elem90 = null;
            elem90 = new CalendarBusinessEvent();
            elem90.read(input);
            this.success.push(elem90);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAvailabilityCalendar_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter91 in this.success) {
        if (this.success.hasOwnProperty(iter91)) {
          iter91 = this.success[iter91];
          iter91.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_confirmMeeting_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    this.decision = null;
    this.newDateBegin = null;
    this.newDateEnd = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.newDateBegin !== undefined && args.newDateBegin !== null) {
        this.newDateBegin = args.newDateBegin;
      }
      if (args.newDateEnd !== undefined && args.newDateEnd !== null) {
        this.newDateEnd = args.newDateEnd;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.decision = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.newDateBegin = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.newDateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_confirmMeeting_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.I32, 3);
      output.writeI32(this.decision);
      output.writeFieldEnd();
    }
    if (this.newDateBegin !== null && this.newDateBegin !== undefined) {
      output.writeFieldBegin('newDateBegin', Thrift.Type.I64, 4);
      output.writeI64(this.newDateBegin);
      output.writeFieldEnd();
    }
    if (this.newDateEnd !== null && this.newDateEnd !== undefined) {
      output.writeFieldBegin('newDateEnd', Thrift.Type.I64, 5);
      output.writeI64(this.newDateEnd);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 6);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_confirmMeeting_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_confirmMeeting_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_confirmMeetingAlternativeTime_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_confirmMeetingAlternativeTime_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 3);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_confirmMeetingAlternativeTime_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_confirmMeetingAlternativeTime_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createMeetingProtocol_args = class {
  constructor(args) {
    this.token = null;
    this.meetingId = null;
    this.patternId = null;
    this.stageForConfirmationId = null;
    this.onlyConfirmedUsers = null;
    this.documentDeadlineDate = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.stageForConfirmationId !== undefined && args.stageForConfirmationId !== null) {
        this.stageForConfirmationId = args.stageForConfirmationId;
      }
      if (args.onlyConfirmedUsers !== undefined && args.onlyConfirmedUsers !== null) {
        this.onlyConfirmedUsers = args.onlyConfirmedUsers;
      }
      if (args.documentDeadlineDate !== undefined && args.documentDeadlineDate !== null) {
        this.documentDeadlineDate = args.documentDeadlineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.stageForConfirmationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.onlyConfirmedUsers = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.documentDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createMeetingProtocol_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 2);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 3);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.stageForConfirmationId !== null && this.stageForConfirmationId !== undefined) {
      output.writeFieldBegin('stageForConfirmationId', Thrift.Type.STRING, 4);
      output.writeString(this.stageForConfirmationId);
      output.writeFieldEnd();
    }
    if (this.onlyConfirmedUsers !== null && this.onlyConfirmedUsers !== undefined) {
      output.writeFieldBegin('onlyConfirmedUsers', Thrift.Type.BOOL, 5);
      output.writeBool(this.onlyConfirmedUsers);
      output.writeFieldEnd();
    }
    if (this.documentDeadlineDate !== null && this.documentDeadlineDate !== undefined) {
      output.writeFieldBegin('documentDeadlineDate', Thrift.Type.I64, 6);
      output.writeI64(this.documentDeadlineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createMeetingProtocol_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createMeetingProtocol_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllCalendarSharings_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllCalendarSharings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllCalendarSharings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CalendarSharing]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp393 = input.readListBegin();
          const _size92 = _rtmp393.size || 0;
          for (let _i94 = 0; _i94 < _size92; ++_i94) {
            let elem95 = null;
            elem95 = new CalendarSharing();
            elem95.read(input);
            this.success.push(elem95);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllCalendarSharings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter96 in this.success) {
        if (this.success.hasOwnProperty(iter96)) {
          iter96 = this.success[iter96];
          iter96.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllCalendarSharingsToMe_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllCalendarSharingsToMe_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllCalendarSharingsToMe_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CalendarSharing]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp398 = input.readListBegin();
          const _size97 = _rtmp398.size || 0;
          for (let _i99 = 0; _i99 < _size97; ++_i99) {
            let elem100 = null;
            elem100 = new CalendarSharing();
            elem100.read(input);
            this.success.push(elem100);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllCalendarSharingsToMe_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter101 in this.success) {
        if (this.success.hasOwnProperty(iter101)) {
          iter101 = this.success[iter101];
          iter101.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateCalendarSharing_args = class {
  constructor(args) {
    this.token = null;
    this.userOrGroups = null;
    this.sharingMode = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
      if (args.sharingMode !== undefined && args.sharingMode !== null) {
        this.sharingMode = args.sharingMode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp3103 = input.readListBegin();
          const _size102 = _rtmp3103.size || 0;
          for (let _i104 = 0; _i104 < _size102; ++_i104) {
            let elem105 = null;
            elem105 = new UserOrGroup();
            elem105.read(input);
            this.userOrGroups.push(elem105);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.sharingMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateCalendarSharing_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter106 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter106)) {
          iter106 = this.userOrGroups[iter106];
          iter106.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.sharingMode !== null && this.sharingMode !== undefined) {
      output.writeFieldBegin('sharingMode', Thrift.Type.I32, 3);
      output.writeI32(this.sharingMode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_createOrUpdateCalendarSharing_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CalendarSharing]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3108 = input.readListBegin();
          const _size107 = _rtmp3108.size || 0;
          for (let _i109 = 0; _i109 < _size107; ++_i109) {
            let elem110 = null;
            elem110 = new CalendarSharing();
            elem110.read(input);
            this.success.push(elem110);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_createOrUpdateCalendarSharing_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter111 in this.success) {
        if (this.success.hasOwnProperty(iter111)) {
          iter111 = this.success[iter111];
          iter111.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_removeCalendarSharing_args = class {
  constructor(args) {
    this.token = null;
    this.sharingIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.sharingIds !== undefined && args.sharingIds !== null) {
        this.sharingIds = Thrift.copyList(args.sharingIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.sharingIds = [];
          const _rtmp3113 = input.readListBegin();
          const _size112 = _rtmp3113.size || 0;
          for (let _i114 = 0; _i114 < _size112; ++_i114) {
            let elem115 = null;
            elem115 = input.readString().value;
            this.sharingIds.push(elem115);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_removeCalendarSharing_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.sharingIds !== null && this.sharingIds !== undefined) {
      output.writeFieldBegin('sharingIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.sharingIds.length);
      for (let iter116 in this.sharingIds) {
        if (this.sharingIds.hasOwnProperty(iter116)) {
          iter116 = this.sharingIds[iter116];
          output.writeString(iter116);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_removeCalendarSharing_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_removeCalendarSharing_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllWeekendDictionaries_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllWeekendDictionaries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_getAllWeekendDictionaries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [WeekendDictionary]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3118 = input.readListBegin();
          const _size117 = _rtmp3118.size || 0;
          for (let _i119 = 0; _i119 < _size117; ++_i119) {
            let elem120 = null;
            elem120 = new WeekendDictionary();
            elem120.read(input);
            this.success.push(elem120);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_getAllWeekendDictionaries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter121 in this.success) {
        if (this.success.hasOwnProperty(iter121)) {
          iter121 = this.success[iter121];
          iter121.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_changeWeekendDictionaries_args = class {
  constructor(args) {
    this.token = null;
    this.toUpdate = null;
    this.toRemove = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toUpdate !== undefined && args.toUpdate !== null) {
        this.toUpdate = Thrift.copyList(args.toUpdate, [WeekendDictionary]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toUpdate = [];
          const _rtmp3123 = input.readListBegin();
          const _size122 = _rtmp3123.size || 0;
          for (let _i124 = 0; _i124 < _size122; ++_i124) {
            let elem125 = null;
            elem125 = new WeekendDictionary();
            elem125.read(input);
            this.toUpdate.push(elem125);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3127 = input.readListBegin();
          const _size126 = _rtmp3127.size || 0;
          for (let _i128 = 0; _i128 < _size126; ++_i128) {
            let elem129 = null;
            elem129 = input.readString().value;
            this.toRemove.push(elem129);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_changeWeekendDictionaries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toUpdate !== null && this.toUpdate !== undefined) {
      output.writeFieldBegin('toUpdate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toUpdate.length);
      for (let iter130 in this.toUpdate) {
        if (this.toUpdate.hasOwnProperty(iter130)) {
          iter130 = this.toUpdate[iter130];
          iter130.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter131 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter131)) {
          iter131 = this.toRemove[iter131];
          output.writeString(iter131);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_changeWeekendDictionaries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [WeekendDictionary]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3133 = input.readListBegin();
          const _size132 = _rtmp3133.size || 0;
          for (let _i134 = 0; _i134 < _size132; ++_i134) {
            let elem135 = null;
            elem135 = new WeekendDictionary();
            elem135.read(input);
            this.success.push(elem135);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_changeWeekendDictionaries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter136 in this.success) {
        if (this.success.hasOwnProperty(iter136)) {
          iter136 = this.success[iter136];
          iter136.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_populateWeekends_args = class {
  constructor(args) {
    this.token = null;
    this.dateFrom = null;
    this.dateTo = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.dateFrom !== undefined && args.dateFrom !== null) {
        this.dateFrom = args.dateFrom;
      }
      if (args.dateTo !== undefined && args.dateTo !== null) {
        this.dateTo = args.dateTo;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.dateFrom = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.dateTo = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_populateWeekends_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.dateFrom !== null && this.dateFrom !== undefined) {
      output.writeFieldBegin('dateFrom', Thrift.Type.I64, 2);
      output.writeI64(this.dateFrom);
      output.writeFieldEnd();
    }
    if (this.dateTo !== null && this.dateTo !== undefined) {
      output.writeFieldBegin('dateTo', Thrift.Type.I64, 3);
      output.writeI64(this.dateTo);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_populateWeekends_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [WeekendDictionary]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3138 = input.readListBegin();
          const _size137 = _rtmp3138.size || 0;
          for (let _i139 = 0; _i139 < _size137; ++_i139) {
            let elem140 = null;
            elem140 = new WeekendDictionary();
            elem140.read(input);
            this.success.push(elem140);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_populateWeekends_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter141 in this.success) {
        if (this.success.hasOwnProperty(iter141)) {
          iter141 = this.success[iter141];
          iter141.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_convertJiraTimeToDate_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.jiraPeriod = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.jiraPeriod !== undefined && args.jiraPeriod !== null) {
        this.jiraPeriod = args.jiraPeriod;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.jiraPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_convertJiraTimeToDate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.jiraPeriod !== null && this.jiraPeriod !== undefined) {
      output.writeFieldBegin('jiraPeriod', Thrift.Type.STRING, 3);
      output.writeString(this.jiraPeriod);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_convertJiraTimeToDate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_convertJiraTimeToDate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_sendMeetingNotification_args = class {
  constructor(args) {
    this.token = null;
    this.users = null;
    this.guests = null;
    this.meeting = null;
    this.meetingEventType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [null]);
      }
      if (args.guests !== undefined && args.guests !== null) {
        this.guests = Thrift.copyList(args.guests, [null]);
      }
      if (args.meeting !== undefined && args.meeting !== null) {
        this.meeting = new Meeting(args.meeting);
      }
      if (args.meetingEventType !== undefined && args.meetingEventType !== null) {
        this.meetingEventType = args.meetingEventType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3143 = input.readListBegin();
          const _size142 = _rtmp3143.size || 0;
          for (let _i144 = 0; _i144 < _size142; ++_i144) {
            let elem145 = null;
            elem145 = input.readString().value;
            this.users.push(elem145);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.guests = [];
          const _rtmp3147 = input.readListBegin();
          const _size146 = _rtmp3147.size || 0;
          for (let _i148 = 0; _i148 < _size146; ++_i148) {
            let elem149 = null;
            elem149 = input.readString().value;
            this.guests.push(elem149);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.meeting = new Meeting();
          this.meeting.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.meetingEventType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_sendMeetingNotification_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.users.length);
      for (let iter150 in this.users) {
        if (this.users.hasOwnProperty(iter150)) {
          iter150 = this.users[iter150];
          output.writeString(iter150);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.guests !== null && this.guests !== undefined) {
      output.writeFieldBegin('guests', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.guests.length);
      for (let iter151 in this.guests) {
        if (this.guests.hasOwnProperty(iter151)) {
          iter151 = this.guests[iter151];
          output.writeString(iter151);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.meeting !== null && this.meeting !== undefined) {
      output.writeFieldBegin('meeting', Thrift.Type.STRUCT, 4);
      this.meeting.write(output);
      output.writeFieldEnd();
    }
    if (this.meetingEventType !== null && this.meetingEventType !== undefined) {
      output.writeFieldBegin('meetingEventType', Thrift.Type.I32, 5);
      output.writeI32(this.meetingEventType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarService_sendMeetingNotification_result = class {
  constructor(args) {
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarService_sendMeetingNotification_result');
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllEvents (token, beginDate, endDate, usersOrGroups, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllEvents(token, beginDate, endDate, usersOrGroups, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllEvents (token, beginDate, endDate, usersOrGroups, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      usersOrGroups: usersOrGroups,
      filter: filter
    };
    const args = new CalendarService_getAllEvents_args(params);
    try {
      this.output.writeMessageBegin('getAllEvents', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllEvents();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllEvents () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllEvents_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllEvents failed: unknown result';
  }

  deleteEvent (token, eventId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteEvent(token, eventId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteEvent (token, eventId, callback) {
    const params = {
      token: token,
      eventId: eventId
    };
    const args = new CalendarService_deleteEvent_args(params);
    try {
      this.output.writeMessageBegin('deleteEvent', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteEvent();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteEvent () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_deleteEvent_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteEvent failed: unknown result';
  }

  createOrUpdateEvent (token, event) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateEvent(token, event, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateEvent (token, event, callback) {
    const params = {
      token: token,
      event: event
    };
    const args = new CalendarService_createOrUpdateEvent_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateEvent', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateEvent();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateEvent () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createOrUpdateEvent_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateEvent failed: unknown result';
  }

  getAllDeadlines (token, beginDate, endDate, usersOrGroups, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDeadlines(token, beginDate, endDate, usersOrGroups, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDeadlines (token, beginDate, endDate, usersOrGroups, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      usersOrGroups: usersOrGroups,
      filter: filter
    };
    const args = new CalendarService_getAllDeadlines_args(params);
    try {
      this.output.writeMessageBegin('getAllDeadlines', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDeadlines();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDeadlines () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllDeadlines_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDeadlines failed: unknown result';
  }

  getCountAllDeadlines (token, beginDate, endDate, usersOrGroups, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllDeadlines(token, beginDate, endDate, usersOrGroups, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllDeadlines (token, beginDate, endDate, usersOrGroups, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      usersOrGroups: usersOrGroups,
      filter: filter
    };
    const args = new CalendarService_getCountAllDeadlines_args(params);
    try {
      this.output.writeMessageBegin('getCountAllDeadlines', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllDeadlines();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllDeadlines () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getCountAllDeadlines_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllDeadlines failed: unknown result';
  }

  getAllGroupedDeadlines (token, beginDate, endDate, usersOrGroups, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllGroupedDeadlines(token, beginDate, endDate, usersOrGroups, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllGroupedDeadlines (token, beginDate, endDate, usersOrGroups, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      usersOrGroups: usersOrGroups,
      filter: filter
    };
    const args = new CalendarService_getAllGroupedDeadlines_args(params);
    try {
      this.output.writeMessageBegin('getAllGroupedDeadlines', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllGroupedDeadlines();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllGroupedDeadlines () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllGroupedDeadlines_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllGroupedDeadlines failed: unknown result';
  }

  getAllAreas (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllAreas(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllAreas (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new CalendarService_getAllAreas_args(params);
    try {
      this.output.writeMessageBegin('getAllAreas', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllAreas();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllAreas () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllAreas_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllAreas failed: unknown result';
  }

  getCountAllAreas (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllAreas(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllAreas (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new CalendarService_getCountAllAreas_args(params);
    try {
      this.output.writeMessageBegin('getCountAllAreas', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllAreas();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllAreas () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getCountAllAreas_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllAreas failed: unknown result';
  }

  createOrUpdateArea (token, area) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateArea(token, area, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateArea (token, area, callback) {
    const params = {
      token: token,
      area: area
    };
    const args = new CalendarService_createOrUpdateArea_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateArea', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateArea();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateArea () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createOrUpdateArea_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateArea failed: unknown result';
  }

  deleteArea (token, areaId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteArea(token, areaId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteArea (token, areaId, callback) {
    const params = {
      token: token,
      areaId: areaId
    };
    const args = new CalendarService_deleteArea_args(params);
    try {
      this.output.writeMessageBegin('deleteArea', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteArea();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteArea () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_deleteArea_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteArea failed: unknown result';
  }

  getAllReassignments (token, beginDate, endDate, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllReassignments(token, beginDate, endDate, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllReassignments (token, beginDate, endDate, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      filter: filter
    };
    const args = new CalendarService_getAllReassignments_args(params);
    try {
      this.output.writeMessageBegin('getAllReassignments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllReassignments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllReassignments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllReassignments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllReassignments failed: unknown result';
  }

  getAllMaterialResources (token, areaId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMaterialResources(token, areaId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMaterialResources (token, areaId, filter, callback) {
    const params = {
      token: token,
      areaId: areaId,
      filter: filter
    };
    const args = new CalendarService_getAllMaterialResources_args(params);
    try {
      this.output.writeMessageBegin('getAllMaterialResources', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMaterialResources();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMaterialResources () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllMaterialResources_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMaterialResources failed: unknown result';
  }

  getCountAllMaterialResources (token, areaId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllMaterialResources(token, areaId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllMaterialResources (token, areaId, filter, callback) {
    const params = {
      token: token,
      areaId: areaId,
      filter: filter
    };
    const args = new CalendarService_getCountAllMaterialResources_args(params);
    try {
      this.output.writeMessageBegin('getCountAllMaterialResources', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllMaterialResources();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllMaterialResources () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getCountAllMaterialResources_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllMaterialResources failed: unknown result';
  }

  createOrUpdateMaterialResource (token, materialResource) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateMaterialResource(token, materialResource, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateMaterialResource (token, materialResource, callback) {
    const params = {
      token: token,
      materialResource: materialResource
    };
    const args = new CalendarService_createOrUpdateMaterialResource_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateMaterialResource', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateMaterialResource();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateMaterialResource () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createOrUpdateMaterialResource_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateMaterialResource failed: unknown result';
  }

  deleteMaterialResource (token, materialResourceId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteMaterialResource(token, materialResourceId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteMaterialResource (token, materialResourceId, callback) {
    const params = {
      token: token,
      materialResourceId: materialResourceId
    };
    const args = new CalendarService_deleteMaterialResource_args(params);
    try {
      this.output.writeMessageBegin('deleteMaterialResource', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteMaterialResource();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteMaterialResource () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_deleteMaterialResource_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteMaterialResource failed: unknown result';
  }

  moveMaterialResource (token, resourceId, areaId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_moveMaterialResource(token, resourceId, areaId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_moveMaterialResource (token, resourceId, areaId, callback) {
    const params = {
      token: token,
      resourceId: resourceId,
      areaId: areaId
    };
    const args = new CalendarService_moveMaterialResource_args(params);
    try {
      this.output.writeMessageBegin('moveMaterialResource', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_moveMaterialResource();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_moveMaterialResource () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_moveMaterialResource_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'moveMaterialResource failed: unknown result';
  }

  getAllMeetings (token, beginDate, endDate, usersOrGroups, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMeetings(token, beginDate, endDate, usersOrGroups, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMeetings (token, beginDate, endDate, usersOrGroups, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      usersOrGroups: usersOrGroups,
      filter: filter
    };
    const args = new CalendarService_getAllMeetings_args(params);
    try {
      this.output.writeMessageBegin('getAllMeetings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMeetings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMeetings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllMeetings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMeetings failed: unknown result';
  }

  getTinyMeetings (token, beginDate, endDate, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTinyMeetings(token, beginDate, endDate, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTinyMeetings (token, beginDate, endDate, filter, callback) {
    const params = {
      token: token,
      beginDate: beginDate,
      endDate: endDate,
      filter: filter
    };
    const args = new CalendarService_getTinyMeetings_args(params);
    try {
      this.output.writeMessageBegin('getTinyMeetings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTinyMeetings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTinyMeetings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getTinyMeetings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTinyMeetings failed: unknown result';
  }

  createOrUpdateMeeting (token, meeting) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateMeeting(token, meeting, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateMeeting (token, meeting, callback) {
    const params = {
      token: token,
      meeting: meeting
    };
    const args = new CalendarService_createOrUpdateMeeting_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateMeeting', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateMeeting();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateMeeting () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createOrUpdateMeeting_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateMeeting failed: unknown result';
  }

  getMeetingById (token, meetingId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMeetingById(token, meetingId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMeetingById (token, meetingId, callback) {
    const params = {
      token: token,
      meetingId: meetingId
    };
    const args = new CalendarService_getMeetingById_args(params);
    try {
      this.output.writeMessageBegin('getMeetingById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMeetingById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMeetingById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getMeetingById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMeetingById failed: unknown result';
  }

  deleteMeeting (token, meetingId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteMeeting(token, meetingId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteMeeting (token, meetingId, callback) {
    const params = {
      token: token,
      meetingId: meetingId
    };
    const args = new CalendarService_deleteMeeting_args(params);
    try {
      this.output.writeMessageBegin('deleteMeeting', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteMeeting();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteMeeting () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_deleteMeeting_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteMeeting failed: unknown result';
  }

  setMeetingViewed (token, meetingId, viewed) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setMeetingViewed(token, meetingId, viewed, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setMeetingViewed (token, meetingId, viewed, callback) {
    const params = {
      token: token,
      meetingId: meetingId,
      viewed: viewed
    };
    const args = new CalendarService_setMeetingViewed_args(params);
    try {
      this.output.writeMessageBegin('setMeetingViewed', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setMeetingViewed();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setMeetingViewed () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_setMeetingViewed_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setMeetingViewed failed: unknown result';
  }

  searchForMaterialResources (token, areaId, beginDate, endDate, resourceType, personsCount, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_searchForMaterialResources(token, areaId, beginDate, endDate, resourceType, personsCount, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_searchForMaterialResources (token, areaId, beginDate, endDate, resourceType, personsCount, filter, callback) {
    const params = {
      token: token,
      areaId: areaId,
      beginDate: beginDate,
      endDate: endDate,
      resourceType: resourceType,
      personsCount: personsCount,
      filter: filter
    };
    const args = new CalendarService_searchForMaterialResources_args(params);
    try {
      this.output.writeMessageBegin('searchForMaterialResources', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_searchForMaterialResources();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_searchForMaterialResources () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_searchForMaterialResources_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'searchForMaterialResources failed: unknown result';
  }

  getAvailabilityCalendar (token, meetingId, beginDate, endDate, userIds, resourceIds, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAvailabilityCalendar(token, meetingId, beginDate, endDate, userIds, resourceIds, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAvailabilityCalendar (token, meetingId, beginDate, endDate, userIds, resourceIds, filter, callback) {
    const params = {
      token: token,
      meetingId: meetingId,
      beginDate: beginDate,
      endDate: endDate,
      userIds: userIds,
      resourceIds: resourceIds,
      filter: filter
    };
    const args = new CalendarService_getAvailabilityCalendar_args(params);
    try {
      this.output.writeMessageBegin('getAvailabilityCalendar', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAvailabilityCalendar();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAvailabilityCalendar () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAvailabilityCalendar_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAvailabilityCalendar failed: unknown result';
  }

  confirmMeeting (token, meetingId, decision, newDateBegin, newDateEnd, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_confirmMeeting(token, meetingId, decision, newDateBegin, newDateEnd, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_confirmMeeting (token, meetingId, decision, newDateBegin, newDateEnd, userId, callback) {
    const params = {
      token: token,
      meetingId: meetingId,
      decision: decision,
      newDateBegin: newDateBegin,
      newDateEnd: newDateEnd,
      userId: userId
    };
    const args = new CalendarService_confirmMeeting_args(params);
    try {
      this.output.writeMessageBegin('confirmMeeting', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_confirmMeeting();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_confirmMeeting () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_confirmMeeting_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'confirmMeeting failed: unknown result';
  }

  confirmMeetingAlternativeTime (token, meetingId, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_confirmMeetingAlternativeTime(token, meetingId, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_confirmMeetingAlternativeTime (token, meetingId, userId, callback) {
    const params = {
      token: token,
      meetingId: meetingId,
      userId: userId
    };
    const args = new CalendarService_confirmMeetingAlternativeTime_args(params);
    try {
      this.output.writeMessageBegin('confirmMeetingAlternativeTime', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_confirmMeetingAlternativeTime();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_confirmMeetingAlternativeTime () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_confirmMeetingAlternativeTime_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'confirmMeetingAlternativeTime failed: unknown result';
  }

  createMeetingProtocol (token, meetingId, patternId, stageForConfirmationId, onlyConfirmedUsers, documentDeadlineDate) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createMeetingProtocol(token, meetingId, patternId, stageForConfirmationId, onlyConfirmedUsers, documentDeadlineDate, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createMeetingProtocol (token, meetingId, patternId, stageForConfirmationId, onlyConfirmedUsers, documentDeadlineDate, callback) {
    const params = {
      token: token,
      meetingId: meetingId,
      patternId: patternId,
      stageForConfirmationId: stageForConfirmationId,
      onlyConfirmedUsers: onlyConfirmedUsers,
      documentDeadlineDate: documentDeadlineDate
    };
    const args = new CalendarService_createMeetingProtocol_args(params);
    try {
      this.output.writeMessageBegin('createMeetingProtocol', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createMeetingProtocol();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createMeetingProtocol () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createMeetingProtocol_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createMeetingProtocol failed: unknown result';
  }

  getAllCalendarSharings (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllCalendarSharings(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllCalendarSharings (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new CalendarService_getAllCalendarSharings_args(params);
    try {
      this.output.writeMessageBegin('getAllCalendarSharings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllCalendarSharings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllCalendarSharings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllCalendarSharings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllCalendarSharings failed: unknown result';
  }

  getAllCalendarSharingsToMe (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllCalendarSharingsToMe(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllCalendarSharingsToMe (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new CalendarService_getAllCalendarSharingsToMe_args(params);
    try {
      this.output.writeMessageBegin('getAllCalendarSharingsToMe', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllCalendarSharingsToMe();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllCalendarSharingsToMe () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllCalendarSharingsToMe_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllCalendarSharingsToMe failed: unknown result';
  }

  createOrUpdateCalendarSharing (token, userOrGroups, sharingMode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateCalendarSharing(token, userOrGroups, sharingMode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateCalendarSharing (token, userOrGroups, sharingMode, callback) {
    const params = {
      token: token,
      userOrGroups: userOrGroups,
      sharingMode: sharingMode
    };
    const args = new CalendarService_createOrUpdateCalendarSharing_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateCalendarSharing', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateCalendarSharing();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateCalendarSharing () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_createOrUpdateCalendarSharing_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateCalendarSharing failed: unknown result';
  }

  removeCalendarSharing (token, sharingIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeCalendarSharing(token, sharingIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeCalendarSharing (token, sharingIds, callback) {
    const params = {
      token: token,
      sharingIds: sharingIds
    };
    const args = new CalendarService_removeCalendarSharing_args(params);
    try {
      this.output.writeMessageBegin('removeCalendarSharing', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeCalendarSharing();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeCalendarSharing () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_removeCalendarSharing_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeCalendarSharing failed: unknown result';
  }

  getAllWeekendDictionaries (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllWeekendDictionaries(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllWeekendDictionaries (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new CalendarService_getAllWeekendDictionaries_args(params);
    try {
      this.output.writeMessageBegin('getAllWeekendDictionaries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllWeekendDictionaries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllWeekendDictionaries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_getAllWeekendDictionaries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllWeekendDictionaries failed: unknown result';
  }

  changeWeekendDictionaries (token, toUpdate, toRemove, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeWeekendDictionaries(token, toUpdate, toRemove, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeWeekendDictionaries (token, toUpdate, toRemove, filter, callback) {
    const params = {
      token: token,
      toUpdate: toUpdate,
      toRemove: toRemove,
      filter: filter
    };
    const args = new CalendarService_changeWeekendDictionaries_args(params);
    try {
      this.output.writeMessageBegin('changeWeekendDictionaries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeWeekendDictionaries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeWeekendDictionaries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_changeWeekendDictionaries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeWeekendDictionaries failed: unknown result';
  }

  populateWeekends (token, dateFrom, dateTo, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_populateWeekends(token, dateFrom, dateTo, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_populateWeekends (token, dateFrom, dateTo, filter, callback) {
    const params = {
      token: token,
      dateFrom: dateFrom,
      dateTo: dateTo,
      filter: filter
    };
    const args = new CalendarService_populateWeekends_args(params);
    try {
      this.output.writeMessageBegin('populateWeekends', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_populateWeekends();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_populateWeekends () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_populateWeekends_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'populateWeekends failed: unknown result';
  }

  convertJiraTimeToDate (token, userId, jiraPeriod) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_convertJiraTimeToDate(token, userId, jiraPeriod, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_convertJiraTimeToDate (token, userId, jiraPeriod, callback) {
    const params = {
      token: token,
      userId: userId,
      jiraPeriod: jiraPeriod
    };
    const args = new CalendarService_convertJiraTimeToDate_args(params);
    try {
      this.output.writeMessageBegin('convertJiraTimeToDate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_convertJiraTimeToDate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_convertJiraTimeToDate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_convertJiraTimeToDate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'convertJiraTimeToDate failed: unknown result';
  }

  sendMeetingNotification (token, users, guests, meeting, meetingEventType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_sendMeetingNotification(token, users, guests, meeting, meetingEventType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_sendMeetingNotification (token, users, guests, meeting, meetingEventType, callback) {
    const params = {
      token: token,
      users: users,
      guests: guests,
      meeting: meeting,
      meetingEventType: meetingEventType
    };
    const args = new CalendarService_sendMeetingNotification_args(params);
    try {
      this.output.writeMessageBegin('sendMeetingNotification', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_sendMeetingNotification();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_sendMeetingNotification () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new CalendarService_sendMeetingNotification_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    return;
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


MessageType = {
  'NORMAL' : 0,
  'AUDIO' : 1,
  'OBJ' : 2
};
ObjType = class {
  constructor(args) {
    this.id = null;
    this.objType = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.objType !== undefined && args.objType !== null) {
        this.objType = args.objType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.objType = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ObjType');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.objType !== null && this.objType !== undefined) {
      output.writeFieldBegin('objType', Thrift.Type.STRING, 2);
      output.writeString(this.objType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Message = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.author = null;
    this.originalUser = null;
    this.groupId = null;
    this.message = null;
    this.isRead = null;
    this.msgType = null;
    this.objDescribe = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.author !== undefined && args.author !== null) {
        this.author = new UserOrGroup(args.author);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = args.message;
      }
      if (args.isRead !== undefined && args.isRead !== null) {
        this.isRead = args.isRead;
      }
      if (args.msgType !== undefined && args.msgType !== null) {
        this.msgType = args.msgType;
      }
      if (args.objDescribe !== undefined && args.objDescribe !== null) {
        this.objDescribe = new ObjType(args.objDescribe);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.author = new UserOrGroup();
          this.author.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.message = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.isRead = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.msgType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.objDescribe = new ObjType();
          this.objDescribe.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Message');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.author !== null && this.author !== undefined) {
      output.writeFieldBegin('author', Thrift.Type.STRUCT, 3);
      this.author.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 4);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 5);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRING, 6);
      output.writeString(this.message);
      output.writeFieldEnd();
    }
    if (this.isRead !== null && this.isRead !== undefined) {
      output.writeFieldBegin('isRead', Thrift.Type.BOOL, 7);
      output.writeBool(this.isRead);
      output.writeFieldEnd();
    }
    if (this.msgType !== null && this.msgType !== undefined) {
      output.writeFieldBegin('msgType', Thrift.Type.I32, 8);
      output.writeI32(this.msgType);
      output.writeFieldEnd();
    }
    if (this.objDescribe !== null && this.objDescribe !== undefined) {
      output.writeFieldBegin('objDescribe', Thrift.Type.STRUCT, 9);
      this.objDescribe.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Group = class {
  constructor(args) {
    this.id = null;
    this.nameGroup = null;
    this.documentId = null;
    this.authorId = null;
    this.lastMessage = null;
    this.listen = null;
    this.parentGroupId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameGroup !== undefined && args.nameGroup !== null) {
        this.nameGroup = args.nameGroup;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.authorId !== undefined && args.authorId !== null) {
        this.authorId = args.authorId;
      }
      if (args.lastMessage !== undefined && args.lastMessage !== null) {
        this.lastMessage = new Message(args.lastMessage);
      }
      if (args.listen !== undefined && args.listen !== null) {
        this.listen = args.listen;
      }
      if (args.parentGroupId !== undefined && args.parentGroupId !== null) {
        this.parentGroupId = args.parentGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.authorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.lastMessage = new Message();
          this.lastMessage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.listen = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.parentGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Group');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameGroup !== null && this.nameGroup !== undefined) {
      output.writeFieldBegin('nameGroup', Thrift.Type.STRING, 2);
      output.writeString(this.nameGroup);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.authorId !== null && this.authorId !== undefined) {
      output.writeFieldBegin('authorId', Thrift.Type.STRING, 4);
      output.writeString(this.authorId);
      output.writeFieldEnd();
    }
    if (this.lastMessage !== null && this.lastMessage !== undefined) {
      output.writeFieldBegin('lastMessage', Thrift.Type.STRUCT, 5);
      this.lastMessage.write(output);
      output.writeFieldEnd();
    }
    if (this.listen !== null && this.listen !== undefined) {
      output.writeFieldBegin('listen', Thrift.Type.BOOL, 6);
      output.writeBool(this.listen);
      output.writeFieldEnd();
    }
    if (this.parentGroupId !== null && this.parentGroupId !== undefined) {
      output.writeFieldBegin('parentGroupId', Thrift.Type.STRING, 7);
      output.writeString(this.parentGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
GroupInformation = class {
  constructor(args) {
    this.group = null;
    this.messagesCount = null;
    if (args) {
      if (args.group !== undefined && args.group !== null) {
        this.group = new Group(args.group);
      }
      if (args.messagesCount !== undefined && args.messagesCount !== null) {
        this.messagesCount = args.messagesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.group = new Group();
          this.group.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.messagesCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('GroupInformation');
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRUCT, 1);
      this.group.write(output);
      output.writeFieldEnd();
    }
    if (this.messagesCount !== null && this.messagesCount !== undefined) {
      output.writeFieldBegin('messagesCount', Thrift.Type.I64, 2);
      output.writeI64(this.messagesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatUser = class {
  constructor(args) {
    this.user = null;
    this.present = null;
    if (args) {
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.present !== undefined && args.present !== null) {
        this.present = args.present;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.present = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatUser');
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 1);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.present !== null && this.present !== undefined) {
      output.writeFieldBegin('present', Thrift.Type.BOOL, 2);
      output.writeBool(this.present);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CHANT_CURRENT_VERSION = '1.0-alpha.54';
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

ChatService_getVersion_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getVersion_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getVersion_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getVersion_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_createOrUpdateChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.userIds = null;
    this.group = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = new Group(args.group);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString().value;
            this.userIds.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.group = new Group();
          this.group.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_createOrUpdateChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter4 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter4)) {
          iter4 = this.userIds[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRUCT, 3);
      this.group.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_createOrUpdateChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Group(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Group();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_createOrUpdateChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatMessages_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.fromDate = null;
    this.tillDate = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.fromDate !== undefined && args.fromDate !== null) {
        this.fromDate = args.fromDate;
      }
      if (args.tillDate !== undefined && args.tillDate !== null) {
        this.tillDate = args.tillDate;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.fromDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.tillDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatMessages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.fromDate !== null && this.fromDate !== undefined) {
      output.writeFieldBegin('fromDate', Thrift.Type.I64, 3);
      output.writeI64(this.fromDate);
      output.writeFieldEnd();
    }
    if (this.tillDate !== null && this.tillDate !== undefined) {
      output.writeFieldBegin('tillDate', Thrift.Type.I64, 4);
      output.writeI64(this.tillDate);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatMessages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Message]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new Message();
            elem8.read(input);
            this.success.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter9 in this.success) {
        if (this.success.hasOwnProperty(iter9)) {
          iter9 = this.success[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_sendChatMessage_args = class {
  constructor(args) {
    this.token = null;
    this.message = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_sendChatMessage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_sendChatMessage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Message(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_sendChatMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_editChatMessage_args = class {
  constructor(args) {
    this.token = null;
    this.message = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = new Message(args.message);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.message = new Message();
          this.message.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_editChatMessage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRUCT, 2);
      this.message.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_editChatMessage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Message(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Message();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_editChatMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeChatMessage_args = class {
  constructor(args) {
    this.token = null;
    this.messageId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.messageId !== undefined && args.messageId !== null) {
        this.messageId = args.messageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.messageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeChatMessage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.messageId !== null && this.messageId !== undefined) {
      output.writeFieldBegin('messageId', Thrift.Type.STRING, 2);
      output.writeString(this.messageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeChatMessage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeChatMessage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_existsChatMessages_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_existsChatMessages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_existsChatMessages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_existsChatMessages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_markChatMessagesAsRead_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.tillDate = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.tillDate !== undefined && args.tillDate !== null) {
        this.tillDate = args.tillDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.tillDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_markChatMessagesAsRead_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.tillDate !== null && this.tillDate !== undefined) {
      output.writeFieldBegin('tillDate', Thrift.Type.I64, 3);
      output.writeI64(this.tillDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_markChatMessagesAsRead_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_markChatMessagesAsRead_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroupParticipantsStatuses_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroupParticipantsStatuses_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroupParticipantsStatuses_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ChatUser]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new ChatUser();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroupParticipantsStatuses_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroups_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Group]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new Group();
            elem18.read(input);
            this.success.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter19 in this.success) {
        if (this.success.hasOwnProperty(iter19)) {
          iter19 = this.success[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroupsForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentChatId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentChatId !== undefined && args.documentChatId !== null) {
        this.documentChatId = args.documentChatId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentChatId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroupsForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentChatId !== null && this.documentChatId !== undefined) {
      output.writeFieldBegin('documentChatId', Thrift.Type.STRING, 2);
      output.writeString(this.documentChatId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAllChatGroupsForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Group]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new Group();
            elem23.read(input);
            this.success.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAllChatGroupsForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter24 in this.success) {
        if (this.success.hasOwnProperty(iter24)) {
          iter24 = this.success[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_addUsersToChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.userIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = input.readString().value;
            this.userIds.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_addUsersToChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter29 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter29)) {
          iter29 = this.userIds[iter29];
          output.writeString(iter29);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_addUsersToChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_addUsersToChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeUsersFromChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.userIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readString().value;
            this.userIds.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeUsersFromChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter34 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter34)) {
          iter34 = this.userIds[iter34];
          output.writeString(iter34);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeUsersFromChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeUsersFromChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_exitFromChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_exitFromChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_exitFromChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_exitFromChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_disableNotifyToChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_disableNotifyToChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_disableNotifyToChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_disableNotifyToChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_enableNotifyToChatGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_enableNotifyToChatGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_enableNotifyToChatGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_enableNotifyToChatGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAggregatedChatGroupsInformation_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAggregatedChatGroupsInformation_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getAggregatedChatGroupsInformation_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [GroupInformation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new GroupInformation();
            elem38.read(input);
            this.success.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getAggregatedChatGroupsInformation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter39 in this.success) {
        if (this.success.hasOwnProperty(iter39)) {
          iter39 = this.success[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getCountAggregatedChatGroupsInformation_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getCountAggregatedChatGroupsInformation_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_getCountAggregatedChatGroupsInformation_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_getCountAggregatedChatGroupsInformation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeChat_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeChat_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_removeChat_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_removeChat_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_changeUserInChats_args = class {
  constructor(args) {
    this.token = null;
    this.docIds = null;
    this.userIdFrom = null;
    this.userIdTo = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docIds !== undefined && args.docIds !== null) {
        this.docIds = Thrift.copyList(args.docIds, [null]);
      }
      if (args.userIdFrom !== undefined && args.userIdFrom !== null) {
        this.userIdFrom = args.userIdFrom;
      }
      if (args.userIdTo !== undefined && args.userIdTo !== null) {
        this.userIdTo = args.userIdTo;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.docIds = [];
          const _rtmp341 = input.readSetBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = input.readString().value;
            this.docIds.push(elem43);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userIdFrom = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.userIdTo = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_changeUserInChats_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docIds !== null && this.docIds !== undefined) {
      output.writeFieldBegin('docIds', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.docIds.length);
      for (let iter44 in this.docIds) {
        if (this.docIds.hasOwnProperty(iter44)) {
          iter44 = this.docIds[iter44];
          output.writeString(iter44);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.userIdFrom !== null && this.userIdFrom !== undefined) {
      output.writeFieldBegin('userIdFrom', Thrift.Type.STRING, 3);
      output.writeString(this.userIdFrom);
      output.writeFieldEnd();
    }
    if (this.userIdTo !== null && this.userIdTo !== undefined) {
      output.writeFieldBegin('userIdTo', Thrift.Type.STRING, 4);
      output.writeString(this.userIdTo);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_changeUserInChats_result = class {
  constructor(args) {
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_changeUserInChats_result');
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_createWAV_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    this.fileName = null;
    this.totalSize = null;
    this.countPortions = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.totalSize !== undefined && args.totalSize !== null) {
        this.totalSize = args.totalSize;
      }
      if (args.countPortions !== undefined && args.countPortions !== null) {
        this.countPortions = args.countPortions;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.totalSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.countPortions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_createWAV_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.totalSize !== null && this.totalSize !== undefined) {
      output.writeFieldBegin('totalSize', Thrift.Type.I64, 4);
      output.writeI64(this.totalSize);
      output.writeFieldEnd();
    }
    if (this.countPortions !== null && this.countPortions !== undefined) {
      output.writeFieldBegin('countPortions', Thrift.Type.I32, 5);
      output.writeI32(this.countPortions);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_createWAV_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_createWAV_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_uploadWAV_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.numberPortion = null;
    this.fileContentBytes = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.numberPortion !== undefined && args.numberPortion !== null) {
        this.numberPortion = args.numberPortion;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.numberPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_uploadWAV_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.numberPortion !== null && this.numberPortion !== undefined) {
      output.writeFieldBegin('numberPortion', Thrift.Type.I32, 3);
      output.writeI32(this.numberPortion);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 4);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_uploadWAV_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_uploadWAV_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_countUsersByGroup_args = class {
  constructor(args) {
    this.token = null;
    this.chatGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.chatGroupId !== undefined && args.chatGroupId !== null) {
        this.chatGroupId = args.chatGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.chatGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_countUsersByGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.chatGroupId !== null && this.chatGroupId !== undefined) {
      output.writeFieldBegin('chatGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.chatGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatService_countUsersByGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChatService_countUsersByGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChatServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getVersion () {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getVersion((error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getVersion (callback) {
    const args = new ChatService_getVersion_args();
    try {
      this.output.writeMessageBegin('getVersion', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getVersion();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getVersion () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getVersion_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.success) {
      return result.success;
    }
    throw 'getVersion failed: unknown result';
  }

  createOrUpdateChatGroup (token, userIds, group) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateChatGroup(token, userIds, group, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateChatGroup (token, userIds, group, callback) {
    const params = {
      token: token,
      userIds: userIds,
      group: group
    };
    const args = new ChatService_createOrUpdateChatGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_createOrUpdateChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateChatGroup failed: unknown result';
  }

  getAllChatMessages (token, chatGroupId, fromDate, tillDate, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllChatMessages(token, chatGroupId, fromDate, tillDate, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllChatMessages (token, chatGroupId, fromDate, tillDate, filter, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      fromDate: fromDate,
      tillDate: tillDate,
      filter: filter
    };
    const args = new ChatService_getAllChatMessages_args(params);
    try {
      this.output.writeMessageBegin('getAllChatMessages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllChatMessages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllChatMessages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getAllChatMessages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllChatMessages failed: unknown result';
  }

  sendChatMessage (token, message) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_sendChatMessage(token, message, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_sendChatMessage (token, message, callback) {
    const params = {
      token: token,
      message: message
    };
    const args = new ChatService_sendChatMessage_args(params);
    try {
      this.output.writeMessageBegin('sendChatMessage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_sendChatMessage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_sendChatMessage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_sendChatMessage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'sendChatMessage failed: unknown result';
  }

  editChatMessage (token, message) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_editChatMessage(token, message, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_editChatMessage (token, message, callback) {
    const params = {
      token: token,
      message: message
    };
    const args = new ChatService_editChatMessage_args(params);
    try {
      this.output.writeMessageBegin('editChatMessage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_editChatMessage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_editChatMessage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_editChatMessage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'editChatMessage failed: unknown result';
  }

  removeChatMessage (token, messageId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeChatMessage(token, messageId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeChatMessage (token, messageId, callback) {
    const params = {
      token: token,
      messageId: messageId
    };
    const args = new ChatService_removeChatMessage_args(params);
    try {
      this.output.writeMessageBegin('removeChatMessage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeChatMessage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeChatMessage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_removeChatMessage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeChatMessage failed: unknown result';
  }

  existsChatMessages (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_existsChatMessages(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_existsChatMessages (token, callback) {
    const params = {
      token: token
    };
    const args = new ChatService_existsChatMessages_args(params);
    try {
      this.output.writeMessageBegin('existsChatMessages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_existsChatMessages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_existsChatMessages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_existsChatMessages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'existsChatMessages failed: unknown result';
  }

  markChatMessagesAsRead (token, chatGroupId, tillDate) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markChatMessagesAsRead(token, chatGroupId, tillDate, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markChatMessagesAsRead (token, chatGroupId, tillDate, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      tillDate: tillDate
    };
    const args = new ChatService_markChatMessagesAsRead_args(params);
    try {
      this.output.writeMessageBegin('markChatMessagesAsRead', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markChatMessagesAsRead();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markChatMessagesAsRead () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_markChatMessagesAsRead_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markChatMessagesAsRead failed: unknown result';
  }

  getAllChatGroupParticipantsStatuses (token, chatGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllChatGroupParticipantsStatuses(token, chatGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllChatGroupParticipantsStatuses (token, chatGroupId, filter, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      filter: filter
    };
    const args = new ChatService_getAllChatGroupParticipantsStatuses_args(params);
    try {
      this.output.writeMessageBegin('getAllChatGroupParticipantsStatuses', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllChatGroupParticipantsStatuses();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllChatGroupParticipantsStatuses () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getAllChatGroupParticipantsStatuses_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllChatGroupParticipantsStatuses failed: unknown result';
  }

  getAllChatGroups (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllChatGroups(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllChatGroups (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ChatService_getAllChatGroups_args(params);
    try {
      this.output.writeMessageBegin('getAllChatGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllChatGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllChatGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getAllChatGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllChatGroups failed: unknown result';
  }

  getAllChatGroupsForDocument (token, documentChatId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllChatGroupsForDocument(token, documentChatId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllChatGroupsForDocument (token, documentChatId, callback) {
    const params = {
      token: token,
      documentChatId: documentChatId
    };
    const args = new ChatService_getAllChatGroupsForDocument_args(params);
    try {
      this.output.writeMessageBegin('getAllChatGroupsForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllChatGroupsForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllChatGroupsForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getAllChatGroupsForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllChatGroupsForDocument failed: unknown result';
  }

  addUsersToChatGroup (token, chatGroupId, userIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addUsersToChatGroup(token, chatGroupId, userIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addUsersToChatGroup (token, chatGroupId, userIds, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      userIds: userIds
    };
    const args = new ChatService_addUsersToChatGroup_args(params);
    try {
      this.output.writeMessageBegin('addUsersToChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addUsersToChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addUsersToChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_addUsersToChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addUsersToChatGroup failed: unknown result';
  }

  removeUsersFromChatGroup (token, chatGroupId, userIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeUsersFromChatGroup(token, chatGroupId, userIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeUsersFromChatGroup (token, chatGroupId, userIds, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      userIds: userIds
    };
    const args = new ChatService_removeUsersFromChatGroup_args(params);
    try {
      this.output.writeMessageBegin('removeUsersFromChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeUsersFromChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeUsersFromChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_removeUsersFromChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeUsersFromChatGroup failed: unknown result';
  }

  exitFromChatGroup (token, chatGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exitFromChatGroup(token, chatGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exitFromChatGroup (token, chatGroupId, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId
    };
    const args = new ChatService_exitFromChatGroup_args(params);
    try {
      this.output.writeMessageBegin('exitFromChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exitFromChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exitFromChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_exitFromChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exitFromChatGroup failed: unknown result';
  }

  disableNotifyToChatGroup (token, chatGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_disableNotifyToChatGroup(token, chatGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_disableNotifyToChatGroup (token, chatGroupId, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId
    };
    const args = new ChatService_disableNotifyToChatGroup_args(params);
    try {
      this.output.writeMessageBegin('disableNotifyToChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_disableNotifyToChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_disableNotifyToChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_disableNotifyToChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'disableNotifyToChatGroup failed: unknown result';
  }

  enableNotifyToChatGroup (token, chatGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_enableNotifyToChatGroup(token, chatGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_enableNotifyToChatGroup (token, chatGroupId, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId
    };
    const args = new ChatService_enableNotifyToChatGroup_args(params);
    try {
      this.output.writeMessageBegin('enableNotifyToChatGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_enableNotifyToChatGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_enableNotifyToChatGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_enableNotifyToChatGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'enableNotifyToChatGroup failed: unknown result';
  }

  getAggregatedChatGroupsInformation (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAggregatedChatGroupsInformation(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAggregatedChatGroupsInformation (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ChatService_getAggregatedChatGroupsInformation_args(params);
    try {
      this.output.writeMessageBegin('getAggregatedChatGroupsInformation', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAggregatedChatGroupsInformation();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAggregatedChatGroupsInformation () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getAggregatedChatGroupsInformation_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAggregatedChatGroupsInformation failed: unknown result';
  }

  getCountAggregatedChatGroupsInformation (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAggregatedChatGroupsInformation(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAggregatedChatGroupsInformation (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ChatService_getCountAggregatedChatGroupsInformation_args(params);
    try {
      this.output.writeMessageBegin('getCountAggregatedChatGroupsInformation', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAggregatedChatGroupsInformation();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAggregatedChatGroupsInformation () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_getCountAggregatedChatGroupsInformation_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAggregatedChatGroupsInformation failed: unknown result';
  }

  removeChat (token, chatGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeChat(token, chatGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeChat (token, chatGroupId, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId
    };
    const args = new ChatService_removeChat_args(params);
    try {
      this.output.writeMessageBegin('removeChat', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeChat();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeChat () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_removeChat_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeChat failed: unknown result';
  }

  changeUserInChats (token, docIds, userIdFrom, userIdTo) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeUserInChats(token, docIds, userIdFrom, userIdTo, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeUserInChats (token, docIds, userIdFrom, userIdTo, callback) {
    const params = {
      token: token,
      docIds: docIds,
      userIdFrom: userIdFrom,
      userIdTo: userIdTo
    };
    const args = new ChatService_changeUserInChats_args(params);
    try {
      this.output.writeMessageBegin('changeUserInChats', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeUserInChats();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeUserInChats () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_changeUserInChats_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    return;
  }

  createWAV (token, chatGroupId, fileName, totalSize, countPortions) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createWAV(token, chatGroupId, fileName, totalSize, countPortions, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createWAV (token, chatGroupId, fileName, totalSize, countPortions, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId,
      fileName: fileName,
      totalSize: totalSize,
      countPortions: countPortions
    };
    const args = new ChatService_createWAV_args(params);
    try {
      this.output.writeMessageBegin('createWAV', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createWAV();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createWAV () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_createWAV_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createWAV failed: unknown result';
  }

  uploadWAV (token, attachmentId, numberPortion, fileContentBytes) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadWAV(token, attachmentId, numberPortion, fileContentBytes, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadWAV (token, attachmentId, numberPortion, fileContentBytes, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      numberPortion: numberPortion,
      fileContentBytes: fileContentBytes
    };
    const args = new ChatService_uploadWAV_args(params);
    try {
      this.output.writeMessageBegin('uploadWAV', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadWAV();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadWAV () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_uploadWAV_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadWAV failed: unknown result';
  }

  countUsersByGroup (token, chatGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_countUsersByGroup(token, chatGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_countUsersByGroup (token, chatGroupId, callback) {
    const params = {
      token: token,
      chatGroupId: chatGroupId
    };
    const args = new ChatService_countUsersByGroup_args(params);
    try {
      this.output.writeMessageBegin('countUsersByGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_countUsersByGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_countUsersByGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ChatService_countUsersByGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'countUsersByGroup failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DepartmentService_getAllOrgStructure_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllOrgStructure_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getAllOrgStructure_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [OrgStructure]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new OrgStructure();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllOrgStructure_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_createOrUpdateOrgStructure_args = class {
  constructor(args) {
    this.token = null;
    this.orgStructure = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.orgStructure !== undefined && args.orgStructure !== null) {
        this.orgStructure = new OrgStructure(args.orgStructure);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.orgStructure = new OrgStructure();
          this.orgStructure.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_createOrUpdateOrgStructure_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.orgStructure !== null && this.orgStructure !== undefined) {
      output.writeFieldBegin('orgStructure', Thrift.Type.STRUCT, 2);
      this.orgStructure.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_createOrUpdateOrgStructure_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new OrgStructure(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new OrgStructure();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_createOrUpdateOrgStructure_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_removeOrgStructure_args = class {
  constructor(args) {
    this.token = null;
    this.orgStructureId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.orgStructureId !== undefined && args.orgStructureId !== null) {
        this.orgStructureId = args.orgStructureId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.orgStructureId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_removeOrgStructure_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.orgStructureId !== null && this.orgStructureId !== undefined) {
      output.writeFieldBegin('orgStructureId', Thrift.Type.STRING, 2);
      output.writeString(this.orgStructureId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_removeOrgStructure_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_removeOrgStructure_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getAllDepartments_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllDepartments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getAllDepartments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Department]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new Department();
            elem8.read(input);
            this.success.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllDepartments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter9 in this.success) {
        if (this.success.hasOwnProperty(iter9)) {
          iter9 = this.success[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getUsersByDepartment_args = class {
  constructor(args) {
    this.token = null;
    this.departmentId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.departmentId !== undefined && args.departmentId !== null) {
        this.departmentId = args.departmentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.departmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getUsersByDepartment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.departmentId !== null && this.departmentId !== undefined) {
      output.writeFieldBegin('departmentId', Thrift.Type.STRING, 2);
      output.writeString(this.departmentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getUsersByDepartment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new UserOrGroup();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getUsersByDepartment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getCountUsersByDepartment_args = class {
  constructor(args) {
    this.token = null;
    this.departmentId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.departmentId !== undefined && args.departmentId !== null) {
        this.departmentId = args.departmentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.departmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getCountUsersByDepartment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.departmentId !== null && this.departmentId !== undefined) {
      output.writeFieldBegin('departmentId', Thrift.Type.STRING, 2);
      output.writeString(this.departmentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getCountUsersByDepartment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getCountUsersByDepartment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_createOrUpdateDepartment_args = class {
  constructor(args) {
    this.token = null;
    this.department = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.department !== undefined && args.department !== null) {
        this.department = new Department(args.department);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.department = new Department();
          this.department.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_createOrUpdateDepartment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.department !== null && this.department !== undefined) {
      output.writeFieldBegin('department', Thrift.Type.STRUCT, 2);
      this.department.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_createOrUpdateDepartment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Department(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Department();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_createOrUpdateDepartment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_removeDepartment_args = class {
  constructor(args) {
    this.token = null;
    this.departmentId = null;
    this.removeType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.departmentId !== undefined && args.departmentId !== null) {
        this.departmentId = args.departmentId;
      }
      if (args.removeType !== undefined && args.removeType !== null) {
        this.removeType = args.removeType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.departmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.removeType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_removeDepartment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.departmentId !== null && this.departmentId !== undefined) {
      output.writeFieldBegin('departmentId', Thrift.Type.STRING, 2);
      output.writeString(this.departmentId);
      output.writeFieldEnd();
    }
    if (this.removeType !== null && this.removeType !== undefined) {
      output.writeFieldBegin('removeType', Thrift.Type.I32, 3);
      output.writeI32(this.removeType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_removeDepartment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_removeDepartment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getAllDepartmentsForUser_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.withParent = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.withParent !== undefined && args.withParent !== null) {
        this.withParent = args.withParent;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.withParent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllDepartmentsForUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.withParent !== null && this.withParent !== undefined) {
      output.writeFieldBegin('withParent', Thrift.Type.BOOL, 3);
      output.writeBool(this.withParent);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_getAllDepartmentsForUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Department]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new Department();
            elem18.read(input);
            this.success.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_getAllDepartmentsForUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter19 in this.success) {
        if (this.success.hasOwnProperty(iter19)) {
          iter19 = this.success[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_changeUserDepartments_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.toAdd = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [Department]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new Department();
            elem23.read(input);
            this.toAdd.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp325 = input.readListBegin();
          const _size24 = _rtmp325.size || 0;
          for (let _i26 = 0; _i26 < _size24; ++_i26) {
            let elem27 = null;
            elem27 = input.readString().value;
            this.toRemove.push(elem27);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_changeUserDepartments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter28 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter28)) {
          iter28 = this.toAdd[iter28];
          iter28.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter29 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter29)) {
          iter29 = this.toRemove[iter29];
          output.writeString(iter29);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_changeUserDepartments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Department]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new Department();
            elem33.read(input);
            this.success.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_changeUserDepartments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter34 in this.success) {
        if (this.success.hasOwnProperty(iter34)) {
          iter34 = this.success[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_moveDepartment_args = class {
  constructor(args) {
    this.token = null;
    this.departmentId = null;
    this.toDepartmentId = null;
    this.withChilds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.departmentId !== undefined && args.departmentId !== null) {
        this.departmentId = args.departmentId;
      }
      if (args.toDepartmentId !== undefined && args.toDepartmentId !== null) {
        this.toDepartmentId = args.toDepartmentId;
      }
      if (args.withChilds !== undefined && args.withChilds !== null) {
        this.withChilds = args.withChilds;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.departmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.toDepartmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.withChilds = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_moveDepartment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.departmentId !== null && this.departmentId !== undefined) {
      output.writeFieldBegin('departmentId', Thrift.Type.STRING, 2);
      output.writeString(this.departmentId);
      output.writeFieldEnd();
    }
    if (this.toDepartmentId !== null && this.toDepartmentId !== undefined) {
      output.writeFieldBegin('toDepartmentId', Thrift.Type.STRING, 3);
      output.writeString(this.toDepartmentId);
      output.writeFieldEnd();
    }
    if (this.withChilds !== null && this.withChilds !== undefined) {
      output.writeFieldBegin('withChilds', Thrift.Type.BOOL, 4);
      output.writeBool(this.withChilds);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentService_moveDepartment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DepartmentService_moveDepartment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DepartmentServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllOrgStructure (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllOrgStructure(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllOrgStructure (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DepartmentService_getAllOrgStructure_args(params);
    try {
      this.output.writeMessageBegin('getAllOrgStructure', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllOrgStructure();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllOrgStructure () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_getAllOrgStructure_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllOrgStructure failed: unknown result';
  }

  createOrUpdateOrgStructure (token, orgStructure) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateOrgStructure(token, orgStructure, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateOrgStructure (token, orgStructure, callback) {
    const params = {
      token: token,
      orgStructure: orgStructure
    };
    const args = new DepartmentService_createOrUpdateOrgStructure_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateOrgStructure', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateOrgStructure();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateOrgStructure () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_createOrUpdateOrgStructure_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateOrgStructure failed: unknown result';
  }

  removeOrgStructure (token, orgStructureId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeOrgStructure(token, orgStructureId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeOrgStructure (token, orgStructureId, callback) {
    const params = {
      token: token,
      orgStructureId: orgStructureId
    };
    const args = new DepartmentService_removeOrgStructure_args(params);
    try {
      this.output.writeMessageBegin('removeOrgStructure', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeOrgStructure();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeOrgStructure () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_removeOrgStructure_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeOrgStructure failed: unknown result';
  }

  getAllDepartments (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDepartments(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDepartments (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DepartmentService_getAllDepartments_args(params);
    try {
      this.output.writeMessageBegin('getAllDepartments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDepartments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDepartments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_getAllDepartments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDepartments failed: unknown result';
  }

  getUsersByDepartment (token, departmentId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUsersByDepartment(token, departmentId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUsersByDepartment (token, departmentId, filter, callback) {
    const params = {
      token: token,
      departmentId: departmentId,
      filter: filter
    };
    const args = new DepartmentService_getUsersByDepartment_args(params);
    try {
      this.output.writeMessageBegin('getUsersByDepartment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUsersByDepartment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUsersByDepartment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_getUsersByDepartment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUsersByDepartment failed: unknown result';
  }

  getCountUsersByDepartment (token, departmentId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountUsersByDepartment(token, departmentId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountUsersByDepartment (token, departmentId, filter, callback) {
    const params = {
      token: token,
      departmentId: departmentId,
      filter: filter
    };
    const args = new DepartmentService_getCountUsersByDepartment_args(params);
    try {
      this.output.writeMessageBegin('getCountUsersByDepartment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountUsersByDepartment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountUsersByDepartment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_getCountUsersByDepartment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountUsersByDepartment failed: unknown result';
  }

  createOrUpdateDepartment (token, department) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDepartment(token, department, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDepartment (token, department, callback) {
    const params = {
      token: token,
      department: department
    };
    const args = new DepartmentService_createOrUpdateDepartment_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDepartment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDepartment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDepartment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_createOrUpdateDepartment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDepartment failed: unknown result';
  }

  removeDepartment (token, departmentId, removeType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeDepartment(token, departmentId, removeType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeDepartment (token, departmentId, removeType, callback) {
    const params = {
      token: token,
      departmentId: departmentId,
      removeType: removeType
    };
    const args = new DepartmentService_removeDepartment_args(params);
    try {
      this.output.writeMessageBegin('removeDepartment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeDepartment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeDepartment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_removeDepartment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeDepartment failed: unknown result';
  }

  getAllDepartmentsForUser (token, userId, withParent) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDepartmentsForUser(token, userId, withParent, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDepartmentsForUser (token, userId, withParent, callback) {
    const params = {
      token: token,
      userId: userId,
      withParent: withParent
    };
    const args = new DepartmentService_getAllDepartmentsForUser_args(params);
    try {
      this.output.writeMessageBegin('getAllDepartmentsForUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDepartmentsForUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDepartmentsForUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_getAllDepartmentsForUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDepartmentsForUser failed: unknown result';
  }

  changeUserDepartments (token, userId, toAdd, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeUserDepartments(token, userId, toAdd, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeUserDepartments (token, userId, toAdd, toRemove, callback) {
    const params = {
      token: token,
      userId: userId,
      toAdd: toAdd,
      toRemove: toRemove
    };
    const args = new DepartmentService_changeUserDepartments_args(params);
    try {
      this.output.writeMessageBegin('changeUserDepartments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeUserDepartments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeUserDepartments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_changeUserDepartments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeUserDepartments failed: unknown result';
  }

  moveDepartment (token, departmentId, toDepartmentId, withChilds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_moveDepartment(token, departmentId, toDepartmentId, withChilds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_moveDepartment (token, departmentId, toDepartmentId, withChilds, callback) {
    const params = {
      token: token,
      departmentId: departmentId,
      toDepartmentId: toDepartmentId,
      withChilds: withChilds
    };
    const args = new DepartmentService_moveDepartment_args(params);
    try {
      this.output.writeMessageBegin('moveDepartment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_moveDepartment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_moveDepartment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DepartmentService_moveDepartment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'moveDepartment failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DevicesService_getAllMobileDevices_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_getAllMobileDevices_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesService_getAllMobileDevices_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Device]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new Device();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_getAllMobileDevices_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesService_responseMobileRegistration_args = class {
  constructor(args) {
    this.token = null;
    this.device = null;
    this.code = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.device !== undefined && args.device !== null) {
        this.device = new Device(args.device);
      }
      if (args.code !== undefined && args.code !== null) {
        this.code = args.code;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.device = new Device();
          this.device.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.code = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_responseMobileRegistration_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.device !== null && this.device !== undefined) {
      output.writeFieldBegin('device', Thrift.Type.STRUCT, 2);
      this.device.write(output);
      output.writeFieldEnd();
    }
    if (this.code !== null && this.code !== undefined) {
      output.writeFieldBegin('code', Thrift.Type.STRING, 3);
      output.writeString(this.code);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesService_responseMobileRegistration_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Device(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Device();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_responseMobileRegistration_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesService_forgotMobileRegistration_args = class {
  constructor(args) {
    this.token = null;
    this.udid = null;
    this.newUdid = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.udid !== undefined && args.udid !== null) {
        this.udid = args.udid;
      }
      if (args.newUdid !== undefined && args.newUdid !== null) {
        this.newUdid = args.newUdid;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.udid = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.newUdid = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_forgotMobileRegistration_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.udid !== null && this.udid !== undefined) {
      output.writeFieldBegin('udid', Thrift.Type.STRING, 2);
      output.writeString(this.udid);
      output.writeFieldEnd();
    }
    if (this.newUdid !== null && this.newUdid !== undefined) {
      output.writeFieldBegin('newUdid', Thrift.Type.STRING, 3);
      output.writeString(this.newUdid);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesService_forgotMobileRegistration_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DevicesService_forgotMobileRegistration_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DevicesServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllMobileDevices (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMobileDevices(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMobileDevices (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DevicesService_getAllMobileDevices_args(params);
    try {
      this.output.writeMessageBegin('getAllMobileDevices', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMobileDevices();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMobileDevices () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DevicesService_getAllMobileDevices_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMobileDevices failed: unknown result';
  }

  responseMobileRegistration (token, device, code) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_responseMobileRegistration(token, device, code, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_responseMobileRegistration (token, device, code, callback) {
    const params = {
      token: token,
      device: device,
      code: code
    };
    const args = new DevicesService_responseMobileRegistration_args(params);
    try {
      this.output.writeMessageBegin('responseMobileRegistration', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_responseMobileRegistration();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_responseMobileRegistration () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DevicesService_responseMobileRegistration_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'responseMobileRegistration failed: unknown result';
  }

  forgotMobileRegistration (token, udid, newUdid) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_forgotMobileRegistration(token, udid, newUdid, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_forgotMobileRegistration (token, udid, newUdid, callback) {
    const params = {
      token: token,
      udid: udid,
      newUdid: newUdid
    };
    const args = new DevicesService_forgotMobileRegistration_args(params);
    try {
      this.output.writeMessageBegin('forgotMobileRegistration', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_forgotMobileRegistration();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_forgotMobileRegistration () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DevicesService_forgotMobileRegistration_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'forgotMobileRegistration failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DocumentPatternService_getAllDocumentPatterns_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.withCurrentDocNumber = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.withCurrentDocNumber !== undefined && args.withCurrentDocNumber !== null) {
        this.withCurrentDocNumber = args.withCurrentDocNumber;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.withCurrentDocNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatterns_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.withCurrentDocNumber !== null && this.withCurrentDocNumber !== undefined) {
      output.writeFieldBegin('withCurrentDocNumber', Thrift.Type.BOOL, 3);
      output.writeBool(this.withCurrentDocNumber);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatterns_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPattern]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = new DocumentPattern();
            elem58.read(input);
            this.success.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatterns_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter59 in this.success) {
        if (this.success.hasOwnProperty(iter59)) {
          iter59 = this.success[iter59];
          iter59.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternsGroupByName_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternsGroupByName_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternsGroupByName_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SimpleDocumentPatternOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = new SimpleDocumentPatternOrGroup();
            elem63.read(input);
            this.success.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternsGroupByName_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter64 in this.success) {
        if (this.success.hasOwnProperty(iter64)) {
          iter64 = this.success[iter64];
          iter64.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPattern(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPattern();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.documentPattern = null;
    this.accountId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentPattern !== undefined && args.documentPattern !== null) {
        this.documentPattern = new DocumentPattern(args.documentPattern);
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPattern = new DocumentPattern();
          this.documentPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentPattern !== null && this.documentPattern !== undefined) {
      output.writeFieldBegin('documentPattern', Thrift.Type.STRUCT, 2);
      this.documentPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPattern(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPattern();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_exportPatternAsDocumentDraftXML_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_exportPatternAsDocumentDraftXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_exportPatternAsDocumentDraftXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_exportPatternAsDocumentDraftXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    this.selector = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.selector !== undefined && args.selector !== null) {
        this.selector = args.selector;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.selector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.selector !== null && this.selector !== undefined) {
      output.writeFieldBegin('selector', Thrift.Type.I32, 4);
      output.writeI32(this.selector);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp366 = input.readListBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = new DocumentPatternStage();
            elem68.read(input);
            this.success.push(elem68);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter69 in this.success) {
        if (this.success.hasOwnProperty(iter69)) {
          iter69 = this.success[iter69];
          iter69.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPatternStage_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPatternStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPatternStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPatternStage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPatternStage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPatternStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageId = null;
    this.newDocPatternStageId = null;
    this.fillDocPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
      if (args.newDocPatternStageId !== undefined && args.newDocPatternStageId !== null) {
        this.newDocPatternStageId = args.newDocPatternStageId;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.newDocPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    if (this.newDocPatternStageId !== null && this.newDocPatternStageId !== undefined) {
      output.writeFieldBegin('newDocPatternStageId', Thrift.Type.STRING, 3);
      output.writeString(this.newDocPatternStageId);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 4);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateStagesAndLinks_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.stages = null;
    this.links = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.links !== undefined && args.links !== null) {
        this.links = Thrift.copyList(args.links, [DocumentPatternStagesLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = new DocumentPatternStage();
            elem73.read(input);
            this.stages.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.links = [];
          const _rtmp375 = input.readListBegin();
          const _size74 = _rtmp375.size || 0;
          for (let _i76 = 0; _i76 < _size74; ++_i76) {
            let elem77 = null;
            elem77 = new DocumentPatternStagesLink();
            elem77.read(input);
            this.links.push(elem77);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateStagesAndLinks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter78 in this.stages) {
        if (this.stages.hasOwnProperty(iter78)) {
          iter78 = this.stages[iter78];
          iter78.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.links !== null && this.links !== undefined) {
      output.writeFieldBegin('links', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.links.length);
      for (let iter79 in this.links) {
        if (this.links.hasOwnProperty(iter79)) {
          iter79 = this.links[iter79];
          iter79.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateStagesAndLinks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PatternData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PatternData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateStagesAndLinks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStagesLinks_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.docPatternStageId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStagesLinks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 3);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStagesLinks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStagesLink]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = new DocumentPatternStagesLink();
            elem83.read(input);
            this.success.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStagesLinks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter84 in this.success) {
        if (this.success.hasOwnProperty(iter84)) {
          iter84 = this.success[iter84];
          iter84.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPatternStageLink_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageLinkId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageLinkId !== undefined && args.docPatternStageLinkId !== null) {
        this.docPatternStageLinkId = args.docPatternStageLinkId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageLinkId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPatternStageLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageLinkId !== null && this.docPatternStageLinkId !== undefined) {
      output.writeFieldBegin('docPatternStageLinkId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageLinkId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getDocumentPatternStageLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPatternStagesLink(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPatternStagesLink();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getDocumentPatternStageLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPatternStagesLink_args = class {
  constructor(args) {
    this.token = null;
    this.documentPatternStagesLink = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentPatternStagesLink !== undefined && args.documentPatternStagesLink !== null) {
        this.documentPatternStagesLink = new DocumentPatternStagesLink(args.documentPatternStagesLink);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternStagesLink = new DocumentPatternStagesLink();
          this.documentPatternStagesLink.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPatternStagesLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentPatternStagesLink !== null && this.documentPatternStagesLink !== undefined) {
      output.writeFieldBegin('documentPatternStagesLink', Thrift.Type.STRUCT, 2);
      this.documentPatternStagesLink.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPatternStagesLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPatternStagesLink(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPatternStagesLink();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPatternStagesLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternStageLink_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageLinkId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageLinkId !== undefined && args.docPatternStageLinkId !== null) {
        this.docPatternStageLinkId = args.docPatternStageLinkId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageLinkId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternStageLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageLinkId !== null && this.docPatternStageLinkId !== undefined) {
      output.writeFieldBegin('docPatternStageLinkId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageLinkId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternStageLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternStageLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStageExecutors_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStageExecutors_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternStageExecutors_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStagesExecutor]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp386 = input.readListBegin();
          const _size85 = _rtmp386.size || 0;
          for (let _i87 = 0; _i87 < _size85; ++_i87) {
            let elem88 = null;
            elem88 = new DocumentPatternStagesExecutor();
            elem88.read(input);
            this.success.push(elem88);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternStageExecutors_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter89 in this.success) {
        if (this.success.hasOwnProperty(iter89)) {
          iter89 = this.success[iter89];
          iter89.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_addExecutorsToDocumentPatternStage_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageId = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp391 = input.readListBegin();
          const _size90 = _rtmp391.size || 0;
          for (let _i92 = 0; _i92 < _size90; ++_i92) {
            let elem93 = null;
            elem93 = new UserOrGroup();
            elem93.read(input);
            this.userOrGroups.push(elem93);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_addExecutorsToDocumentPatternStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter94 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter94)) {
          iter94 = this.userOrGroups[iter94];
          iter94.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_addExecutorsToDocumentPatternStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_addExecutorsToDocumentPatternStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteExecutorsFromDocumentPatternStage_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternStageId = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternStageId !== undefined && args.docPatternStageId !== null) {
        this.docPatternStageId = args.docPatternStageId;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp396 = input.readListBegin();
          const _size95 = _rtmp396.size || 0;
          for (let _i97 = 0; _i97 < _size95; ++_i97) {
            let elem98 = null;
            elem98 = new UserOrGroup();
            elem98.read(input);
            this.userOrGroups.push(elem98);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteExecutorsFromDocumentPatternStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternStageId !== null && this.docPatternStageId !== undefined) {
      output.writeFieldBegin('docPatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternStageId);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter99 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter99)) {
          iter99 = this.userOrGroups[iter99];
          iter99.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteExecutorsFromDocumentPatternStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteExecutorsFromDocumentPatternStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_checkDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_checkDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_checkDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3101 = input.readListBegin();
          const _size100 = _rtmp3101.size || 0;
          for (let _i102 = 0; _i102 < _size100; ++_i102) {
            let elem103 = null;
            elem103 = new PreconditionException();
            elem103.read(input);
            this.success.push(elem103);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_checkDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter104 in this.success) {
        if (this.success.hasOwnProperty(iter104)) {
          iter104 = this.success[iter104];
          iter104.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternContentItems_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.contentItems = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3106 = input.readListBegin();
          const _size105 = _rtmp3106.size || 0;
          for (let _i107 = 0; _i107 < _size105; ++_i107) {
            let elem108 = null;
            elem108 = new ContentItem();
            elem108.read(input);
            this.contentItems.push(elem108);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternContentItems_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter109 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter109)) {
          iter109 = this.contentItems[iter109];
          iter109.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternContentItems_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentItem]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3111 = input.readListBegin();
          const _size110 = _rtmp3111.size || 0;
          for (let _i112 = 0; _i112 < _size110; ++_i112) {
            let elem113 = null;
            elem113 = new ContentItem();
            elem113.read(input);
            this.success.push(elem113);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternContentItems_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter114 in this.success) {
        if (this.success.hasOwnProperty(iter114)) {
          iter114 = this.success[iter114];
          iter114.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deletePatternContentItem_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.contentItemKey = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.contentItemKey !== undefined && args.contentItemKey !== null) {
        this.contentItemKey = args.contentItemKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.contentItemKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deletePatternContentItem_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.contentItemKey !== null && this.contentItemKey !== undefined) {
      output.writeFieldBegin('contentItemKey', Thrift.Type.STRING, 3);
      output.writeString(this.contentItemKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deletePatternContentItem_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deletePatternContentItem_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.patternContentTab = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.patternContentTab !== undefined && args.patternContentTab !== null) {
        this.patternContentTab = new ContentTab(args.patternContentTab);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.patternContentTab = new ContentTab();
          this.patternContentTab.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.patternContentTab !== null && this.patternContentTab !== undefined) {
      output.writeFieldBegin('patternContentTab', Thrift.Type.STRUCT, 3);
      this.patternContentTab.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ContentTab(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ContentTab();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternContentTabsByFilter_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternContentTabsByFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternContentTabsByFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentTab]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3116 = input.readListBegin();
          const _size115 = _rtmp3116.size || 0;
          for (let _i117 = 0; _i117 < _size115; ++_i117) {
            let elem118 = null;
            elem118 = new ContentTab();
            elem118.read(input);
            this.success.push(elem118);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternContentTabsByFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter119 in this.success) {
        if (this.success.hasOwnProperty(iter119)) {
          iter119 = this.success[iter119];
          iter119.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deletePatternContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.patternContentTabId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternContentTabId !== undefined && args.patternContentTabId !== null) {
        this.patternContentTabId = args.patternContentTabId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternContentTabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deletePatternContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternContentTabId !== null && this.patternContentTabId !== undefined) {
      output.writeFieldBegin('patternContentTabId', Thrift.Type.STRING, 2);
      output.writeString(this.patternContentTabId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deletePatternContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deletePatternContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternGroups_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3121 = input.readListBegin();
          const _size120 = _rtmp3121.size || 0;
          for (let _i122 = 0; _i122 < _size120; ++_i122) {
            let elem123 = null;
            elem123 = new DocumentPatternGroup();
            elem123.read(input);
            this.success.push(elem123);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter124 in this.success) {
        if (this.success.hasOwnProperty(iter124)) {
          iter124 = this.success[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternGroupsGroupByName_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternGroupsGroupByName_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDocumentPatternGroupsGroupByName_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SimpleDocumentPatternOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3126 = input.readListBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            let elem128 = null;
            elem128 = new SimpleDocumentPatternOrGroup();
            elem128.read(input);
            this.success.push(elem128);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDocumentPatternGroupsGroupByName_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter129 in this.success) {
        if (this.success.hasOwnProperty(iter129)) {
          iter129 = this.success[iter129];
          iter129.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPatternGroup_args = class {
  constructor(args) {
    this.token = null;
    this.documentPatternGroup = null;
    this.accountId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPatternGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 2);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDocumentPatternGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPatternGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPatternGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDocumentPatternGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternGroup_args = class {
  constructor(args) {
    this.token = null;
    this.documentPatternGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentPatternGroupId !== undefined && args.documentPatternGroupId !== null) {
        this.documentPatternGroupId = args.documentPatternGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentPatternGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroupId !== null && this.documentPatternGroupId !== undefined) {
      output.writeFieldBegin('documentPatternGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.documentPatternGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDocumentPatternGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDocumentPatternGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllAvailableStages_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllAvailableStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllAvailableStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [AvailablePatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3131 = input.readListBegin();
          const _size130 = _rtmp3131.size || 0;
          for (let _i132 = 0; _i132 < _size130; ++_i132) {
            let elem133 = null;
            elem133 = new AvailablePatternStage();
            elem133.read(input);
            this.success.push(elem133);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllAvailableStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter134 in this.success) {
        if (this.success.hasOwnProperty(iter134)) {
          iter134 = this.success[iter134];
          iter134.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAvailableLinkAnswersByPattern_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAvailableLinkAnswersByPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAvailableLinkAnswersByPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp3136 = input.readSetBegin();
          const _size135 = _rtmp3136.size || 0;
          for (let _i137 = 0; _i137 < _size135; ++_i137) {
            let elem138 = null;
            elem138 = input.readString().value;
            this.success.push(elem138);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAvailableLinkAnswersByPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRING, this.success.length);
      for (let iter139 in this.success) {
        if (this.success.hasOwnProperty(iter139)) {
          iter139 = this.success[iter139];
          output.writeString(iter139);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeAvailableStage_args = class {
  constructor(args) {
    this.token = null;
    this.availStageId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.availStageId !== undefined && args.availStageId !== null) {
        this.availStageId = args.availStageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.availStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeAvailableStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.availStageId !== null && this.availStageId !== undefined) {
      output.writeFieldBegin('availStageId', Thrift.Type.STRING, 2);
      output.writeString(this.availStageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeAvailableStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeAvailableStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDigitalViews_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDigitalViews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllDigitalViews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DigitalView]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3141 = input.readListBegin();
          const _size140 = _rtmp3141.size || 0;
          for (let _i142 = 0; _i142 < _size140; ++_i142) {
            let elem143 = null;
            elem143 = new DigitalView();
            elem143.read(input);
            this.success.push(elem143);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllDigitalViews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter144 in this.success) {
        if (this.success.hasOwnProperty(iter144)) {
          iter144 = this.success[iter144];
          iter144.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDigitalView_args = class {
  constructor(args) {
    this.token = null;
    this.digitalView = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.digitalView !== undefined && args.digitalView !== null) {
        this.digitalView = new DigitalView(args.digitalView);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.digitalView = new DigitalView();
          this.digitalView.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDigitalView_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.digitalView !== null && this.digitalView !== undefined) {
      output.writeFieldBegin('digitalView', Thrift.Type.STRUCT, 2);
      this.digitalView.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateDigitalView_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DigitalView(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DigitalView();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateDigitalView_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDigitalView_args = class {
  constructor(args) {
    this.token = null;
    this.digitalViewId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.digitalViewId !== undefined && args.digitalViewId !== null) {
        this.digitalViewId = args.digitalViewId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.digitalViewId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDigitalView_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.digitalViewId !== null && this.digitalViewId !== undefined) {
      output.writeFieldBegin('digitalViewId', Thrift.Type.STRING, 2);
      output.writeString(this.digitalViewId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_deleteDigitalView_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_deleteDigitalView_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_exportDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_exportDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_exportDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_exportDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_importDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.json = null;
    this.docPatternName = null;
    this.pDescription = null;
    this.docPatternGroupId = null;
    this.accountId = null;
    this.ignoreError = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.json !== undefined && args.json !== null) {
        this.json = args.json;
      }
      if (args.docPatternName !== undefined && args.docPatternName !== null) {
        this.docPatternName = args.docPatternName;
      }
      if (args.pDescription !== undefined && args.pDescription !== null) {
        this.pDescription = args.pDescription;
      }
      if (args.docPatternGroupId !== undefined && args.docPatternGroupId !== null) {
        this.docPatternGroupId = args.docPatternGroupId;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.ignoreError !== undefined && args.ignoreError !== null) {
        this.ignoreError = args.ignoreError;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.json = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.pDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.ignoreError = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_importDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.json !== null && this.json !== undefined) {
      output.writeFieldBegin('json', Thrift.Type.STRING, 2);
      output.writeBinary(this.json);
      output.writeFieldEnd();
    }
    if (this.docPatternName !== null && this.docPatternName !== undefined) {
      output.writeFieldBegin('docPatternName', Thrift.Type.STRING, 3);
      output.writeString(this.docPatternName);
      output.writeFieldEnd();
    }
    if (this.pDescription !== null && this.pDescription !== undefined) {
      output.writeFieldBegin('pDescription', Thrift.Type.STRING, 4);
      output.writeString(this.pDescription);
      output.writeFieldEnd();
    }
    if (this.docPatternGroupId !== null && this.docPatternGroupId !== undefined) {
      output.writeFieldBegin('docPatternGroupId', Thrift.Type.STRING, 5);
      output.writeString(this.docPatternGroupId);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 6);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.ignoreError !== null && this.ignoreError !== undefined) {
      output.writeFieldBegin('ignoreError', Thrift.Type.BOOL, 7);
      output.writeBool(this.ignoreError);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_importDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPattern(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPattern();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_importDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternUserGroup_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternUserGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternUserGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternUserGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3146 = input.readListBegin();
          const _size145 = _rtmp3146.size || 0;
          for (let _i147 = 0; _i147 < _size145; ++_i147) {
            let elem148 = null;
            elem148 = new PatternUserGroup();
            elem148.read(input);
            this.success.push(elem148);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternUserGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter149 in this.success) {
        if (this.success.hasOwnProperty(iter149)) {
          iter149 = this.success[iter149];
          iter149.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternUserGroup_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [PatternUserGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp3151 = input.readListBegin();
          const _size150 = _rtmp3151.size || 0;
          for (let _i152 = 0; _i152 < _size150; ++_i152) {
            let elem153 = null;
            elem153 = new PatternUserGroup();
            elem153.read(input);
            this.userOrGroups.push(elem153);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternUserGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter154 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter154)) {
          iter154 = this.userOrGroups[iter154];
          iter154.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternUserGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternUserGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternProcessRoles_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternProcessRoles_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternProcessRoles_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternProcessRole]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3156 = input.readListBegin();
          const _size155 = _rtmp3156.size || 0;
          for (let _i157 = 0; _i157 < _size155; ++_i157) {
            let elem158 = null;
            elem158 = new PatternProcessRole();
            elem158.read(input);
            this.success.push(elem158);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternProcessRoles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter159 in this.success) {
        if (this.success.hasOwnProperty(iter159)) {
          iter159 = this.success[iter159];
          iter159.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changePatternProcessRoles_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.userOrGroupsToAdd = null;
    this.keyIdToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.userOrGroupsToAdd !== undefined && args.userOrGroupsToAdd !== null) {
        this.userOrGroupsToAdd = Thrift.copyList(args.userOrGroupsToAdd, [PatternProcessRole]);
      }
      if (args.keyIdToRemove !== undefined && args.keyIdToRemove !== null) {
        this.keyIdToRemove = Thrift.copyList(args.keyIdToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroupsToAdd = [];
          const _rtmp3161 = input.readListBegin();
          const _size160 = _rtmp3161.size || 0;
          for (let _i162 = 0; _i162 < _size160; ++_i162) {
            let elem163 = null;
            elem163 = new PatternProcessRole();
            elem163.read(input);
            this.userOrGroupsToAdd.push(elem163);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.SET) {
          this.keyIdToRemove = [];
          const _rtmp3165 = input.readSetBegin();
          const _size164 = _rtmp3165.size || 0;
          for (let _i166 = 0; _i166 < _size164; ++_i166) {
            let elem167 = null;
            elem167 = input.readString().value;
            this.keyIdToRemove.push(elem167);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changePatternProcessRoles_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.userOrGroupsToAdd !== null && this.userOrGroupsToAdd !== undefined) {
      output.writeFieldBegin('userOrGroupsToAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroupsToAdd.length);
      for (let iter168 in this.userOrGroupsToAdd) {
        if (this.userOrGroupsToAdd.hasOwnProperty(iter168)) {
          iter168 = this.userOrGroupsToAdd[iter168];
          iter168.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.keyIdToRemove !== null && this.keyIdToRemove !== undefined) {
      output.writeFieldBegin('keyIdToRemove', Thrift.Type.SET, 4);
      output.writeSetBegin(Thrift.Type.STRING, this.keyIdToRemove.length);
      for (let iter169 in this.keyIdToRemove) {
        if (this.keyIdToRemove.hasOwnProperty(iter169)) {
          iter169 = this.keyIdToRemove[iter169];
          output.writeString(iter169);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changePatternProcessRoles_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternProcessRole]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3171 = input.readListBegin();
          const _size170 = _rtmp3171.size || 0;
          for (let _i172 = 0; _i172 < _size170; ++_i172) {
            let elem173 = null;
            elem173 = new PatternProcessRole();
            elem173.read(input);
            this.success.push(elem173);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changePatternProcessRoles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter174 in this.success) {
        if (this.success.hasOwnProperty(iter174)) {
          iter174 = this.success[iter174];
          iter174.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternVariables_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternVariables_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternVariables_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternVariable]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3176 = input.readListBegin();
          const _size175 = _rtmp3176.size || 0;
          for (let _i177 = 0; _i177 < _size175; ++_i177) {
            let elem178 = null;
            elem178 = new PatternVariable();
            elem178.read(input);
            this.success.push(elem178);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternVariables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter179 in this.success) {
        if (this.success.hasOwnProperty(iter179)) {
          iter179 = this.success[iter179];
          iter179.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changePatternVariables_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.patternVariablesToAdd = null;
    this.keyIdToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.patternVariablesToAdd !== undefined && args.patternVariablesToAdd !== null) {
        this.patternVariablesToAdd = Thrift.copyList(args.patternVariablesToAdd, [PatternVariable]);
      }
      if (args.keyIdToRemove !== undefined && args.keyIdToRemove !== null) {
        this.keyIdToRemove = Thrift.copyList(args.keyIdToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.patternVariablesToAdd = [];
          const _rtmp3181 = input.readListBegin();
          const _size180 = _rtmp3181.size || 0;
          for (let _i182 = 0; _i182 < _size180; ++_i182) {
            let elem183 = null;
            elem183 = new PatternVariable();
            elem183.read(input);
            this.patternVariablesToAdd.push(elem183);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.SET) {
          this.keyIdToRemove = [];
          const _rtmp3185 = input.readSetBegin();
          const _size184 = _rtmp3185.size || 0;
          for (let _i186 = 0; _i186 < _size184; ++_i186) {
            let elem187 = null;
            elem187 = input.readString().value;
            this.keyIdToRemove.push(elem187);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changePatternVariables_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.patternVariablesToAdd !== null && this.patternVariablesToAdd !== undefined) {
      output.writeFieldBegin('patternVariablesToAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternVariablesToAdd.length);
      for (let iter188 in this.patternVariablesToAdd) {
        if (this.patternVariablesToAdd.hasOwnProperty(iter188)) {
          iter188 = this.patternVariablesToAdd[iter188];
          iter188.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.keyIdToRemove !== null && this.keyIdToRemove !== undefined) {
      output.writeFieldBegin('keyIdToRemove', Thrift.Type.SET, 4);
      output.writeSetBegin(Thrift.Type.STRING, this.keyIdToRemove.length);
      for (let iter189 in this.keyIdToRemove) {
        if (this.keyIdToRemove.hasOwnProperty(iter189)) {
          iter189 = this.keyIdToRemove[iter189];
          output.writeString(iter189);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changePatternVariables_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternVariable]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3191 = input.readListBegin();
          const _size190 = _rtmp3191.size || 0;
          for (let _i192 = 0; _i192 < _size190; ++_i192) {
            let elem193 = null;
            elem193 = new PatternVariable();
            elem193.read(input);
            this.success.push(elem193);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changePatternVariables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter194 in this.success) {
        if (this.success.hasOwnProperty(iter194)) {
          iter194 = this.success[iter194];
          iter194.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_addAvailablePatternStageToAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.availablePatternStageId = null;
    this.accountIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.availablePatternStageId !== undefined && args.availablePatternStageId !== null) {
        this.availablePatternStageId = args.availablePatternStageId;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.availablePatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.accountIds = [];
          const _rtmp3196 = input.readListBegin();
          const _size195 = _rtmp3196.size || 0;
          for (let _i197 = 0; _i197 < _size195; ++_i197) {
            let elem198 = null;
            elem198 = input.readString().value;
            this.accountIds.push(elem198);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_addAvailablePatternStageToAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.availablePatternStageId !== null && this.availablePatternStageId !== undefined) {
      output.writeFieldBegin('availablePatternStageId', Thrift.Type.STRING, 2);
      output.writeString(this.availablePatternStageId);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter199 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter199)) {
          iter199 = this.accountIds[iter199];
          output.writeString(iter199);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_addAvailablePatternStageToAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_addAvailablePatternStageToAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllPatternAttachmentTemplates_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllPatternAttachmentTemplates_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllPatternAttachmentTemplates_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternAttachmentTemplate]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3201 = input.readListBegin();
          const _size200 = _rtmp3201.size || 0;
          for (let _i202 = 0; _i202 < _size200; ++_i202) {
            let elem203 = null;
            elem203 = new PatternAttachmentTemplate();
            elem203.read(input);
            this.success.push(elem203);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllPatternAttachmentTemplates_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter204 in this.success) {
        if (this.success.hasOwnProperty(iter204)) {
          iter204 = this.success[iter204];
          iter204.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternAttachmentTemplateById_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternAttachmentTemplateById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternAttachmentTemplateById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PatternAttachmentTemplate(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PatternAttachmentTemplate();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternAttachmentTemplateById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternAttachmentTemplate_args = class {
  constructor(args) {
    this.token = null;
    this.patternAttachmentTemplate = null;
    this.xmlFile = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternAttachmentTemplate !== undefined && args.patternAttachmentTemplate !== null) {
        this.patternAttachmentTemplate = new PatternAttachmentTemplate(args.patternAttachmentTemplate);
      }
      if (args.xmlFile !== undefined && args.xmlFile !== null) {
        this.xmlFile = args.xmlFile;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.patternAttachmentTemplate = new PatternAttachmentTemplate();
          this.patternAttachmentTemplate.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.xmlFile = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternAttachmentTemplate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternAttachmentTemplate !== null && this.patternAttachmentTemplate !== undefined) {
      output.writeFieldBegin('patternAttachmentTemplate', Thrift.Type.STRUCT, 2);
      this.patternAttachmentTemplate.write(output);
      output.writeFieldEnd();
    }
    if (this.xmlFile !== null && this.xmlFile !== undefined) {
      output.writeFieldBegin('xmlFile', Thrift.Type.STRING, 3);
      output.writeBinary(this.xmlFile);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdatePatternAttachmentTemplate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PatternAttachmentTemplate(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PatternAttachmentTemplate();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdatePatternAttachmentTemplate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_downloadPatternAttachmentTemplate_args = class {
  constructor(args) {
    this.token = null;
    this.patternAttachmentTemplateId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternAttachmentTemplateId !== undefined && args.patternAttachmentTemplateId !== null) {
        this.patternAttachmentTemplateId = args.patternAttachmentTemplateId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternAttachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_downloadPatternAttachmentTemplate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternAttachmentTemplateId !== null && this.patternAttachmentTemplateId !== undefined) {
      output.writeFieldBegin('patternAttachmentTemplateId', Thrift.Type.STRING, 2);
      output.writeString(this.patternAttachmentTemplateId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_downloadPatternAttachmentTemplate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_downloadPatternAttachmentTemplate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removePatternAttachmentTemplate_args = class {
  constructor(args) {
    this.token = null;
    this.patternAttachmentTemplateId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternAttachmentTemplateId !== undefined && args.patternAttachmentTemplateId !== null) {
        this.patternAttachmentTemplateId = args.patternAttachmentTemplateId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternAttachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removePatternAttachmentTemplate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternAttachmentTemplateId !== null && this.patternAttachmentTemplateId !== undefined) {
      output.writeFieldBegin('patternAttachmentTemplateId', Thrift.Type.STRING, 2);
      output.writeString(this.patternAttachmentTemplateId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removePatternAttachmentTemplate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removePatternAttachmentTemplate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changeStartDocNumberSequence_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.value = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.value = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changeStartDocNumberSequence_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.I64, 3);
      output.writeI64(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changeStartDocNumberSequence_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changeStartDocNumberSequence_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllContentHolders_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.withContent = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.withContent !== undefined && args.withContent !== null) {
        this.withContent = args.withContent;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.withContent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllContentHolders_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.withContent !== null && this.withContent !== undefined) {
      output.writeFieldBegin('withContent', Thrift.Type.BOOL, 3);
      output.writeBool(this.withContent);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllContentHolders_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentHolder]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3206 = input.readListBegin();
          const _size205 = _rtmp3206.size || 0;
          for (let _i207 = 0; _i207 < _size205; ++_i207) {
            let elem208 = null;
            elem208 = new ContentHolder();
            elem208.read(input);
            this.success.push(elem208);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllContentHolders_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter209 in this.success) {
        if (this.success.hasOwnProperty(iter209)) {
          iter209 = this.success[iter209];
          iter209.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changeContentHolders_args = class {
  constructor(args) {
    this.token = null;
    this.toUpdate = null;
    this.toRemoveIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toUpdate !== undefined && args.toUpdate !== null) {
        this.toUpdate = Thrift.copyList(args.toUpdate, [ContentHolder]);
      }
      if (args.toRemoveIds !== undefined && args.toRemoveIds !== null) {
        this.toRemoveIds = Thrift.copyList(args.toRemoveIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toUpdate = [];
          const _rtmp3211 = input.readListBegin();
          const _size210 = _rtmp3211.size || 0;
          for (let _i212 = 0; _i212 < _size210; ++_i212) {
            let elem213 = null;
            elem213 = new ContentHolder();
            elem213.read(input);
            this.toUpdate.push(elem213);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemoveIds = [];
          const _rtmp3215 = input.readListBegin();
          const _size214 = _rtmp3215.size || 0;
          for (let _i216 = 0; _i216 < _size214; ++_i216) {
            let elem217 = null;
            elem217 = input.readString().value;
            this.toRemoveIds.push(elem217);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changeContentHolders_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toUpdate !== null && this.toUpdate !== undefined) {
      output.writeFieldBegin('toUpdate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toUpdate.length);
      for (let iter218 in this.toUpdate) {
        if (this.toUpdate.hasOwnProperty(iter218)) {
          iter218 = this.toUpdate[iter218];
          iter218.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemoveIds !== null && this.toRemoveIds !== undefined) {
      output.writeFieldBegin('toRemoveIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemoveIds.length);
      for (let iter219 in this.toRemoveIds) {
        if (this.toRemoveIds.hasOwnProperty(iter219)) {
          iter219 = this.toRemoveIds[iter219];
          output.writeString(iter219);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_changeContentHolders_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentHolder]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3221 = input.readListBegin();
          const _size220 = _rtmp3221.size || 0;
          for (let _i222 = 0; _i222 < _size220; ++_i222) {
            let elem223 = null;
            elem223 = new ContentHolder();
            elem223.read(input);
            this.success.push(elem223);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_changeContentHolders_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter224 in this.success) {
        if (this.success.hasOwnProperty(iter224)) {
          iter224 = this.success[iter224];
          iter224.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternRelationModel_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternRelationModel_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternRelationModel_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PatternRelationModel(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PatternRelationModel();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternRelationModel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getNomenclatureNumber_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureNumberId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureNumberId !== undefined && args.nomenclatureNumberId !== null) {
        this.nomenclatureNumberId = args.nomenclatureNumberId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureNumberId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getNomenclatureNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumberId !== null && this.nomenclatureNumberId !== undefined) {
      output.writeFieldBegin('nomenclatureNumberId', Thrift.Type.STRING, 2);
      output.writeString(this.nomenclatureNumberId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getNomenclatureNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new NomenclatureNumber(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new NomenclatureNumber();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getNomenclatureNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllNomenclatureNumber_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllNomenclatureNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllNomenclatureNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NomenclatureNumber]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3226 = input.readListBegin();
          const _size225 = _rtmp3226.size || 0;
          for (let _i227 = 0; _i227 < _size225; ++_i227) {
            let elem228 = null;
            elem228 = new NomenclatureNumber();
            elem228.read(input);
            this.success.push(elem228);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllNomenclatureNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter229 in this.success) {
        if (this.success.hasOwnProperty(iter229)) {
          iter229 = this.success[iter229];
          iter229.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getCountAllNomenclatureNumber_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getCountAllNomenclatureNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getCountAllNomenclatureNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getCountAllNomenclatureNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateNomenclatureNumber_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureNumber = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureNumber !== undefined && args.nomenclatureNumber !== null) {
        this.nomenclatureNumber = new NomenclatureNumber(args.nomenclatureNumber);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureNumber = new NomenclatureNumber();
          this.nomenclatureNumber.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateNomenclatureNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumber !== null && this.nomenclatureNumber !== undefined) {
      output.writeFieldBegin('nomenclatureNumber', Thrift.Type.STRUCT, 2);
      this.nomenclatureNumber.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateNomenclatureNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new NomenclatureNumber(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new NomenclatureNumber();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateNomenclatureNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeNomenclatureNumber_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureNumberId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureNumberId !== undefined && args.nomenclatureNumberId !== null) {
        this.nomenclatureNumberId = args.nomenclatureNumberId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureNumberId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeNomenclatureNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumberId !== null && this.nomenclatureNumberId !== undefined) {
      output.writeFieldBegin('nomenclatureNumberId', Thrift.Type.STRING, 2);
      output.writeString(this.nomenclatureNumberId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeNomenclatureNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeNomenclatureNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getNomenclatureGroup_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureGroupId !== undefined && args.nomenclatureGroupId !== null) {
        this.nomenclatureGroupId = args.nomenclatureGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getNomenclatureGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureGroupId !== null && this.nomenclatureGroupId !== undefined) {
      output.writeFieldBegin('nomenclatureGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.nomenclatureGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getNomenclatureGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new NomenclatureGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new NomenclatureGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getNomenclatureGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllNomenclatureGroup_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllNomenclatureGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getAllNomenclatureGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NomenclatureGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3231 = input.readListBegin();
          const _size230 = _rtmp3231.size || 0;
          for (let _i232 = 0; _i232 < _size230; ++_i232) {
            let elem233 = null;
            elem233 = new NomenclatureGroup();
            elem233.read(input);
            this.success.push(elem233);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getAllNomenclatureGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter234 in this.success) {
        if (this.success.hasOwnProperty(iter234)) {
          iter234 = this.success[iter234];
          iter234.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getCountAllNomenclatureGroup_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getCountAllNomenclatureGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getCountAllNomenclatureGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getCountAllNomenclatureGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateNomenclatureGroup_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureGroup = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureGroup !== undefined && args.nomenclatureGroup !== null) {
        this.nomenclatureGroup = new NomenclatureGroup(args.nomenclatureGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureGroup = new NomenclatureGroup();
          this.nomenclatureGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateNomenclatureGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureGroup !== null && this.nomenclatureGroup !== undefined) {
      output.writeFieldBegin('nomenclatureGroup', Thrift.Type.STRUCT, 2);
      this.nomenclatureGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateNomenclatureGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new NomenclatureGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new NomenclatureGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateNomenclatureGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeNomenclatureGroup_args = class {
  constructor(args) {
    this.token = null;
    this.nomenclatureGrouprId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.nomenclatureGrouprId !== undefined && args.nomenclatureGrouprId !== null) {
        this.nomenclatureGrouprId = args.nomenclatureGrouprId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureGrouprId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeNomenclatureGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.nomenclatureGrouprId !== null && this.nomenclatureGrouprId !== undefined) {
      output.writeFieldBegin('nomenclatureGrouprId', Thrift.Type.STRING, 2);
      output.writeString(this.nomenclatureGrouprId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_removeNomenclatureGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_removeNomenclatureGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getInfoForCreateDoc_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.parentDocId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.parentDocId !== undefined && args.parentDocId !== null) {
        this.parentDocId = args.parentDocId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.parentDocId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getInfoForCreateDoc_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.parentDocId !== null && this.parentDocId !== undefined) {
      output.writeFieldBegin('parentDocId', Thrift.Type.STRING, 3);
      output.writeString(this.parentDocId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getInfoForCreateDoc_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new InfoForCreateDoc(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new InfoForCreateDoc();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getInfoForCreateDoc_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternContentItems_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternContentItems_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_getPatternContentItems_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentItem]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3236 = input.readListBegin();
          const _size235 = _rtmp3236.size || 0;
          for (let _i237 = 0; _i237 < _size235; ++_i237) {
            let elem238 = null;
            elem238 = new ContentItem();
            elem238.read(input);
            this.success.push(elem238);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_getPatternContentItems_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter239 in this.success) {
        if (this.success.hasOwnProperty(iter239)) {
          iter239 = this.success[iter239];
          iter239.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateStagesAndLinksEx_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.stages = null;
    this.links = null;
    this.stageToRemove = null;
    this.linkToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.links !== undefined && args.links !== null) {
        this.links = Thrift.copyList(args.links, [DocumentPatternStagesLink]);
      }
      if (args.stageToRemove !== undefined && args.stageToRemove !== null) {
        this.stageToRemove = Thrift.copyList(args.stageToRemove, [null]);
      }
      if (args.linkToRemove !== undefined && args.linkToRemove !== null) {
        this.linkToRemove = Thrift.copyList(args.linkToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp3241 = input.readListBegin();
          const _size240 = _rtmp3241.size || 0;
          for (let _i242 = 0; _i242 < _size240; ++_i242) {
            let elem243 = null;
            elem243 = new DocumentPatternStage();
            elem243.read(input);
            this.stages.push(elem243);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.links = [];
          const _rtmp3245 = input.readListBegin();
          const _size244 = _rtmp3245.size || 0;
          for (let _i246 = 0; _i246 < _size244; ++_i246) {
            let elem247 = null;
            elem247 = new DocumentPatternStagesLink();
            elem247.read(input);
            this.links.push(elem247);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.stageToRemove = [];
          const _rtmp3249 = input.readListBegin();
          const _size248 = _rtmp3249.size || 0;
          for (let _i250 = 0; _i250 < _size248; ++_i250) {
            let elem251 = null;
            elem251 = input.readString().value;
            this.stageToRemove.push(elem251);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.linkToRemove = [];
          const _rtmp3253 = input.readListBegin();
          const _size252 = _rtmp3253.size || 0;
          for (let _i254 = 0; _i254 < _size252; ++_i254) {
            let elem255 = null;
            elem255 = input.readString().value;
            this.linkToRemove.push(elem255);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateStagesAndLinksEx_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter256 in this.stages) {
        if (this.stages.hasOwnProperty(iter256)) {
          iter256 = this.stages[iter256];
          iter256.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.links !== null && this.links !== undefined) {
      output.writeFieldBegin('links', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.links.length);
      for (let iter257 in this.links) {
        if (this.links.hasOwnProperty(iter257)) {
          iter257 = this.links[iter257];
          iter257.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.stageToRemove !== null && this.stageToRemove !== undefined) {
      output.writeFieldBegin('stageToRemove', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.stageToRemove.length);
      for (let iter258 in this.stageToRemove) {
        if (this.stageToRemove.hasOwnProperty(iter258)) {
          iter258 = this.stageToRemove[iter258];
          output.writeString(iter258);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.linkToRemove !== null && this.linkToRemove !== undefined) {
      output.writeFieldBegin('linkToRemove', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.linkToRemove.length);
      for (let iter259 in this.linkToRemove) {
        if (this.linkToRemove.hasOwnProperty(iter259)) {
          iter259 = this.linkToRemove[iter259];
          output.writeString(iter259);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternService_createOrUpdateStagesAndLinksEx_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PatternData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PatternData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternService_createOrUpdateStagesAndLinksEx_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllDocumentPatterns (token, filter, withCurrentDocNumber) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatterns(token, filter, withCurrentDocNumber, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatterns (token, filter, withCurrentDocNumber, callback) {
    const params = {
      token: token,
      filter: filter,
      withCurrentDocNumber: withCurrentDocNumber
    };
    const args = new DocumentPatternService_getAllDocumentPatterns_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatterns', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatterns();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatterns () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatterns_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatterns failed: unknown result';
  }

  getAllDocumentPatternsGroupByName (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternsGroupByName(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternsGroupByName (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDocumentPatternsGroupByName_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternsGroupByName', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternsGroupByName();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternsGroupByName () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternsGroupByName_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternsGroupByName failed: unknown result';
  }

  getDocumentPattern (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentPattern(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentPattern (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new DocumentPatternService_getDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('getDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentPattern failed: unknown result';
  }

  deleteDocumentPattern (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentPattern(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentPattern (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new DocumentPatternService_deleteDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentPattern failed: unknown result';
  }

  createOrUpdateDocumentPattern (token, documentPattern, accountId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentPattern(token, documentPattern, accountId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentPattern (token, documentPattern, accountId, callback) {
    const params = {
      token: token,
      documentPattern: documentPattern,
      accountId: accountId
    };
    const args = new DocumentPatternService_createOrUpdateDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentPattern failed: unknown result';
  }

  exportPatternAsDocumentDraftXML (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportPatternAsDocumentDraftXML(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportPatternAsDocumentDraftXML (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new DocumentPatternService_exportPatternAsDocumentDraftXML_args(params);
    try {
      this.output.writeMessageBegin('exportPatternAsDocumentDraftXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportPatternAsDocumentDraftXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportPatternAsDocumentDraftXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_exportPatternAsDocumentDraftXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportPatternAsDocumentDraftXML failed: unknown result';
  }

  getAllDocumentPatternStages (token, docPatternId, filter, selector) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternStages(token, docPatternId, filter, selector, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternStages (token, docPatternId, filter, selector, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter,
      selector: selector
    };
    const args = new DocumentPatternService_getAllDocumentPatternStages_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternStages failed: unknown result';
  }

  getDocumentPatternStage (token, docPatternStageId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentPatternStage(token, docPatternStageId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentPatternStage (token, docPatternStageId, callback) {
    const params = {
      token: token,
      docPatternStageId: docPatternStageId
    };
    const args = new DocumentPatternService_getDocumentPatternStage_args(params);
    try {
      this.output.writeMessageBegin('getDocumentPatternStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentPatternStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentPatternStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getDocumentPatternStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentPatternStage failed: unknown result';
  }

  deleteDocumentPatternStageAndMoveDocuments (token, docPatternStageId, newDocPatternStageId, fillDocPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentPatternStageAndMoveDocuments(token, docPatternStageId, newDocPatternStageId, fillDocPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentPatternStageAndMoveDocuments (token, docPatternStageId, newDocPatternStageId, fillDocPatternId, callback) {
    const params = {
      token: token,
      docPatternStageId: docPatternStageId,
      newDocPatternStageId: newDocPatternStageId,
      fillDocPatternId: fillDocPatternId
    };
    const args = new DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentPatternStageAndMoveDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentPatternStageAndMoveDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentPatternStageAndMoveDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteDocumentPatternStageAndMoveDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentPatternStageAndMoveDocuments failed: unknown result';
  }

  createOrUpdateStagesAndLinks (token, patternId, stages, links) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateStagesAndLinks(token, patternId, stages, links, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateStagesAndLinks (token, patternId, stages, links, callback) {
    const params = {
      token: token,
      patternId: patternId,
      stages: stages,
      links: links
    };
    const args = new DocumentPatternService_createOrUpdateStagesAndLinks_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateStagesAndLinks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateStagesAndLinks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateStagesAndLinks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateStagesAndLinks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateStagesAndLinks failed: unknown result';
  }

  getAllDocumentPatternStagesLinks (token, docPatternId, docPatternStageId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternStagesLinks(token, docPatternId, docPatternStageId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternStagesLinks (token, docPatternId, docPatternStageId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      docPatternStageId: docPatternStageId,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDocumentPatternStagesLinks_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternStagesLinks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternStagesLinks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternStagesLinks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternStagesLinks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternStagesLinks failed: unknown result';
  }

  getDocumentPatternStageLink (token, docPatternStageLinkId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentPatternStageLink(token, docPatternStageLinkId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentPatternStageLink (token, docPatternStageLinkId, callback) {
    const params = {
      token: token,
      docPatternStageLinkId: docPatternStageLinkId
    };
    const args = new DocumentPatternService_getDocumentPatternStageLink_args(params);
    try {
      this.output.writeMessageBegin('getDocumentPatternStageLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentPatternStageLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentPatternStageLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getDocumentPatternStageLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentPatternStageLink failed: unknown result';
  }

  createOrUpdateDocumentPatternStagesLink (token, documentPatternStagesLink) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentPatternStagesLink(token, documentPatternStagesLink, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentPatternStagesLink (token, documentPatternStagesLink, callback) {
    const params = {
      token: token,
      documentPatternStagesLink: documentPatternStagesLink
    };
    const args = new DocumentPatternService_createOrUpdateDocumentPatternStagesLink_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentPatternStagesLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentPatternStagesLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentPatternStagesLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateDocumentPatternStagesLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentPatternStagesLink failed: unknown result';
  }

  deleteDocumentPatternStageLink (token, docPatternStageLinkId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentPatternStageLink(token, docPatternStageLinkId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentPatternStageLink (token, docPatternStageLinkId, callback) {
    const params = {
      token: token,
      docPatternStageLinkId: docPatternStageLinkId
    };
    const args = new DocumentPatternService_deleteDocumentPatternStageLink_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentPatternStageLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentPatternStageLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentPatternStageLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteDocumentPatternStageLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentPatternStageLink failed: unknown result';
  }

  getAllDocumentPatternStageExecutors (token, docPatternStageId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternStageExecutors(token, docPatternStageId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternStageExecutors (token, docPatternStageId, filter, callback) {
    const params = {
      token: token,
      docPatternStageId: docPatternStageId,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDocumentPatternStageExecutors_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternStageExecutors', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternStageExecutors();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternStageExecutors () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternStageExecutors_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternStageExecutors failed: unknown result';
  }

  addExecutorsToDocumentPatternStage (token, docPatternStageId, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addExecutorsToDocumentPatternStage(token, docPatternStageId, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addExecutorsToDocumentPatternStage (token, docPatternStageId, userOrGroups, callback) {
    const params = {
      token: token,
      docPatternStageId: docPatternStageId,
      userOrGroups: userOrGroups
    };
    const args = new DocumentPatternService_addExecutorsToDocumentPatternStage_args(params);
    try {
      this.output.writeMessageBegin('addExecutorsToDocumentPatternStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addExecutorsToDocumentPatternStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addExecutorsToDocumentPatternStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_addExecutorsToDocumentPatternStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addExecutorsToDocumentPatternStage failed: unknown result';
  }

  deleteExecutorsFromDocumentPatternStage (token, docPatternStageId, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteExecutorsFromDocumentPatternStage(token, docPatternStageId, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteExecutorsFromDocumentPatternStage (token, docPatternStageId, userOrGroups, callback) {
    const params = {
      token: token,
      docPatternStageId: docPatternStageId,
      userOrGroups: userOrGroups
    };
    const args = new DocumentPatternService_deleteExecutorsFromDocumentPatternStage_args(params);
    try {
      this.output.writeMessageBegin('deleteExecutorsFromDocumentPatternStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteExecutorsFromDocumentPatternStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteExecutorsFromDocumentPatternStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteExecutorsFromDocumentPatternStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteExecutorsFromDocumentPatternStage failed: unknown result';
  }

  checkDocumentPattern (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_checkDocumentPattern(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_checkDocumentPattern (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new DocumentPatternService_checkDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('checkDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_checkDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_checkDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_checkDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'checkDocumentPattern failed: unknown result';
  }

  createOrUpdatePatternContentItems (token, docPatternId, contentItems) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdatePatternContentItems(token, docPatternId, contentItems, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdatePatternContentItems (token, docPatternId, contentItems, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      contentItems: contentItems
    };
    const args = new DocumentPatternService_createOrUpdatePatternContentItems_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdatePatternContentItems', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdatePatternContentItems();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdatePatternContentItems () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdatePatternContentItems_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdatePatternContentItems failed: unknown result';
  }

  deletePatternContentItem (token, docPatternId, contentItemKey) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deletePatternContentItem(token, docPatternId, contentItemKey, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deletePatternContentItem (token, docPatternId, contentItemKey, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      contentItemKey: contentItemKey
    };
    const args = new DocumentPatternService_deletePatternContentItem_args(params);
    try {
      this.output.writeMessageBegin('deletePatternContentItem', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deletePatternContentItem();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deletePatternContentItem () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deletePatternContentItem_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deletePatternContentItem failed: unknown result';
  }

  createOrUpdatePatternContentTab (token, docPatternId, patternContentTab) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdatePatternContentTab(token, docPatternId, patternContentTab, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdatePatternContentTab (token, docPatternId, patternContentTab, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      patternContentTab: patternContentTab
    };
    const args = new DocumentPatternService_createOrUpdatePatternContentTab_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdatePatternContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdatePatternContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdatePatternContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdatePatternContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdatePatternContentTab failed: unknown result';
  }

  getPatternContentTabsByFilter (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternContentTabsByFilter(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternContentTabsByFilter (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new DocumentPatternService_getPatternContentTabsByFilter_args(params);
    try {
      this.output.writeMessageBegin('getPatternContentTabsByFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternContentTabsByFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternContentTabsByFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternContentTabsByFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternContentTabsByFilter failed: unknown result';
  }

  deletePatternContentTab (token, patternContentTabId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deletePatternContentTab(token, patternContentTabId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deletePatternContentTab (token, patternContentTabId, callback) {
    const params = {
      token: token,
      patternContentTabId: patternContentTabId
    };
    const args = new DocumentPatternService_deletePatternContentTab_args(params);
    try {
      this.output.writeMessageBegin('deletePatternContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deletePatternContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deletePatternContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deletePatternContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deletePatternContentTab failed: unknown result';
  }

  getAllDocumentPatternGroups (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternGroups(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternGroups (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDocumentPatternGroups_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternGroups failed: unknown result';
  }

  getAllDocumentPatternGroupsGroupByName (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatternGroupsGroupByName(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatternGroupsGroupByName (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDocumentPatternGroupsGroupByName_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatternGroupsGroupByName', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatternGroupsGroupByName();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatternGroupsGroupByName () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDocumentPatternGroupsGroupByName_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatternGroupsGroupByName failed: unknown result';
  }

  createOrUpdateDocumentPatternGroup (token, documentPatternGroup, accountId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentPatternGroup(token, documentPatternGroup, accountId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentPatternGroup (token, documentPatternGroup, accountId, callback) {
    const params = {
      token: token,
      documentPatternGroup: documentPatternGroup,
      accountId: accountId
    };
    const args = new DocumentPatternService_createOrUpdateDocumentPatternGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentPatternGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentPatternGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentPatternGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateDocumentPatternGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentPatternGroup failed: unknown result';
  }

  deleteDocumentPatternGroup (token, documentPatternGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentPatternGroup(token, documentPatternGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentPatternGroup (token, documentPatternGroupId, callback) {
    const params = {
      token: token,
      documentPatternGroupId: documentPatternGroupId
    };
    const args = new DocumentPatternService_deleteDocumentPatternGroup_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentPatternGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentPatternGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentPatternGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteDocumentPatternGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentPatternGroup failed: unknown result';
  }

  getAllAvailableStages (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllAvailableStages(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllAvailableStages (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllAvailableStages_args(params);
    try {
      this.output.writeMessageBegin('getAllAvailableStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllAvailableStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllAvailableStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllAvailableStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllAvailableStages failed: unknown result';
  }

  getAvailableLinkAnswersByPattern (token, patternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAvailableLinkAnswersByPattern(token, patternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAvailableLinkAnswersByPattern (token, patternId, callback) {
    const params = {
      token: token,
      patternId: patternId
    };
    const args = new DocumentPatternService_getAvailableLinkAnswersByPattern_args(params);
    try {
      this.output.writeMessageBegin('getAvailableLinkAnswersByPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAvailableLinkAnswersByPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAvailableLinkAnswersByPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAvailableLinkAnswersByPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAvailableLinkAnswersByPattern failed: unknown result';
  }

  removeAvailableStage (token, availStageId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeAvailableStage(token, availStageId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeAvailableStage (token, availStageId, callback) {
    const params = {
      token: token,
      availStageId: availStageId
    };
    const args = new DocumentPatternService_removeAvailableStage_args(params);
    try {
      this.output.writeMessageBegin('removeAvailableStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeAvailableStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeAvailableStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_removeAvailableStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeAvailableStage failed: unknown result';
  }

  getAllDigitalViews (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDigitalViews(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDigitalViews (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new DocumentPatternService_getAllDigitalViews_args(params);
    try {
      this.output.writeMessageBegin('getAllDigitalViews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDigitalViews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDigitalViews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllDigitalViews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDigitalViews failed: unknown result';
  }

  createOrUpdateDigitalView (token, digitalView) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDigitalView(token, digitalView, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDigitalView (token, digitalView, callback) {
    const params = {
      token: token,
      digitalView: digitalView
    };
    const args = new DocumentPatternService_createOrUpdateDigitalView_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDigitalView', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDigitalView();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDigitalView () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateDigitalView_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDigitalView failed: unknown result';
  }

  deleteDigitalView (token, digitalViewId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDigitalView(token, digitalViewId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDigitalView (token, digitalViewId, callback) {
    const params = {
      token: token,
      digitalViewId: digitalViewId
    };
    const args = new DocumentPatternService_deleteDigitalView_args(params);
    try {
      this.output.writeMessageBegin('deleteDigitalView', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDigitalView();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDigitalView () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_deleteDigitalView_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDigitalView failed: unknown result';
  }

  exportDocumentPattern (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportDocumentPattern(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportDocumentPattern (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new DocumentPatternService_exportDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('exportDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_exportDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportDocumentPattern failed: unknown result';
  }

  importDocumentPattern (token, json, docPatternName, pDescription, docPatternGroupId, accountId, ignoreError) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_importDocumentPattern(token, json, docPatternName, pDescription, docPatternGroupId, accountId, ignoreError, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_importDocumentPattern (token, json, docPatternName, pDescription, docPatternGroupId, accountId, ignoreError, callback) {
    const params = {
      token: token,
      json: json,
      docPatternName: docPatternName,
      pDescription: pDescription,
      docPatternGroupId: docPatternGroupId,
      accountId: accountId,
      ignoreError: ignoreError
    };
    const args = new DocumentPatternService_importDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('importDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_importDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_importDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_importDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'importDocumentPattern failed: unknown result';
  }

  getPatternUserGroup (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternUserGroup(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternUserGroup (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new DocumentPatternService_getPatternUserGroup_args(params);
    try {
      this.output.writeMessageBegin('getPatternUserGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternUserGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternUserGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternUserGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternUserGroup failed: unknown result';
  }

  createOrUpdatePatternUserGroup (token, docPatternId, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdatePatternUserGroup(token, docPatternId, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdatePatternUserGroup (token, docPatternId, userOrGroups, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      userOrGroups: userOrGroups
    };
    const args = new DocumentPatternService_createOrUpdatePatternUserGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdatePatternUserGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdatePatternUserGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdatePatternUserGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdatePatternUserGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdatePatternUserGroup failed: unknown result';
  }

  getPatternProcessRoles (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternProcessRoles(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternProcessRoles (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new DocumentPatternService_getPatternProcessRoles_args(params);
    try {
      this.output.writeMessageBegin('getPatternProcessRoles', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternProcessRoles();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternProcessRoles () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternProcessRoles_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternProcessRoles failed: unknown result';
  }

  changePatternProcessRoles (token, docPatternId, userOrGroupsToAdd, keyIdToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changePatternProcessRoles(token, docPatternId, userOrGroupsToAdd, keyIdToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changePatternProcessRoles (token, docPatternId, userOrGroupsToAdd, keyIdToRemove, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      userOrGroupsToAdd: userOrGroupsToAdd,
      keyIdToRemove: keyIdToRemove
    };
    const args = new DocumentPatternService_changePatternProcessRoles_args(params);
    try {
      this.output.writeMessageBegin('changePatternProcessRoles', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changePatternProcessRoles();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changePatternProcessRoles () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_changePatternProcessRoles_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changePatternProcessRoles failed: unknown result';
  }

  getPatternVariables (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternVariables(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternVariables (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new DocumentPatternService_getPatternVariables_args(params);
    try {
      this.output.writeMessageBegin('getPatternVariables', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternVariables();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternVariables () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternVariables_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternVariables failed: unknown result';
  }

  changePatternVariables (token, docPatternId, patternVariablesToAdd, keyIdToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changePatternVariables(token, docPatternId, patternVariablesToAdd, keyIdToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changePatternVariables (token, docPatternId, patternVariablesToAdd, keyIdToRemove, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      patternVariablesToAdd: patternVariablesToAdd,
      keyIdToRemove: keyIdToRemove
    };
    const args = new DocumentPatternService_changePatternVariables_args(params);
    try {
      this.output.writeMessageBegin('changePatternVariables', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changePatternVariables();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changePatternVariables () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_changePatternVariables_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changePatternVariables failed: unknown result';
  }

  addAvailablePatternStageToAccounts (token, availablePatternStageId, accountIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAvailablePatternStageToAccounts(token, availablePatternStageId, accountIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAvailablePatternStageToAccounts (token, availablePatternStageId, accountIds, callback) {
    const params = {
      token: token,
      availablePatternStageId: availablePatternStageId,
      accountIds: accountIds
    };
    const args = new DocumentPatternService_addAvailablePatternStageToAccounts_args(params);
    try {
      this.output.writeMessageBegin('addAvailablePatternStageToAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAvailablePatternStageToAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAvailablePatternStageToAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_addAvailablePatternStageToAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAvailablePatternStageToAccounts failed: unknown result';
  }

  getAllPatternAttachmentTemplates (token, patternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllPatternAttachmentTemplates(token, patternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllPatternAttachmentTemplates (token, patternId, filter, callback) {
    const params = {
      token: token,
      patternId: patternId,
      filter: filter
    };
    const args = new DocumentPatternService_getAllPatternAttachmentTemplates_args(params);
    try {
      this.output.writeMessageBegin('getAllPatternAttachmentTemplates', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllPatternAttachmentTemplates();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllPatternAttachmentTemplates () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllPatternAttachmentTemplates_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllPatternAttachmentTemplates failed: unknown result';
  }

  getPatternAttachmentTemplateById (token, patternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternAttachmentTemplateById(token, patternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternAttachmentTemplateById (token, patternId, callback) {
    const params = {
      token: token,
      patternId: patternId
    };
    const args = new DocumentPatternService_getPatternAttachmentTemplateById_args(params);
    try {
      this.output.writeMessageBegin('getPatternAttachmentTemplateById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternAttachmentTemplateById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternAttachmentTemplateById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternAttachmentTemplateById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternAttachmentTemplateById failed: unknown result';
  }

  createOrUpdatePatternAttachmentTemplate (token, patternAttachmentTemplate, xmlFile) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdatePatternAttachmentTemplate(token, patternAttachmentTemplate, xmlFile, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdatePatternAttachmentTemplate (token, patternAttachmentTemplate, xmlFile, callback) {
    const params = {
      token: token,
      patternAttachmentTemplate: patternAttachmentTemplate,
      xmlFile: xmlFile
    };
    const args = new DocumentPatternService_createOrUpdatePatternAttachmentTemplate_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdatePatternAttachmentTemplate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdatePatternAttachmentTemplate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdatePatternAttachmentTemplate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdatePatternAttachmentTemplate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdatePatternAttachmentTemplate failed: unknown result';
  }

  downloadPatternAttachmentTemplate (token, patternAttachmentTemplateId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_downloadPatternAttachmentTemplate(token, patternAttachmentTemplateId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_downloadPatternAttachmentTemplate (token, patternAttachmentTemplateId, callback) {
    const params = {
      token: token,
      patternAttachmentTemplateId: patternAttachmentTemplateId
    };
    const args = new DocumentPatternService_downloadPatternAttachmentTemplate_args(params);
    try {
      this.output.writeMessageBegin('downloadPatternAttachmentTemplate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_downloadPatternAttachmentTemplate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_downloadPatternAttachmentTemplate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_downloadPatternAttachmentTemplate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'downloadPatternAttachmentTemplate failed: unknown result';
  }

  removePatternAttachmentTemplate (token, patternAttachmentTemplateId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removePatternAttachmentTemplate(token, patternAttachmentTemplateId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removePatternAttachmentTemplate (token, patternAttachmentTemplateId, callback) {
    const params = {
      token: token,
      patternAttachmentTemplateId: patternAttachmentTemplateId
    };
    const args = new DocumentPatternService_removePatternAttachmentTemplate_args(params);
    try {
      this.output.writeMessageBegin('removePatternAttachmentTemplate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removePatternAttachmentTemplate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removePatternAttachmentTemplate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_removePatternAttachmentTemplate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removePatternAttachmentTemplate failed: unknown result';
  }

  changeStartDocNumberSequence (token, patternId, value) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeStartDocNumberSequence(token, patternId, value, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeStartDocNumberSequence (token, patternId, value, callback) {
    const params = {
      token: token,
      patternId: patternId,
      value: value
    };
    const args = new DocumentPatternService_changeStartDocNumberSequence_args(params);
    try {
      this.output.writeMessageBegin('changeStartDocNumberSequence', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeStartDocNumberSequence();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeStartDocNumberSequence () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_changeStartDocNumberSequence_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeStartDocNumberSequence failed: unknown result';
  }

  getAllContentHolders (token, patternId, withContent, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllContentHolders(token, patternId, withContent, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllContentHolders (token, patternId, withContent, filter, callback) {
    const params = {
      token: token,
      patternId: patternId,
      withContent: withContent,
      filter: filter
    };
    const args = new DocumentPatternService_getAllContentHolders_args(params);
    try {
      this.output.writeMessageBegin('getAllContentHolders', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllContentHolders();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllContentHolders () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllContentHolders_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllContentHolders failed: unknown result';
  }

  changeContentHolders (token, toUpdate, toRemoveIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeContentHolders(token, toUpdate, toRemoveIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeContentHolders (token, toUpdate, toRemoveIds, callback) {
    const params = {
      token: token,
      toUpdate: toUpdate,
      toRemoveIds: toRemoveIds
    };
    const args = new DocumentPatternService_changeContentHolders_args(params);
    try {
      this.output.writeMessageBegin('changeContentHolders', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeContentHolders();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeContentHolders () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_changeContentHolders_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeContentHolders failed: unknown result';
  }

  getPatternRelationModel (token, patternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternRelationModel(token, patternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternRelationModel (token, patternId, filter, callback) {
    const params = {
      token: token,
      patternId: patternId,
      filter: filter
    };
    const args = new DocumentPatternService_getPatternRelationModel_args(params);
    try {
      this.output.writeMessageBegin('getPatternRelationModel', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternRelationModel();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternRelationModel () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternRelationModel_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternRelationModel failed: unknown result';
  }

  getNomenclatureNumber (token, nomenclatureNumberId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNomenclatureNumber(token, nomenclatureNumberId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNomenclatureNumber (token, nomenclatureNumberId, callback) {
    const params = {
      token: token,
      nomenclatureNumberId: nomenclatureNumberId
    };
    const args = new DocumentPatternService_getNomenclatureNumber_args(params);
    try {
      this.output.writeMessageBegin('getNomenclatureNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNomenclatureNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNomenclatureNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getNomenclatureNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNomenclatureNumber failed: unknown result';
  }

  getAllNomenclatureNumber (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNomenclatureNumber(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNomenclatureNumber (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllNomenclatureNumber_args(params);
    try {
      this.output.writeMessageBegin('getAllNomenclatureNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNomenclatureNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNomenclatureNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllNomenclatureNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNomenclatureNumber failed: unknown result';
  }

  getCountAllNomenclatureNumber (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllNomenclatureNumber(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllNomenclatureNumber (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getCountAllNomenclatureNumber_args(params);
    try {
      this.output.writeMessageBegin('getCountAllNomenclatureNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllNomenclatureNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllNomenclatureNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getCountAllNomenclatureNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllNomenclatureNumber failed: unknown result';
  }

  createOrUpdateNomenclatureNumber (token, nomenclatureNumber) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateNomenclatureNumber(token, nomenclatureNumber, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateNomenclatureNumber (token, nomenclatureNumber, callback) {
    const params = {
      token: token,
      nomenclatureNumber: nomenclatureNumber
    };
    const args = new DocumentPatternService_createOrUpdateNomenclatureNumber_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateNomenclatureNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateNomenclatureNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateNomenclatureNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateNomenclatureNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateNomenclatureNumber failed: unknown result';
  }

  removeNomenclatureNumber (token, nomenclatureNumberId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeNomenclatureNumber(token, nomenclatureNumberId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeNomenclatureNumber (token, nomenclatureNumberId, callback) {
    const params = {
      token: token,
      nomenclatureNumberId: nomenclatureNumberId
    };
    const args = new DocumentPatternService_removeNomenclatureNumber_args(params);
    try {
      this.output.writeMessageBegin('removeNomenclatureNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeNomenclatureNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeNomenclatureNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_removeNomenclatureNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeNomenclatureNumber failed: unknown result';
  }

  getNomenclatureGroup (token, nomenclatureGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNomenclatureGroup(token, nomenclatureGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNomenclatureGroup (token, nomenclatureGroupId, callback) {
    const params = {
      token: token,
      nomenclatureGroupId: nomenclatureGroupId
    };
    const args = new DocumentPatternService_getNomenclatureGroup_args(params);
    try {
      this.output.writeMessageBegin('getNomenclatureGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNomenclatureGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNomenclatureGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getNomenclatureGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNomenclatureGroup failed: unknown result';
  }

  getAllNomenclatureGroup (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNomenclatureGroup(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNomenclatureGroup (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getAllNomenclatureGroup_args(params);
    try {
      this.output.writeMessageBegin('getAllNomenclatureGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNomenclatureGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNomenclatureGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getAllNomenclatureGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNomenclatureGroup failed: unknown result';
  }

  getCountAllNomenclatureGroup (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllNomenclatureGroup(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllNomenclatureGroup (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentPatternService_getCountAllNomenclatureGroup_args(params);
    try {
      this.output.writeMessageBegin('getCountAllNomenclatureGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllNomenclatureGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllNomenclatureGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getCountAllNomenclatureGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllNomenclatureGroup failed: unknown result';
  }

  createOrUpdateNomenclatureGroup (token, nomenclatureGroup) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateNomenclatureGroup(token, nomenclatureGroup, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateNomenclatureGroup (token, nomenclatureGroup, callback) {
    const params = {
      token: token,
      nomenclatureGroup: nomenclatureGroup
    };
    const args = new DocumentPatternService_createOrUpdateNomenclatureGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateNomenclatureGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateNomenclatureGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateNomenclatureGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateNomenclatureGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateNomenclatureGroup failed: unknown result';
  }

  removeNomenclatureGroup (token, nomenclatureGrouprId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeNomenclatureGroup(token, nomenclatureGrouprId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeNomenclatureGroup (token, nomenclatureGrouprId, callback) {
    const params = {
      token: token,
      nomenclatureGrouprId: nomenclatureGrouprId
    };
    const args = new DocumentPatternService_removeNomenclatureGroup_args(params);
    try {
      this.output.writeMessageBegin('removeNomenclatureGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeNomenclatureGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeNomenclatureGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_removeNomenclatureGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeNomenclatureGroup failed: unknown result';
  }

  getInfoForCreateDoc (token, patternId, parentDocId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getInfoForCreateDoc(token, patternId, parentDocId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getInfoForCreateDoc (token, patternId, parentDocId, accessPolicy, callback) {
    const params = {
      token: token,
      patternId: patternId,
      parentDocId: parentDocId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentPatternService_getInfoForCreateDoc_args(params);
    try {
      this.output.writeMessageBegin('getInfoForCreateDoc', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getInfoForCreateDoc();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getInfoForCreateDoc () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getInfoForCreateDoc_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getInfoForCreateDoc failed: unknown result';
  }

  getPatternContentItems (token, patternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getPatternContentItems(token, patternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getPatternContentItems (token, patternId, callback) {
    const params = {
      token: token,
      patternId: patternId
    };
    const args = new DocumentPatternService_getPatternContentItems_args(params);
    try {
      this.output.writeMessageBegin('getPatternContentItems', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getPatternContentItems();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getPatternContentItems () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_getPatternContentItems_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getPatternContentItems failed: unknown result';
  }

  createOrUpdateStagesAndLinksEx (token, patternId, stages, links, stageToRemove, linkToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateStagesAndLinksEx(token, patternId, stages, links, stageToRemove, linkToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateStagesAndLinksEx (token, patternId, stages, links, stageToRemove, linkToRemove, callback) {
    const params = {
      token: token,
      patternId: patternId,
      stages: stages,
      links: links,
      stageToRemove: stageToRemove,
      linkToRemove: linkToRemove
    };
    const args = new DocumentPatternService_createOrUpdateStagesAndLinksEx_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateStagesAndLinksEx', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateStagesAndLinksEx();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateStagesAndLinksEx () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentPatternService_createOrUpdateStagesAndLinksEx_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateStagesAndLinksEx failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DocumentService_calculatePermissions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_calculatePermissions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocPermissions(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocPermissions();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    this.addedResponsibles = null;
    this.removedResponsibles = null;
    this.addedSecurityClassificationIds = null;
    this.removedSecurityClassificationIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.addedResponsibles !== undefined && args.addedResponsibles !== null) {
        this.addedResponsibles = Thrift.copyList(args.addedResponsibles, [UserOrGroup]);
      }
      if (args.removedResponsibles !== undefined && args.removedResponsibles !== null) {
        this.removedResponsibles = Thrift.copyList(args.removedResponsibles, [UserOrGroup]);
      }
      if (args.addedSecurityClassificationIds !== undefined && args.addedSecurityClassificationIds !== null) {
        this.addedSecurityClassificationIds = Thrift.copyList(args.addedSecurityClassificationIds, [null]);
      }
      if (args.removedSecurityClassificationIds !== undefined && args.removedSecurityClassificationIds !== null) {
        this.removedSecurityClassificationIds = Thrift.copyList(args.removedSecurityClassificationIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.addedResponsibles = [];
          const _rtmp3285 = input.readListBegin();
          const _size284 = _rtmp3285.size || 0;
          for (let _i286 = 0; _i286 < _size284; ++_i286) {
            let elem287 = null;
            elem287 = new UserOrGroup();
            elem287.read(input);
            this.addedResponsibles.push(elem287);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.removedResponsibles = [];
          const _rtmp3289 = input.readListBegin();
          const _size288 = _rtmp3289.size || 0;
          for (let _i290 = 0; _i290 < _size288; ++_i290) {
            let elem291 = null;
            elem291 = new UserOrGroup();
            elem291.read(input);
            this.removedResponsibles.push(elem291);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.addedSecurityClassificationIds = [];
          const _rtmp3293 = input.readListBegin();
          const _size292 = _rtmp3293.size || 0;
          for (let _i294 = 0; _i294 < _size292; ++_i294) {
            let elem295 = null;
            elem295 = input.readString().value;
            this.addedSecurityClassificationIds.push(elem295);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.removedSecurityClassificationIds = [];
          const _rtmp3297 = input.readListBegin();
          const _size296 = _rtmp3297.size || 0;
          for (let _i298 = 0; _i298 < _size296; ++_i298) {
            let elem299 = null;
            elem299 = input.readString().value;
            this.removedSecurityClassificationIds.push(elem299);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.addedResponsibles !== null && this.addedResponsibles !== undefined) {
      output.writeFieldBegin('addedResponsibles', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.addedResponsibles.length);
      for (let iter300 in this.addedResponsibles) {
        if (this.addedResponsibles.hasOwnProperty(iter300)) {
          iter300 = this.addedResponsibles[iter300];
          iter300.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedResponsibles !== null && this.removedResponsibles !== undefined) {
      output.writeFieldBegin('removedResponsibles', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.removedResponsibles.length);
      for (let iter301 in this.removedResponsibles) {
        if (this.removedResponsibles.hasOwnProperty(iter301)) {
          iter301 = this.removedResponsibles[iter301];
          iter301.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.addedSecurityClassificationIds !== null && this.addedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('addedSecurityClassificationIds', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.addedSecurityClassificationIds.length);
      for (let iter302 in this.addedSecurityClassificationIds) {
        if (this.addedSecurityClassificationIds.hasOwnProperty(iter302)) {
          iter302 = this.addedSecurityClassificationIds[iter302];
          output.writeString(iter302);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedSecurityClassificationIds !== null && this.removedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('removedSecurityClassificationIds', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.removedSecurityClassificationIds.length);
      for (let iter303 in this.removedSecurityClassificationIds) {
        if (this.removedSecurityClassificationIds.hasOwnProperty(iter303)) {
          iter303 = this.removedSecurityClassificationIds[iter303];
          output.writeString(iter303);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.users = null;
    this.holderLinks = null;
    this.securityClassificationsId = null;
    this.attachments = null;
    this.docRelations = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.docRelations !== undefined && args.docRelations !== null) {
        this.docRelations = Thrift.copyList(args.docRelations, [DocumentRelation]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3305 = input.readListBegin();
          const _size304 = _rtmp3305.size || 0;
          for (let _i306 = 0; _i306 < _size304; ++_i306) {
            let elem307 = null;
            elem307 = new UserOrGroup();
            elem307.read(input);
            this.users.push(elem307);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3309 = input.readListBegin();
          const _size308 = _rtmp3309.size || 0;
          for (let _i310 = 0; _i310 < _size308; ++_i310) {
            let elem311 = null;
            elem311 = new ContentHolderLink();
            elem311.read(input);
            this.holderLinks.push(elem311);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.securityClassificationsId = [];
          const _rtmp3313 = input.readSetBegin();
          const _size312 = _rtmp3313.size || 0;
          for (let _i314 = 0; _i314 < _size312; ++_i314) {
            let elem315 = null;
            elem315 = input.readString().value;
            this.securityClassificationsId.push(elem315);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3317 = input.readListBegin();
          const _size316 = _rtmp3317.size || 0;
          for (let _i318 = 0; _i318 < _size316; ++_i318) {
            let elem319 = null;
            elem319 = new AttCreateInfo();
            elem319.read(input);
            this.attachments.push(elem319);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.docRelations = [];
          const _rtmp3321 = input.readListBegin();
          const _size320 = _rtmp3321.size || 0;
          for (let _i322 = 0; _i322 < _size320; ++_i322) {
            let elem323 = null;
            elem323 = new DocumentRelation();
            elem323.read(input);
            this.docRelations.push(elem323);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter324 in this.users) {
        if (this.users.hasOwnProperty(iter324)) {
          iter324 = this.users[iter324];
          iter324.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter325 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter325)) {
          iter325 = this.holderLinks[iter325];
          iter325.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter326 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter326)) {
          iter326 = this.securityClassificationsId[iter326];
          output.writeString(iter326);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter327 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter327)) {
          iter327 = this.attachments[iter327];
          iter327.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docRelations !== null && this.docRelations !== undefined) {
      output.writeFieldBegin('docRelations', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelations.length);
      for (let iter328 in this.docRelations) {
        if (this.docRelations.hasOwnProperty(iter328)) {
          iter328 = this.docRelations[iter328];
          iter328.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xmlDoc = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xmlDoc !== undefined && args.xmlDoc !== null) {
        this.xmlDoc = args.xmlDoc;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xmlDoc = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xmlDoc !== null && this.xmlDoc !== undefined) {
      output.writeFieldBegin('xmlDoc', Thrift.Type.STRING, 2);
      output.writeBinary(this.xmlDoc);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.decrypt = null;
    this.executorsPortion = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.decrypt !== undefined && args.decrypt !== null) {
        this.decrypt = args.decrypt;
      }
      if (args.executorsPortion !== undefined && args.executorsPortion !== null) {
        this.executorsPortion = args.executorsPortion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.decrypt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.executorsPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.decrypt !== null && this.decrypt !== undefined) {
      output.writeFieldBegin('decrypt', Thrift.Type.BOOL, 4);
      output.writeBool(this.decrypt);
      output.writeFieldEnd();
    }
    if (this.executorsPortion !== null && this.executorsPortion !== undefined) {
      output.writeFieldBegin('executorsPortion', Thrift.Type.I32, 5);
      output.writeI32(this.executorsPortion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3330 = input.readListBegin();
          const _size329 = _rtmp3330.size || 0;
          for (let _i331 = 0; _i331 < _size329; ++_i331) {
            let elem332 = null;
            elem332 = new Document();
            elem332.read(input);
            this.success.push(elem332);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter333 in this.success) {
        if (this.success.hasOwnProperty(iter333)) {
          iter333 = this.success[iter333];
          iter333.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PassedStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3335 = input.readListBegin();
          const _size334 = _rtmp3335.size || 0;
          for (let _i336 = 0; _i336 < _size334; ++_i336) {
            let elem337 = null;
            elem337 = new PassedStage();
            elem337.read(input);
            this.success.push(elem337);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter338 in this.success) {
        if (this.success.hasOwnProperty(iter338)) {
          iter338 = this.success[iter338];
          iter338.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.iteration = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 4);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ExecutionTree]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3340 = input.readListBegin();
          const _size339 = _rtmp3340.size || 0;
          for (let _i341 = 0; _i341 < _size339; ++_i341) {
            let elem342 = null;
            elem342 = new ExecutionTree();
            elem342.read(input);
            this.success.push(elem342);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter343 in this.success) {
        if (this.success.hasOwnProperty(iter343)) {
          iter343 = this.success[iter343];
          iter343.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3345 = input.readListBegin();
          const _size344 = _rtmp3345.size || 0;
          for (let _i346 = 0; _i346 < _size344; ++_i346) {
            let elem347 = null;
            elem347 = new DocumentPatternStage();
            elem347.read(input);
            this.success.push(elem347);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter348 in this.success) {
        if (this.success.hasOwnProperty(iter348)) {
          iter348 = this.success[iter348];
          iter348.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3350 = input.readMapBegin();
          const _size349 = _rtmp3350.size || 0;
          for (let _i351 = 0; _i351 < _size349; ++_i351) {
            if (_i351 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key352 = null;
            let val353 = null;
            key352 = input.readString().value;
            val353 = input.readI32().value;
            this.success[key352] = val353;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter354 in this.success) {
        if (this.success.hasOwnProperty(kiter354)) {
          let viter355 = this.success[kiter354];
          output.writeString(kiter354);
          output.writeI32(viter355);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.signature = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3357 = input.readListBegin();
          const _size356 = _rtmp3357.size || 0;
          for (let _i358 = 0; _i358 < _size356; ++_i358) {
            let elem359 = null;
            elem359 = new AttCreateInfo();
            elem359.read(input);
            this.attachments.push(elem359);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3361 = input.readListBegin();
          const _size360 = _rtmp3361.size || 0;
          for (let _i362 = 0; _i362 < _size360; ++_i362) {
            let elem363 = null;
            elem363 = new ContentHolderLink();
            elem363.read(input);
            this.holderLinks.push(elem363);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 7);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter364 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter364)) {
          iter364 = this.attachments[iter364];
          iter364.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter365 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter365)) {
          iter365 = this.holderLinks[iter365];
          iter365.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 10);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.pKeyId = null;
    this.password = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3367 = input.readListBegin();
          const _size366 = _rtmp3367.size || 0;
          for (let _i368 = 0; _i368 < _size366; ++_i368) {
            let elem369 = null;
            elem369 = new AttCreateInfo();
            elem369.read(input);
            this.attachments.push(elem369);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3371 = input.readListBegin();
          const _size370 = _rtmp3371.size || 0;
          for (let _i372 = 0; _i372 < _size370; ++_i372) {
            let elem373 = null;
            elem373 = new ContentHolderLink();
            elem373.read(input);
            this.holderLinks.push(elem373);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 6);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 7);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 8);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter374 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter374)) {
          iter374 = this.attachments[iter374];
          iter374.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter375 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter375)) {
          iter375 = this.holderLinks[iter375];
          iter375.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 11);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.executionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.executionId !== undefined && args.executionId !== null) {
        this.executionId = args.executionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.executionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.executionId !== null && this.executionId !== undefined) {
      output.writeFieldBegin('executionId', Thrift.Type.STRING, 2);
      output.writeString(this.executionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.usersOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3377 = input.readListBegin();
          const _size376 = _rtmp3377.size || 0;
          for (let _i378 = 0; _i378 < _size376; ++_i378) {
            let elem379 = null;
            elem379 = new UserOrGroup();
            elem379.read(input);
            this.usersOrGroups.push(elem379);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter380 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter380)) {
          iter380 = this.usersOrGroups[iter380];
          iter380.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3382 = input.readListBegin();
          const _size381 = _rtmp3382.size || 0;
          for (let _i383 = 0; _i383 < _size381; ++_i383) {
            let elem384 = null;
            elem384 = new DocumentExecution();
            elem384.read(input);
            this.success.push(elem384);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter385 in this.success) {
        if (this.success.hasOwnProperty(iter385)) {
          iter385 = this.success[iter385];
          iter385.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.usersOrGroups = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3387 = input.readListBegin();
          const _size386 = _rtmp3387.size || 0;
          for (let _i388 = 0; _i388 < _size386; ++_i388) {
            let elem389 = null;
            elem389 = new UserOrGroup();
            elem389.read(input);
            this.usersOrGroups.push(elem389);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter390 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter390)) {
          iter390 = this.usersOrGroups[iter390];
          iter390.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3392 = input.readListBegin();
          const _size391 = _rtmp3392.size || 0;
          for (let _i393 = 0; _i393 < _size391; ++_i393) {
            let elem394 = null;
            elem394 = new UserOrGroup();
            elem394.read(input);
            this.success.push(elem394);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter395 in this.success) {
        if (this.success.hasOwnProperty(iter395)) {
          iter395 = this.success[iter395];
          iter395.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentReassign]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3397 = input.readListBegin();
          const _size396 = _rtmp3397.size || 0;
          for (let _i398 = 0; _i398 < _size396; ++_i398) {
            let elem399 = null;
            elem399 = new DocumentReassign();
            elem399.read(input);
            this.success.push(elem399);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter400 in this.success) {
        if (this.success.hasOwnProperty(iter400)) {
          iter400 = this.success[iter400];
          iter400.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3402 = input.readListBegin();
          const _size401 = _rtmp3402.size || 0;
          for (let _i403 = 0; _i403 < _size401; ++_i403) {
            let elem404 = null;
            elem404 = new DocumentReassign();
            elem404.read(input);
            this.documentReassign.push(elem404);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter405 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter405)) {
          iter405 = this.documentReassign[iter405];
          iter405.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 5);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3407 = input.readListBegin();
          const _size406 = _rtmp3407.size || 0;
          for (let _i408 = 0; _i408 < _size406; ++_i408) {
            let elem409 = null;
            elem409 = new DocumentExecution();
            elem409.read(input);
            this.success.push(elem409);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter410 in this.success) {
        if (this.success.hasOwnProperty(iter410)) {
          iter410 = this.success[iter410];
          iter410.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.pKeyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3412 = input.readListBegin();
          const _size411 = _rtmp3412.size || 0;
          for (let _i413 = 0; _i413 < _size411; ++_i413) {
            let elem414 = null;
            elem414 = new DocumentReassign();
            elem414.read(input);
            this.documentReassign.push(elem414);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter415 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter415)) {
          iter415 = this.documentReassign[iter415];
          iter415.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 5);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 6);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3417 = input.readListBegin();
          const _size416 = _rtmp3417.size || 0;
          for (let _i418 = 0; _i418 < _size416; ++_i418) {
            let elem419 = null;
            elem419 = new DocumentExecution();
            elem419.read(input);
            this.success.push(elem419);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter420 in this.success) {
        if (this.success.hasOwnProperty(iter420)) {
          iter420 = this.success[iter420];
          iter420.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.deleteCard = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.deleteCard !== undefined && args.deleteCard !== null) {
        this.deleteCard = args.deleteCard;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.deleteCard = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.deleteCard !== null && this.deleteCard !== undefined) {
      output.writeFieldBegin('deleteCard', Thrift.Type.BOOL, 3);
      output.writeBool(this.deleteCard);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = new DocumentReassign(args.documentReassign);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentReassign = new DocumentReassign();
          this.documentReassign.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.STRUCT, 2);
      this.documentReassign.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentReassign(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentReassign();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassignId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassignId !== undefined && args.documentReassignId !== null) {
        this.documentReassignId = args.documentReassignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentReassignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassignId !== null && this.documentReassignId !== undefined) {
      output.writeFieldBegin('documentReassignId', Thrift.Type.STRING, 2);
      output.writeString(this.documentReassignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_args = class {
  constructor(args) {
    this.token = null;
    this.documentExecutionId = null;
    this.userId = null;
    this.reassignType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentExecutionId !== undefined && args.documentExecutionId !== null) {
        this.documentExecutionId = args.documentExecutionId;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentExecutionId !== null && this.documentExecutionId !== undefined) {
      output.writeFieldBegin('documentExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.documentExecutionId);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 3);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 4);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.typeLink = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.typeLink !== undefined && args.typeLink !== null) {
        this.typeLink = args.typeLink;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.typeLink = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.typeLink !== null && this.typeLink !== undefined) {
      output.writeFieldBegin('typeLink', Thrift.Type.I32, 4);
      output.writeI32(this.typeLink);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3422 = input.readListBegin();
          const _size421 = _rtmp3422.size || 0;
          for (let _i423 = 0; _i423 < _size421; ++_i423) {
            let elem424 = null;
            elem424 = new DocumentExecution();
            elem424.read(input);
            this.success.push(elem424);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter425 in this.success) {
        if (this.success.hasOwnProperty(iter425)) {
          iter425 = this.success[iter425];
          iter425.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.docExecutionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docExecutionId !== undefined && args.docExecutionId !== null) {
        this.docExecutionId = args.docExecutionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docExecutionId !== null && this.docExecutionId !== undefined) {
      output.writeFieldBegin('docExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.docExecutionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.toAdd = null;
    this.toClose = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentReassign]);
      }
      if (args.toClose !== undefined && args.toClose !== null) {
        this.toClose = Thrift.copyList(args.toClose, [null]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3427 = input.readListBegin();
          const _size426 = _rtmp3427.size || 0;
          for (let _i428 = 0; _i428 < _size426; ++_i428) {
            let elem429 = null;
            elem429 = new DocumentReassign();
            elem429.read(input);
            this.toAdd.push(elem429);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toClose = [];
          const _rtmp3431 = input.readListBegin();
          const _size430 = _rtmp3431.size || 0;
          for (let _i432 = 0; _i432 < _size430; ++_i432) {
            let elem433 = null;
            elem433 = input.readString().value;
            this.toClose.push(elem433);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter434 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter434)) {
          iter434 = this.toAdd[iter434];
          iter434.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toClose !== null && this.toClose !== undefined) {
      output.writeFieldBegin('toClose', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.toClose.length);
      for (let iter435 in this.toClose) {
        if (this.toClose.hasOwnProperty(iter435)) {
          iter435 = this.toClose[iter435];
          output.writeString(iter435);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    this.attCreateInfoList = null;
    this.processingType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.attCreateInfoList !== undefined && args.attCreateInfoList !== null) {
        this.attCreateInfoList = Thrift.copyList(args.attCreateInfoList, [AttCreateInfo]);
      }
      if (args.processingType !== undefined && args.processingType !== null) {
        this.processingType = args.processingType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.attCreateInfoList = [];
          const _rtmp3437 = input.readListBegin();
          const _size436 = _rtmp3437.size || 0;
          for (let _i438 = 0; _i438 < _size436; ++_i438) {
            let elem439 = null;
            elem439 = new AttCreateInfo();
            elem439.read(input);
            this.attCreateInfoList.push(elem439);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.processingType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.attCreateInfoList !== null && this.attCreateInfoList !== undefined) {
      output.writeFieldBegin('attCreateInfoList', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.attCreateInfoList.length);
      for (let iter440 in this.attCreateInfoList) {
        if (this.attCreateInfoList.hasOwnProperty(iter440)) {
          iter440 = this.attCreateInfoList[iter440];
          iter440.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.processingType !== null && this.processingType !== undefined) {
      output.writeFieldBegin('processingType', Thrift.Type.I32, 6);
      output.writeI32(this.processingType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3442 = input.readListBegin();
          const _size441 = _rtmp3442.size || 0;
          for (let _i443 = 0; _i443 < _size441; ++_i443) {
            let elem444 = null;
            elem444 = new Attachment();
            elem444.read(input);
            this.success.push(elem444);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter445 in this.success) {
        if (this.success.hasOwnProperty(iter445)) {
          iter445 = this.success[iter445];
          iter445.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.fileName = null;
    this.totalSize = null;
    this.countPortions = null;
    this.cardId = null;
    this.attachmmentId = null;
    this.forDraft = null;
    this.accessPolicy = null;
    this.editMode = null;
    this.meetingId = null;
    this.extStatus = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.totalSize !== undefined && args.totalSize !== null) {
        this.totalSize = args.totalSize;
      }
      if (args.countPortions !== undefined && args.countPortions !== null) {
        this.countPortions = args.countPortions;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachmmentId !== undefined && args.attachmmentId !== null) {
        this.attachmmentId = args.attachmmentId;
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.extStatus !== undefined && args.extStatus !== null) {
        this.extStatus = args.extStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.totalSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.countPortions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.attachmmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.extStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.totalSize !== null && this.totalSize !== undefined) {
      output.writeFieldBegin('totalSize', Thrift.Type.I64, 4);
      output.writeI64(this.totalSize);
      output.writeFieldEnd();
    }
    if (this.countPortions !== null && this.countPortions !== undefined) {
      output.writeFieldBegin('countPortions', Thrift.Type.I32, 5);
      output.writeI32(this.countPortions);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 6);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachmmentId !== null && this.attachmmentId !== undefined) {
      output.writeFieldBegin('attachmmentId', Thrift.Type.STRING, 7);
      output.writeString(this.attachmmentId);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 8);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 9);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 10);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 11);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.extStatus !== null && this.extStatus !== undefined) {
      output.writeFieldBegin('extStatus', Thrift.Type.I32, 12);
      output.writeI32(this.extStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.numberPortion = null;
    this.fileContentBytes = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.numberPortion !== undefined && args.numberPortion !== null) {
        this.numberPortion = args.numberPortion;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.numberPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.numberPortion !== null && this.numberPortion !== undefined) {
      output.writeFieldBegin('numberPortion', Thrift.Type.I32, 3);
      output.writeI32(this.numberPortion);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 4);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_writeHistoryOpenAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.attachmentType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentType !== undefined && args.attachmentType !== null) {
        this.attachmentType = args.attachmentType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.attachmentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_writeHistoryOpenAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentType !== null && this.attachmentType !== undefined) {
      output.writeFieldBegin('attachmentType', Thrift.Type.I32, 3);
      output.writeI32(this.attachmentType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_writeHistoryOpenAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_writeHistoryOpenAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.attachmentType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentType !== undefined && args.attachmentType !== null) {
        this.attachmentType = args.attachmentType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.attachmentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentType !== null && this.attachmentType !== undefined) {
      output.writeFieldBegin('attachmentType', Thrift.Type.I32, 3);
      output.writeI32(this.attachmentType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.pages = null;
    this.angle = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.pages !== undefined && args.pages !== null) {
        this.pages = args.pages;
      }
      if (args.angle !== undefined && args.angle !== null) {
        this.angle = args.angle;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pages = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.angle = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.pages !== null && this.pages !== undefined) {
      output.writeFieldBegin('pages', Thrift.Type.STRING, 3);
      output.writeString(this.pages);
      output.writeFieldEnd();
    }
    if (this.angle !== null && this.angle !== undefined) {
      output.writeFieldBegin('angle', Thrift.Type.I32, 4);
      output.writeI32(this.angle);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.attachments = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3447 = input.readListBegin();
          const _size446 = _rtmp3447.size || 0;
          for (let _i448 = 0; _i448 < _size446; ++_i448) {
            let elem449 = null;
            elem449 = new AttCreateInfo();
            elem449.read(input);
            this.attachments.push(elem449);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter450 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter450)) {
          iter450 = this.attachments[iter450];
          iter450.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.removeOldVersions = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.removeOldVersions !== undefined && args.removeOldVersions !== null) {
        this.removeOldVersions = args.removeOldVersions;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.removeOldVersions = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.removeOldVersions !== null && this.removeOldVersions !== undefined) {
      output.writeFieldBegin('removeOldVersions', Thrift.Type.BOOL, 3);
      output.writeBool(this.removeOldVersions);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.editMode = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 3);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.latestOnly = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.latestOnly !== undefined && args.latestOnly !== null) {
        this.latestOnly = args.latestOnly;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.latestOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.latestOnly !== null && this.latestOnly !== undefined) {
      output.writeFieldBegin('latestOnly', Thrift.Type.BOOL, 3);
      output.writeBool(this.latestOnly);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3452 = input.readListBegin();
          const _size451 = _rtmp3452.size || 0;
          for (let _i453 = 0; _i453 < _size451; ++_i453) {
            let elem454 = null;
            elem454 = new Attachment();
            elem454.read(input);
            this.success.push(elem454);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter455 in this.success) {
        if (this.success.hasOwnProperty(iter455)) {
          iter455 = this.success[iter455];
          iter455.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3457 = input.readListBegin();
          const _size456 = _rtmp3457.size || 0;
          for (let _i458 = 0; _i458 < _size456; ++_i458) {
            let elem459 = null;
            elem459 = new Attachment();
            elem459.read(input);
            this.success.push(elem459);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter460 in this.success) {
        if (this.success.hasOwnProperty(iter460)) {
          iter460 = this.success[iter460];
          iter460.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_args = class {
  constructor(args) {
    this.token = null;
    this.toHideList = null;
    this.toShowList = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toHideList !== undefined && args.toHideList !== null) {
        this.toHideList = Thrift.copyList(args.toHideList, [null]);
      }
      if (args.toShowList !== undefined && args.toShowList !== null) {
        this.toShowList = Thrift.copyList(args.toShowList, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toHideList = [];
          const _rtmp3462 = input.readListBegin();
          const _size461 = _rtmp3462.size || 0;
          for (let _i463 = 0; _i463 < _size461; ++_i463) {
            let elem464 = null;
            elem464 = input.readString().value;
            this.toHideList.push(elem464);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toShowList = [];
          const _rtmp3466 = input.readListBegin();
          const _size465 = _rtmp3466.size || 0;
          for (let _i467 = 0; _i467 < _size465; ++_i467) {
            let elem468 = null;
            elem468 = input.readString().value;
            this.toShowList.push(elem468);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toHideList !== null && this.toHideList !== undefined) {
      output.writeFieldBegin('toHideList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.toHideList.length);
      for (let iter469 in this.toHideList) {
        if (this.toHideList.hasOwnProperty(iter469)) {
          iter469 = this.toHideList[iter469];
          output.writeString(iter469);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toShowList !== null && this.toShowList !== undefined) {
      output.writeFieldBegin('toShowList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toShowList.length);
      for (let iter470 in this.toShowList) {
        if (this.toShowList.hasOwnProperty(iter470)) {
          iter470 = this.toShowList[iter470];
          output.writeString(iter470);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentComment = null;
    this.addToComment = null;
    this.changeType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = new DocumentComment(args.documentComment);
      }
      if (args.addToComment !== undefined && args.addToComment !== null) {
        this.addToComment = args.addToComment;
      }
      if (args.changeType !== undefined && args.changeType !== null) {
        this.changeType = args.changeType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentComment = new DocumentComment();
          this.documentComment.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.addToComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.changeType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRUCT, 2);
      this.documentComment.write(output);
      output.writeFieldEnd();
    }
    if (this.addToComment !== null && this.addToComment !== undefined) {
      output.writeFieldBegin('addToComment', Thrift.Type.STRING, 3);
      output.writeString(this.addToComment);
      output.writeFieldEnd();
    }
    if (this.changeType !== null && this.changeType !== undefined) {
      output.writeFieldBegin('changeType', Thrift.Type.I32, 4);
      output.writeI32(this.changeType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentComment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentComment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentComment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3472 = input.readListBegin();
          const _size471 = _rtmp3472.size || 0;
          for (let _i473 = 0; _i473 < _size471; ++_i473) {
            let elem474 = null;
            elem474 = new DocumentComment();
            elem474.read(input);
            this.success.push(elem474);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter475 in this.success) {
        if (this.success.hasOwnProperty(iter475)) {
          iter475 = this.success[iter475];
          iter475.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentCommentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentCommentId !== undefined && args.documentCommentId !== null) {
        this.documentCommentId = args.documentCommentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentCommentId !== null && this.documentCommentId !== undefined) {
      output.writeFieldBegin('documentCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentCommentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3477 = input.readListBegin();
          const _size476 = _rtmp3477.size || 0;
          for (let _i478 = 0; _i478 < _size476; ++_i478) {
            let elem479 = null;
            elem479 = new ContentHolderLink();
            elem479.read(input);
            this.holderLinks.push(elem479);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter480 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter480)) {
          iter480 = this.holderLinks[iter480];
          iter480.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentHolderShowPlace]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3482 = input.readListBegin();
          const _size481 = _rtmp3482.size || 0;
          for (let _i483 = 0; _i483 < _size481; ++_i483) {
            let elem484 = null;
            elem484 = new ContentHolderShowPlace();
            elem484.read(input);
            this.success.push(elem484);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter485 in this.success) {
        if (this.success.hasOwnProperty(iter485)) {
          iter485 = this.success[iter485];
          iter485.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentContentTab = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentContentTab !== undefined && args.documentContentTab !== null) {
        this.documentContentTab = new ContentTab(args.documentContentTab);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentContentTab = new ContentTab();
          this.documentContentTab.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentContentTab !== null && this.documentContentTab !== undefined) {
      output.writeFieldBegin('documentContentTab', Thrift.Type.STRUCT, 3);
      this.documentContentTab.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ContentTab(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ContentTab();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentTab]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3487 = input.readListBegin();
          const _size486 = _rtmp3487.size || 0;
          for (let _i488 = 0; _i488 < _size486; ++_i488) {
            let elem489 = null;
            elem489 = new ContentTab();
            elem489.read(input);
            this.success.push(elem489);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter490 in this.success) {
        if (this.success.hasOwnProperty(iter490)) {
          iter490 = this.success[iter490];
          iter490.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentContentTabId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentContentTabId !== undefined && args.documentContentTabId !== null) {
        this.documentContentTabId = args.documentContentTabId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentContentTabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentContentTabId !== null && this.documentContentTabId !== undefined) {
      output.writeFieldBegin('documentContentTabId', Thrift.Type.STRING, 2);
      output.writeString(this.documentContentTabId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp3492 = input.readSetBegin();
          const _size491 = _rtmp3492.size || 0;
          for (let _i493 = 0; _i493 < _size491; ++_i493) {
            let elem494 = null;
            elem494 = new UserOrGroup();
            elem494.read(input);
            this.success.push(elem494);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter495 in this.success) {
        if (this.success.hasOwnProperty(iter495)) {
          iter495 = this.success[iter495];
          iter495.write(output);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3497 = input.readListBegin();
          const _size496 = _rtmp3497.size || 0;
          for (let _i498 = 0; _i498 < _size496; ++_i498) {
            let elem499 = null;
            elem499 = new UserOrGroup();
            elem499.read(input);
            this.users.push(elem499);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter500 in this.users) {
        if (this.users.hasOwnProperty(iter500)) {
          iter500 = this.users[iter500];
          iter500.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3502 = input.readListBegin();
          const _size501 = _rtmp3502.size || 0;
          for (let _i503 = 0; _i503 < _size501; ++_i503) {
            let elem504 = null;
            elem504 = new UserOrGroup();
            elem504.read(input);
            this.users.push(elem504);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter505 in this.users) {
        if (this.users.hasOwnProperty(iter505)) {
          iter505 = this.users[iter505];
          iter505.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [News]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3507 = input.readListBegin();
          const _size506 = _rtmp3507.size || 0;
          for (let _i508 = 0; _i508 < _size506; ++_i508) {
            let elem509 = null;
            elem509 = new News();
            elem509.read(input);
            this.success.push(elem509);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter510 in this.success) {
        if (this.success.hasOwnProperty(iter510)) {
          iter510 = this.success[iter510];
          iter510.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_args = class {
  constructor(args) {
    this.token = null;
    this.date = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.date !== undefined && args.date !== null) {
        this.date = args.date;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.date = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.date !== null && this.date !== undefined) {
      output.writeFieldBegin('date', Thrift.Type.I64, 2);
      output.writeI64(this.date);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3512 = input.readMapBegin();
          const _size511 = _rtmp3512.size || 0;
          for (let _i513 = 0; _i513 < _size511; ++_i513) {
            if (_i513 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key514 = null;
            let val515 = null;
            key514 = input.readI32().value;
            val515 = input.readI32().value;
            this.success[key514] = val515;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter516 in this.success) {
        if (this.success.hasOwnProperty(kiter516)) {
          let viter517 = this.success[kiter516];
          output.writeI32(kiter516);
          output.writeI32(viter517);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.docNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.docNumber !== undefined && args.docNumber !== null) {
        this.docNumber = args.docNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.docNumber !== null && this.docNumber !== undefined) {
      output.writeFieldBegin('docNumber', Thrift.Type.STRING, 3);
      output.writeString(this.docNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.viewed = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 3);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3519 = input.readListBegin();
          const _size518 = _rtmp3519.size || 0;
          for (let _i520 = 0; _i520 < _size518; ++_i520) {
            let elem521 = null;
            elem521 = new DocumentRelation();
            elem521.read(input);
            this.success.push(elem521);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter522 in this.success) {
        if (this.success.hasOwnProperty(iter522)) {
          iter522 = this.success[iter522];
          iter522.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_args = class {
  constructor(args) {
    this.token = null;
    this.toCreate = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toCreate !== undefined && args.toCreate !== null) {
        this.toCreate = Thrift.copyList(args.toCreate, [DocumentRelation]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toCreate = [];
          const _rtmp3524 = input.readListBegin();
          const _size523 = _rtmp3524.size || 0;
          for (let _i525 = 0; _i525 < _size523; ++_i525) {
            let elem526 = null;
            elem526 = new DocumentRelation();
            elem526.read(input);
            this.toCreate.push(elem526);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3528 = input.readListBegin();
          const _size527 = _rtmp3528.size || 0;
          for (let _i529 = 0; _i529 < _size527; ++_i529) {
            let elem530 = null;
            elem530 = input.readString().value;
            this.toRemove.push(elem530);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toCreate !== null && this.toCreate !== undefined) {
      output.writeFieldBegin('toCreate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toCreate.length);
      for (let iter531 in this.toCreate) {
        if (this.toCreate.hasOwnProperty(iter531)) {
          iter531 = this.toCreate[iter531];
          iter531.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter532 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter532)) {
          iter532 = this.toRemove[iter532];
          output.writeString(iter532);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3534 = input.readListBegin();
          const _size533 = _rtmp3534.size || 0;
          for (let _i535 = 0; _i535 < _size533; ++_i535) {
            let elem536 = null;
            elem536 = new DocumentRelation();
            elem536.read(input);
            this.success.push(elem536);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter537 in this.success) {
        if (this.success.hasOwnProperty(iter537)) {
          iter537 = this.success[iter537];
          iter537.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.subStatus = null;
    this.comment = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 3);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentExecution = null;
    this.deadlineTime = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentExecution !== undefined && args.documentExecution !== null) {
        this.documentExecution = args.documentExecution;
      }
      if (args.deadlineTime !== undefined && args.deadlineTime !== null) {
        this.deadlineTime = args.deadlineTime;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentExecution !== null && this.documentExecution !== undefined) {
      output.writeFieldBegin('documentExecution', Thrift.Type.STRING, 3);
      output.writeString(this.documentExecution);
      output.writeFieldEnd();
    }
    if (this.deadlineTime !== null && this.deadlineTime !== undefined) {
      output.writeFieldBegin('deadlineTime', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineTime);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.users = null;
    this.deadlineDate = null;
    this.comment = null;
    this.requireMyParticipation = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [null]);
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.requireMyParticipation !== undefined && args.requireMyParticipation !== null) {
        this.requireMyParticipation = args.requireMyParticipation;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3539 = input.readListBegin();
          const _size538 = _rtmp3539.size || 0;
          for (let _i540 = 0; _i540 < _size538; ++_i540) {
            let elem541 = null;
            elem541 = input.readString().value;
            this.users.push(elem541);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.requireMyParticipation = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.users.length);
      for (let iter542 in this.users) {
        if (this.users.hasOwnProperty(iter542)) {
          iter542 = this.users[iter542];
          output.writeString(iter542);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 5);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.requireMyParticipation !== null && this.requireMyParticipation !== undefined) {
      output.writeFieldBegin('requireMyParticipation', Thrift.Type.BOOL, 6);
      output.writeBool(this.requireMyParticipation);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 7);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_args = class {
  constructor(args) {
    this.token = null;
    this.userDecision = null;
    this.cardId = null;
    this.comment = null;
    this.returnToParentStage = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userDecision !== undefined && args.userDecision !== null) {
        this.userDecision = Thrift.copyMap(args.userDecision, [null]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.returnToParentStage !== undefined && args.returnToParentStage !== null) {
        this.returnToParentStage = args.returnToParentStage;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.userDecision = {};
          const _rtmp3544 = input.readMapBegin();
          const _size543 = _rtmp3544.size || 0;
          for (let _i545 = 0; _i545 < _size543; ++_i545) {
            if (_i545 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key546 = null;
            let val547 = null;
            key546 = input.readString().value;
            val547 = input.readString().value;
            this.userDecision[key546] = val547;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.returnToParentStage = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userDecision !== null && this.userDecision !== undefined) {
      output.writeFieldBegin('userDecision', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.userDecision));
      for (let kiter548 in this.userDecision) {
        if (this.userDecision.hasOwnProperty(kiter548)) {
          let viter549 = this.userDecision[kiter548];
          output.writeString(kiter548);
          output.writeString(viter549);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.returnToParentStage !== null && this.returnToParentStage !== undefined) {
      output.writeFieldBegin('returnToParentStage', Thrift.Type.BOOL, 5);
      output.writeBool(this.returnToParentStage);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecisionUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.userDecision = null;
    this.cardId = null;
    this.comment = null;
    this.returnToParentStage = null;
    this.pKeyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userDecision !== undefined && args.userDecision !== null) {
        this.userDecision = Thrift.copyMap(args.userDecision, [null]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.returnToParentStage !== undefined && args.returnToParentStage !== null) {
        this.returnToParentStage = args.returnToParentStage;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.userDecision = {};
          const _rtmp3551 = input.readMapBegin();
          const _size550 = _rtmp3551.size || 0;
          for (let _i552 = 0; _i552 < _size550; ++_i552) {
            if (_i552 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key553 = null;
            let val554 = null;
            key553 = input.readString().value;
            val554 = input.readString().value;
            this.userDecision[key553] = val554;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.returnToParentStage = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecisionUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userDecision !== null && this.userDecision !== undefined) {
      output.writeFieldBegin('userDecision', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.userDecision));
      for (let kiter555 in this.userDecision) {
        if (this.userDecision.hasOwnProperty(kiter555)) {
          let viter556 = this.userDecision[kiter555];
          output.writeString(kiter555);
          output.writeString(viter556);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.returnToParentStage !== null && this.returnToParentStage !== undefined) {
      output.writeFieldBegin('returnToParentStage', Thrift.Type.BOOL, 5);
      output.writeBool(this.returnToParentStage);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 6);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 7);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecisionUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecisionUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    this.cardId = null;
    this.comment = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3558 = input.readListBegin();
          const _size557 = _rtmp3558.size || 0;
          for (let _i559 = 0; _i559 < _size557; ++_i559) {
            let elem560 = null;
            elem560 = new DocumentReassign();
            elem560.read(input);
            this.documentReassign.push(elem560);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter561 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter561)) {
          iter561 = this.documentReassign[iter561];
          iter561.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3563 = input.readMapBegin();
          const _size562 = _rtmp3563.size || 0;
          for (let _i564 = 0; _i564 < _size562; ++_i564) {
            if (_i564 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key565 = null;
            let val566 = null;
            key565 = input.readI32().value;
            val566 = input.readI32().value;
            this.success[key565] = val566;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter567 in this.success) {
        if (this.success.hasOwnProperty(kiter567)) {
          let viter568 = this.success[kiter567];
          output.writeI32(kiter567);
          output.writeI32(viter568);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.control = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.control !== undefined && args.control !== null) {
        this.control = args.control;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.control = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.control !== null && this.control !== undefined) {
      output.writeFieldBegin('control', Thrift.Type.BOOL, 3);
      output.writeBool(this.control);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyMap(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.tags = {};
          const _rtmp3570 = input.readMapBegin();
          const _size569 = _rtmp3570.size || 0;
          for (let _i571 = 0; _i571 < _size569; ++_i571) {
            if (_i571 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key572 = null;
            let val573 = null;
            key572 = input.readString().value;
            val573 = input.readI32().value;
            this.tags[key572] = val573;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.tags));
      for (let kiter574 in this.tags) {
        if (this.tags.hasOwnProperty(kiter574)) {
          let viter575 = this.tags[kiter574];
          output.writeString(kiter574);
          output.writeI32(viter575);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyMap(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.tags = {};
          const _rtmp3577 = input.readMapBegin();
          const _size576 = _rtmp3577.size || 0;
          for (let _i578 = 0; _i578 < _size576; ++_i578) {
            if (_i578 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key579 = null;
            let val580 = null;
            key579 = input.readString().value;
            val580 = input.readI32().value;
            this.tags[key579] = val580;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.tags));
      for (let kiter581 in this.tags) {
        if (this.tags.hasOwnProperty(kiter581)) {
          let viter582 = this.tags[kiter581];
          output.writeString(kiter581);
          output.writeI32(viter582);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.documentReassign = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3584 = input.readListBegin();
          const _size583 = _rtmp3584.size || 0;
          for (let _i585 = 0; _i585 < _size583; ++_i585) {
            let elem586 = null;
            elem586 = new DocumentReassign();
            elem586.read(input);
            this.documentReassign.push(elem586);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter587 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter587)) {
          iter587 = this.documentReassign[iter587];
          iter587.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3589 = input.readListBegin();
          const _size588 = _rtmp3589.size || 0;
          for (let _i590 = 0; _i590 < _size588; ++_i590) {
            let elem591 = null;
            elem591 = new DocumentExecution();
            elem591.read(input);
            this.success.push(elem591);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter592 in this.success) {
        if (this.success.hasOwnProperty(iter592)) {
          iter592 = this.success[iter592];
          iter592.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.patternGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternGroupId !== undefined && args.patternGroupId !== null) {
        this.patternGroupId = args.patternGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternGroupId !== null && this.patternGroupId !== undefined) {
      output.writeFieldBegin('patternGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.patternGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3594 = input.readListBegin();
          const _size593 = _rtmp3594.size || 0;
          for (let _i595 = 0; _i595 < _size593; ++_i595) {
            let elem596 = null;
            elem596 = new Document();
            elem596.read(input);
            this.success.push(elem596);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter597 in this.success) {
        if (this.success.hasOwnProperty(iter597)) {
          iter597 = this.success[iter597];
          iter597.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.newRegistrationDate = null;
    this.newRegistrationNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.newRegistrationDate !== undefined && args.newRegistrationDate !== null) {
        this.newRegistrationDate = args.newRegistrationDate;
      }
      if (args.newRegistrationNumber !== undefined && args.newRegistrationNumber !== null) {
        this.newRegistrationNumber = args.newRegistrationNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.newRegistrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.newRegistrationNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.newRegistrationDate !== null && this.newRegistrationDate !== undefined) {
      output.writeFieldBegin('newRegistrationDate', Thrift.Type.I64, 3);
      output.writeI64(this.newRegistrationDate);
      output.writeFieldEnd();
    }
    if (this.newRegistrationNumber !== null && this.newRegistrationNumber !== undefined) {
      output.writeFieldBegin('newRegistrationNumber', Thrift.Type.STRING, 4);
      output.writeString(this.newRegistrationNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3599 = input.readListBegin();
          const _size598 = _rtmp3599.size || 0;
          for (let _i600 = 0; _i600 < _size598; ++_i600) {
            let elem601 = null;
            elem601 = new DocumentExtShare();
            elem601.read(input);
            this.success.push(elem601);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter602 in this.success) {
        if (this.success.hasOwnProperty(iter602)) {
          iter602 = this.success[iter602];
          iter602.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.toAdd = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentExtShare]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3604 = input.readListBegin();
          const _size603 = _rtmp3604.size || 0;
          for (let _i605 = 0; _i605 < _size603; ++_i605) {
            let elem606 = null;
            elem606 = new DocumentExtShare();
            elem606.read(input);
            this.toAdd.push(elem606);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3608 = input.readListBegin();
          const _size607 = _rtmp3608.size || 0;
          for (let _i609 = 0; _i609 < _size607; ++_i609) {
            let elem610 = null;
            elem610 = input.readString().value;
            this.toRemove.push(elem610);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter611 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter611)) {
          iter611 = this.toAdd[iter611];
          iter611.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter612 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter612)) {
          iter612 = this.toRemove[iter612];
          output.writeString(iter612);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3614 = input.readListBegin();
          const _size613 = _rtmp3614.size || 0;
          for (let _i615 = 0; _i615 < _size613; ++_i615) {
            let elem616 = null;
            elem616 = new DocumentExtShare();
            elem616.read(input);
            this.success.push(elem616);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter617 in this.success) {
        if (this.success.hasOwnProperty(iter617)) {
          iter617 = this.success[iter617];
          iter617.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_args = class {
  constructor(args) {
    this.token = null;
    this.statusMap = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.statusMap !== undefined && args.statusMap !== null) {
        this.statusMap = Thrift.copyMap(args.statusMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.statusMap = {};
          const _rtmp3619 = input.readMapBegin();
          const _size618 = _rtmp3619.size || 0;
          for (let _i620 = 0; _i620 < _size618; ++_i620) {
            if (_i620 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key621 = null;
            let val622 = null;
            key621 = input.readString().value;
            val622 = input.readI32().value;
            this.statusMap[key621] = val622;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.statusMap !== null && this.statusMap !== undefined) {
      output.writeFieldBegin('statusMap', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.statusMap));
      for (let kiter623 in this.statusMap) {
        if (this.statusMap.hasOwnProperty(kiter623)) {
          let viter624 = this.statusMap[kiter623];
          output.writeString(kiter623);
          output.writeI32(viter624);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.resolution = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.resolution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.STRING, 3);
      output.writeString(this.resolution);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_args = class {
  constructor(args) {
    this.token = null;
    this.docCommentId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docCommentId !== undefined && args.docCommentId !== null) {
        this.docCommentId = args.docCommentId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docCommentId !== null && this.docCommentId !== undefined) {
      output.writeFieldBegin('docCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.docCommentId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.startStageId = null;
    this.stages = null;
    this.contentItems = null;
    this.roles = null;
    this.patternVariables = null;
    this.accessPolicy = null;
    this.newRegNumber = null;
    this.patternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.startStageId !== undefined && args.startStageId !== null) {
        this.startStageId = args.startStageId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [PatternProcessRole]);
      }
      if (args.patternVariables !== undefined && args.patternVariables !== null) {
        this.patternVariables = Thrift.copyList(args.patternVariables, [PatternVariable]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.newRegNumber !== undefined && args.newRegNumber !== null) {
        this.newRegNumber = args.newRegNumber;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.startStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp3626 = input.readListBegin();
          const _size625 = _rtmp3626.size || 0;
          for (let _i627 = 0; _i627 < _size625; ++_i627) {
            let elem628 = null;
            elem628 = new DocumentPatternStage();
            elem628.read(input);
            this.stages.push(elem628);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3630 = input.readListBegin();
          const _size629 = _rtmp3630.size || 0;
          for (let _i631 = 0; _i631 < _size629; ++_i631) {
            let elem632 = null;
            elem632 = new ContentItem();
            elem632.read(input);
            this.contentItems.push(elem632);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.roles = [];
          const _rtmp3634 = input.readListBegin();
          const _size633 = _rtmp3634.size || 0;
          for (let _i635 = 0; _i635 < _size633; ++_i635) {
            let elem636 = null;
            elem636 = new PatternProcessRole();
            elem636.read(input);
            this.roles.push(elem636);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.patternVariables = [];
          const _rtmp3638 = input.readListBegin();
          const _size637 = _rtmp3638.size || 0;
          for (let _i639 = 0; _i639 < _size637; ++_i639) {
            let elem640 = null;
            elem640 = new PatternVariable();
            elem640.read(input);
            this.patternVariables.push(elem640);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.newRegNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.startStageId !== null && this.startStageId !== undefined) {
      output.writeFieldBegin('startStageId', Thrift.Type.STRING, 3);
      output.writeString(this.startStageId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter641 in this.stages) {
        if (this.stages.hasOwnProperty(iter641)) {
          iter641 = this.stages[iter641];
          iter641.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter642 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter642)) {
          iter642 = this.contentItems[iter642];
          iter642.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.roles.length);
      for (let iter643 in this.roles) {
        if (this.roles.hasOwnProperty(iter643)) {
          iter643 = this.roles[iter643];
          iter643.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.patternVariables !== null && this.patternVariables !== undefined) {
      output.writeFieldBegin('patternVariables', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternVariables.length);
      for (let iter644 in this.patternVariables) {
        if (this.patternVariables.hasOwnProperty(iter644)) {
          iter644 = this.patternVariables[iter644];
          iter644.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 8);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.newRegNumber !== null && this.newRegNumber !== undefined) {
      output.writeFieldBegin('newRegNumber', Thrift.Type.STRING, 9);
      output.writeString(this.newRegNumber);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 10);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentRelationModel(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentRelationModel();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_args = class {
  constructor(args) {
    this.token = null;
    this.prevAttId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.prevAttId !== undefined && args.prevAttId !== null) {
        this.prevAttId = args.prevAttId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.prevAttId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.prevAttId !== null && this.prevAttId !== undefined) {
      output.writeFieldBegin('prevAttId', Thrift.Type.STRING, 2);
      output.writeString(this.prevAttId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xml = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xml !== undefined && args.xml !== null) {
        this.xml = args.xml;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xml = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xml !== null && this.xml !== undefined) {
      output.writeFieldBegin('xml', Thrift.Type.STRING, 2);
      output.writeBinary(this.xml);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentItem]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3646 = input.readListBegin();
          const _size645 = _rtmp3646.size || 0;
          for (let _i647 = 0; _i647 < _size645; ++_i647) {
            let elem648 = null;
            elem648 = new ContentItem();
            elem648.read(input);
            this.success.push(elem648);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter649 in this.success) {
        if (this.success.hasOwnProperty(iter649)) {
          iter649 = this.success[iter649];
          iter649.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  calculatePermissions (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_calculatePermissions(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_calculatePermissions (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_calculatePermissions_args(params);
    try {
      this.output.writeMessageBegin('calculatePermissions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_calculatePermissions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_calculatePermissions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_calculatePermissions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'calculatePermissions failed: unknown result';
  }

  createOrUpdateDocument (token, document, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocument(token, document, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocument (token, document, accessPolicy, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocument_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocument failed: unknown result';
  }

  updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateDocument(token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy,
      addedResponsibles: addedResponsibles,
      removedResponsibles: removedResponsibles,
      addedSecurityClassificationIds: addedSecurityClassificationIds,
      removedSecurityClassificationIds: removedSecurityClassificationIds
    };
    const args = new DocumentService_updateDocument_args(params);
    try {
      this.output.writeMessageBegin('updateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateDocument failed: unknown result';
  }

  createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocument(token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, callback) {
    const params = {
      token: token,
      document: document,
      users: users,
      holderLinks: holderLinks,
      securityClassificationsId: securityClassificationsId,
      attachments: attachments,
      docRelations: docRelations
    };
    const args = new DocumentService_createDocument_args(params);
    try {
      this.output.writeMessageBegin('createDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocument failed: unknown result';
  }

  createDocumentFromXML (token, xmlDoc) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocumentFromXML(token, xmlDoc, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocumentFromXML (token, xmlDoc, callback) {
    const params = {
      token: token,
      xmlDoc: xmlDoc
    };
    const args = new DocumentService_createDocumentFromXML_args(params);
    try {
      this.output.writeMessageBegin('createDocumentFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocumentFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocumentFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocumentFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocumentFromXML failed: unknown result';
  }

  getDocument (token, documentId, accessPolicy, decrypt, executorsPortion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocument(token, documentId, accessPolicy, decrypt, executorsPortion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocument (token, documentId, accessPolicy, decrypt, executorsPortion, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      decrypt: decrypt,
      executorsPortion: executorsPortion
    };
    const args = new DocumentService_getDocument_args(params);
    try {
      this.output.writeMessageBegin('getDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocument failed: unknown result';
  }

  getAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocuments failed: unknown result';
  }

  getCountAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getCountAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getCountAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllDocuments failed: unknown result';
  }

  deleteDocument (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocument(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocument (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocument_args(params);
    try {
      this.output.writeMessageBegin('deleteDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocument failed: unknown result';
  }

  getAllPassedStages (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllPassedStages(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllPassedStages (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllPassedStages_args(params);
    try {
      this.output.writeMessageBegin('getAllPassedStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllPassedStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllPassedStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllPassedStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllPassedStages failed: unknown result';
  }

  getExecutionTree (token, documentId, accessPolicy, iteration, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getExecutionTree(token, documentId, accessPolicy, iteration, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getExecutionTree (token, documentId, accessPolicy, iteration, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      iteration: iteration,
      filter: filter
    };
    const args = new DocumentService_getExecutionTree_args(params);
    try {
      this.output.writeMessageBegin('getExecutionTree', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getExecutionTree();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getExecutionTree () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getExecutionTree_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getExecutionTree failed: unknown result';
  }

  getActiveStages (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getActiveStages(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getActiveStages (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getActiveStages_args(params);
    try {
      this.output.writeMessageBegin('getActiveStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getActiveStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getActiveStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getActiveStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getActiveStages failed: unknown result';
  }

  getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountPeoplesWhenRenderedDecision(token, documentId, stageId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getCountPeoplesWhenRenderedDecision_args(params);
    try {
      this.output.writeMessageBegin('getCountPeoplesWhenRenderedDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountPeoplesWhenRenderedDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountPeoplesWhenRenderedDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountPeoplesWhenRenderedDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountPeoplesWhenRenderedDecision failed: unknown result';
  }

  setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecision(token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      signature: signature,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecision failed: unknown result';
  }

  setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecisionUsingServerKeyStorage(token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      pKeyId: pKeyId,
      password: password,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecisionUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecisionUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecisionUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecisionUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecisionUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecisionUsingServerKeyStorage failed: unknown result';
  }

  approveDocumentDecision (token, executionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_approveDocumentDecision(token, executionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_approveDocumentDecision (token, executionId, callback) {
    const params = {
      token: token,
      executionId: executionId
    };
    const args = new DocumentService_approveDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('approveDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_approveDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_approveDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_approveDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'approveDocumentDecision failed: unknown result';
  }

  shareDocument (token, documentId, accessPolicy, usersOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_shareDocument(token, documentId, accessPolicy, usersOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_shareDocument (token, documentId, accessPolicy, usersOrGroups, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      usersOrGroups: usersOrGroups
    };
    const args = new DocumentService_shareDocument_args(params);
    try {
      this.output.writeMessageBegin('shareDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_shareDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_shareDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_shareDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'shareDocument failed: unknown result';
  }

  revokeDocument (token, documentId, usersOrGroups, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDocument(token, documentId, usersOrGroups, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDocument (token, documentId, usersOrGroups, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      usersOrGroups: usersOrGroups,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeDocument_args(params);
    try {
      this.output.writeMessageBegin('revokeDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDocument failed: unknown result';
  }

  getAllDocumentSharings (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentSharings(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentSharings (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentSharings_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentSharings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentSharings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentSharings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentSharings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentSharings failed: unknown result';
  }

  getAllDocumentReassign (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentReassign(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentReassign (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentReassign failed: unknown result';
  }

  reassignDocument (token, documentId, documentReassign, cardId, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocument(token, documentId, documentReassign, cardId, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocument (token, documentId, documentReassign, cardId, signature, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      signature: signature
    };
    const args = new DocumentService_reassignDocument_args(params);
    try {
      this.output.writeMessageBegin('reassignDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocument failed: unknown result';
  }

  reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocumentUsingServerKeyStorage(token, documentId, documentReassign, cardId, pKeyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      pKeyId: pKeyId,
      password: password
    };
    const args = new DocumentService_reassignDocumentUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('reassignDocumentUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocumentUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocumentUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocumentUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocumentUsingServerKeyStorage failed: unknown result';
  }

  revokeChildCards (token, cardId, deleteCard, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeChildCards(token, cardId, deleteCard, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeChildCards (token, cardId, deleteCard, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      deleteCard: deleteCard,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeChildCards_args(params);
    try {
      this.output.writeMessageBegin('revokeChildCards', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeChildCards();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeChildCards () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeChildCards_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeChildCards failed: unknown result';
  }

  createOrUpdateAutomaticDocumentReassign (token, documentReassign) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateAutomaticDocumentReassign(token, documentReassign, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateAutomaticDocumentReassign (token, documentReassign, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign
    };
    const args = new DocumentService_createOrUpdateAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateAutomaticDocumentReassign failed: unknown result';
  }

  deleteAutomaticDocumentReassign (token, documentReassignId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteAutomaticDocumentReassign(token, documentReassignId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteAutomaticDocumentReassign (token, documentReassignId, callback) {
    const params = {
      token: token,
      documentReassignId: documentReassignId
    };
    const args = new DocumentService_deleteAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('deleteAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteAutomaticDocumentReassign failed: unknown result';
  }

  changeReassignControl (token, documentExecutionId, userId, reassignType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeReassignControl(token, documentExecutionId, userId, reassignType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeReassignControl (token, documentExecutionId, userId, reassignType, callback) {
    const params = {
      token: token,
      documentExecutionId: documentExecutionId,
      userId: userId,
      reassignType: reassignType
    };
    const args = new DocumentService_changeReassignControl_args(params);
    try {
      this.output.writeMessageBegin('changeReassignControl', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeReassignControl();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeReassignControl () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeReassignControl_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeReassignControl failed: unknown result';
  }

  getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentExecutions(token, documentId, stageId, typeLink, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      typeLink: typeLink,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentExecutions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentExecutions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentExecutions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentExecutions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentExecutions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentExecutions failed: unknown result';
  }

  getDocumentExecution (token, docExecutionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExecution(token, docExecutionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExecution (token, docExecutionId, callback) {
    const params = {
      token: token,
      docExecutionId: docExecutionId
    };
    const args = new DocumentService_getDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExecution failed: unknown result';
  }

  changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeExecutorsForDocument(token, docId, toAdd, toClose, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      toAdd: toAdd,
      toClose: toClose,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeExecutorsForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeExecutorsForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeExecutorsForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeExecutorsForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeExecutorsForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeExecutorsForDocument failed: unknown result';
  }

  createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createAttachmentFrom(token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy,
      attCreateInfoList: attCreateInfoList,
      processingType: processingType
    };
    const args = new DocumentService_createAttachmentFrom_args(params);
    try {
      this.output.writeMessageBegin('createAttachmentFrom', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createAttachmentFrom();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createAttachmentFrom () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createAttachmentFrom_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createAttachmentFrom failed: unknown result';
  }

  createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createLoadableAttachment(token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, callback) {
    const params = {
      token: token,
      documentId: documentId,
      fileName: fileName,
      totalSize: totalSize,
      countPortions: countPortions,
      cardId: cardId,
      attachmmentId: attachmmentId,
      forDraft: forDraft,
      accessPolicy: accessPolicy,
      editMode: editMode,
      meetingId: meetingId,
      extStatus: extStatus
    };
    const args = new DocumentService_createLoadableAttachment_args(params);
    try {
      this.output.writeMessageBegin('createLoadableAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createLoadableAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createLoadableAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createLoadableAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createLoadableAttachment failed: unknown result';
  }

  uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadDocumentAttachmentPortions(token, attachmentId, numberPortion, fileContentBytes, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      numberPortion: numberPortion,
      fileContentBytes: fileContentBytes
    };
    const args = new DocumentService_uploadDocumentAttachmentPortions_args(params);
    try {
      this.output.writeMessageBegin('uploadDocumentAttachmentPortions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadDocumentAttachmentPortions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadDocumentAttachmentPortions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_uploadDocumentAttachmentPortions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadDocumentAttachmentPortions failed: unknown result';
  }

  writeHistoryOpenAttachment (token, attachmentId, attachmentType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_writeHistoryOpenAttachment(token, attachmentId, attachmentType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_writeHistoryOpenAttachment (token, attachmentId, attachmentType, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      attachmentType: attachmentType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_writeHistoryOpenAttachment_args(params);
    try {
      this.output.writeMessageBegin('writeHistoryOpenAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_writeHistoryOpenAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_writeHistoryOpenAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_writeHistoryOpenAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'writeHistoryOpenAttachment failed: unknown result';
  }

  downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_downloadDocumentAttachment(token, attachmentId, attachmentType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      attachmentType: attachmentType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_downloadDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('downloadDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_downloadDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_downloadDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_downloadDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'downloadDocumentAttachment failed: unknown result';
  }

  rotatePdfPages (token, attachmentId, pages, angle, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_rotatePdfPages(token, attachmentId, pages, angle, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_rotatePdfPages (token, attachmentId, pages, angle, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      pages: pages,
      angle: angle,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_rotatePdfPages_args(params);
    try {
      this.output.writeMessageBegin('rotatePdfPages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_rotatePdfPages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_rotatePdfPages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_rotatePdfPages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'rotatePdfPages failed: unknown result';
  }

  addAttachmentsToDocument (token, documentId, attachments, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAttachmentsToDocument(token, documentId, attachments, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAttachmentsToDocument (token, documentId, attachments, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      attachments: attachments,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAttachmentsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addAttachmentsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAttachmentsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAttachmentsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAttachmentsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAttachmentsToDocument failed: unknown result';
  }

  removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeDocumentAttachment(token, attachmentId, removeOldVersions, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      removeOldVersions: removeOldVersions,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('removeDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeDocumentAttachment failed: unknown result';
  }

  markAsWaitForPublish (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markAsWaitForPublish(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markAsWaitForPublish (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new DocumentService_markAsWaitForPublish_args(params);
    try {
      this.output.writeMessageBegin('markAsWaitForPublish', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markAsWaitForPublish();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markAsWaitForPublish () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markAsWaitForPublish_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markAsWaitForPublish failed: unknown result';
  }

  changeAttachmentEditMode (token, attachmentId, editMode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentEditMode(token, attachmentId, editMode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentEditMode (token, attachmentId, editMode, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      editMode: editMode
    };
    const args = new DocumentService_changeAttachmentEditMode_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentEditMode', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentEditMode();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentEditMode () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentEditMode_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentEditMode failed: unknown result';
  }

  getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachments(token, documentId, latestOnly, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      latestOnly: latestOnly,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachments_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachments failed: unknown result';
  }

  getDocumentAttachmentById (token, attachmentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachmentById(token, attachmentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachmentById (token, attachmentId, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachmentById_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachmentById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachmentById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachmentById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachmentById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachmentById failed: unknown result';
  }

  getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentAttachmentVersions(token, attachmentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentAttachmentVersions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentAttachmentVersions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentAttachmentVersions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentAttachmentVersions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentAttachmentVersions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentAttachmentVersions failed: unknown result';
  }

  changeAttachmentsVisibility (token, toHideList, toShowList) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentsVisibility(token, toHideList, toShowList, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentsVisibility (token, toHideList, toShowList, callback) {
    const params = {
      token: token,
      toHideList: toHideList,
      toShowList: toShowList
    };
    const args = new DocumentService_changeAttachmentsVisibility_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentsVisibility', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentsVisibility();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentsVisibility () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentsVisibility_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentsVisibility failed: unknown result';
  }

  createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentComment(token, documentComment, addToComment, changeType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy, callback) {
    const params = {
      token: token,
      documentComment: documentComment,
      addToComment: addToComment,
      changeType: changeType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentComment failed: unknown result';
  }

  getAllDocumentComments (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentComments(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentComments (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentComments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentComments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentComments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentComments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentComments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentComments failed: unknown result';
  }

  deleteDocumentComment (token, documentCommentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentComment(token, documentCommentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentComment (token, documentCommentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentCommentId: documentCommentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentComment failed: unknown result';
  }

  createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentHolderLink(token, documentId, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentHolderLink_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentHolderLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentHolderLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentHolderLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentHolderLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentHolderLink failed: unknown result';
  }

  createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentTab(token, documentId, documentContentTab, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentContentTab: documentContentTab,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentTab failed: unknown result';
  }

  getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentContentTabsByFilter(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentContentTabsByFilter_args(params);
    try {
      this.output.writeMessageBegin('getDocumentContentTabsByFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentContentTabsByFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentContentTabsByFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentContentTabsByFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentContentTabsByFilter failed: unknown result';
  }

  deleteDocumentContentTab (token, documentContentTabId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentContentTab(token, documentContentTabId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentContentTab (token, documentContentTabId, accessPolicy, callback) {
    const params = {
      token: token,
      documentContentTabId: documentContentTabId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentContentTab failed: unknown result';
  }

  documentToArchive (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_documentToArchive(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_documentToArchive (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_documentToArchive_args(params);
    try {
      this.output.writeMessageBegin('documentToArchive', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_documentToArchive();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_documentToArchive () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_documentToArchive_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'documentToArchive failed: unknown result';
  }

  getAllResponsibleForDocument (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllResponsibleForDocument(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllResponsibleForDocument (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('getAllResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllResponsibleForDocument failed: unknown result';
  }

  addResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('addResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addResponsibleForDocument failed: unknown result';
  }

  removeResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('removeResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeResponsibleForDocument failed: unknown result';
  }

  getDocHistoryPage (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocHistoryPage(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocHistoryPage (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getDocHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocHistoryPage failed: unknown result';
  }

  getAllNews (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNews(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNews (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllNews_args(params);
    try {
      this.output.writeMessageBegin('getAllNews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllNews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNews failed: unknown result';
  }

  getTasksByDate (token, date) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTasksByDate(token, date, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTasksByDate (token, date, callback) {
    const params = {
      token: token,
      date: date
    };
    const args = new DocumentService_getTasksByDate_args(params);
    try {
      this.output.writeMessageBegin('getTasksByDate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTasksByDate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTasksByDate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTasksByDate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTasksByDate failed: unknown result';
  }

  generateDocumentNumber (token, documentId, docNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateDocumentNumber(token, documentId, docNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateDocumentNumber (token, documentId, docNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      docNumber: docNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_generateDocumentNumber_args(params);
    try {
      this.output.writeMessageBegin('generateDocumentNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateDocumentNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateDocumentNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_generateDocumentNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateDocumentNumber failed: unknown result';
  }

  setDocumentViewed (token, documentId, viewed, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentViewed(token, documentId, viewed, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentViewed (token, documentId, viewed, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      viewed: viewed,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentViewed_args(params);
    try {
      this.output.writeMessageBegin('setDocumentViewed', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentViewed();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentViewed () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentViewed_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentViewed failed: unknown result';
  }

  getAllDocumentRelations (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentRelations(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentRelations (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentRelations_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentRelations failed: unknown result';
  }

  changeRelations (token, toCreate, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRelations(token, toCreate, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRelations (token, toCreate, toRemove, callback) {
    const params = {
      token: token,
      toCreate: toCreate,
      toRemove: toRemove
    };
    const args = new DocumentService_changeRelations_args(params);
    try {
      this.output.writeMessageBegin('changeRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRelations failed: unknown result';
  }

  changeSubStatus (token, documentId, subStatus, comment, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeSubStatus(token, documentId, subStatus, comment, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeSubStatus (token, documentId, subStatus, comment, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      subStatus: subStatus,
      comment: comment,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeSubStatus_args(params);
    try {
      this.output.writeMessageBegin('changeSubStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeSubStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeSubStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeSubStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeSubStatus failed: unknown result';
  }

  increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_increaseDeadlineForDocumentOrDocumentExecution(token, documentId, documentExecution, deadlineTime, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentExecution: documentExecution,
      deadlineTime: deadlineTime,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('increaseDeadlineForDocumentOrDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_increaseDeadlineForDocumentOrDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_increaseDeadlineForDocumentOrDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'increaseDeadlineForDocumentOrDocumentExecution failed: unknown result';
  }

  addAdditionalConfirmers (token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAdditionalConfirmers(token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAdditionalConfirmers (token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      users: users,
      deadlineDate: deadlineDate,
      comment: comment,
      requireMyParticipation: requireMyParticipation,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAdditionalConfirmers_args(params);
    try {
      this.output.writeMessageBegin('addAdditionalConfirmers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAdditionalConfirmers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAdditionalConfirmers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAdditionalConfirmers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAdditionalConfirmers failed: unknown result';
  }

  setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setAdditionalDecision(token, userDecision, cardId, comment, returnToParentStage, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature, callback) {
    const params = {
      token: token,
      userDecision: userDecision,
      cardId: cardId,
      comment: comment,
      returnToParentStage: returnToParentStage,
      signature: signature
    };
    const args = new DocumentService_setAdditionalDecision_args(params);
    try {
      this.output.writeMessageBegin('setAdditionalDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setAdditionalDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setAdditionalDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setAdditionalDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setAdditionalDecision failed: unknown result';
  }

  setAdditionalDecisionUsingServerKeyStorage (token, userDecision, cardId, comment, returnToParentStage, pKeyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setAdditionalDecisionUsingServerKeyStorage(token, userDecision, cardId, comment, returnToParentStage, pKeyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setAdditionalDecisionUsingServerKeyStorage (token, userDecision, cardId, comment, returnToParentStage, pKeyId, password, callback) {
    const params = {
      token: token,
      userDecision: userDecision,
      cardId: cardId,
      comment: comment,
      returnToParentStage: returnToParentStage,
      pKeyId: pKeyId,
      password: password
    };
    const args = new DocumentService_setAdditionalDecisionUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('setAdditionalDecisionUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setAdditionalDecisionUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setAdditionalDecisionUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setAdditionalDecisionUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setAdditionalDecisionUsingServerKeyStorage failed: unknown result';
  }

  revokeDecision (token, documentReassign, cardId, comment) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDecision(token, documentReassign, cardId, comment, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDecision (token, documentReassign, cardId, comment, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign,
      cardId: cardId,
      comment: comment
    };
    const args = new DocumentService_revokeDecision_args(params);
    try {
      this.output.writeMessageBegin('revokeDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDecision failed: unknown result';
  }

  markDecisionAsRemoved (token, documentId, cardId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markDecisionAsRemoved(token, documentId, cardId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markDecisionAsRemoved (token, documentId, cardId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_markDecisionAsRemoved_args(params);
    try {
      this.output.writeMessageBegin('markDecisionAsRemoved', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markDecisionAsRemoved();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markDecisionAsRemoved () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markDecisionAsRemoved_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markDecisionAsRemoved failed: unknown result';
  }

  getAllOpenDocumentExecutionsStatistic (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllOpenDocumentExecutionsStatistic(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllOpenDocumentExecutionsStatistic (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new DocumentService_getAllOpenDocumentExecutionsStatistic_args(params);
    try {
      this.output.writeMessageBegin('getAllOpenDocumentExecutionsStatistic', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllOpenDocumentExecutionsStatistic();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllOpenDocumentExecutionsStatistic () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllOpenDocumentExecutionsStatistic_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllOpenDocumentExecutionsStatistic failed: unknown result';
  }

  changeControlForDocument (token, documentId, control, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeControlForDocument(token, documentId, control, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeControlForDocument (token, documentId, control, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      control: control,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeControlForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeControlForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeControlForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeControlForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeControlForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeControlForDocument failed: unknown result';
  }

  addTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_addTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addTagsToDocument failed: unknown result';
  }

  removeTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_removeTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('removeTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeTagsToDocument failed: unknown result';
  }

  addExecutorsToStage (token, docId, documentReassign, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addExecutorsToStage(token, docId, documentReassign, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addExecutorsToStage (token, docId, documentReassign, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      documentReassign: documentReassign,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addExecutorsToStage_args(params);
    try {
      this.output.writeMessageBegin('addExecutorsToStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addExecutorsToStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addExecutorsToStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addExecutorsToStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addExecutorsToStage failed: unknown result';
  }

  getCountDocsByFilterNoPermission (token, patternGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountDocsByFilterNoPermission(token, patternGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountDocsByFilterNoPermission (token, patternGroupId, filter, callback) {
    const params = {
      token: token,
      patternGroupId: patternGroupId,
      filter: filter
    };
    const args = new DocumentService_getCountDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getCountDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountDocsByFilterNoPermission failed: unknown result';
  }

  getTinyDocsByFilterNoPermission (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTinyDocsByFilterNoPermission(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTinyDocsByFilterNoPermission (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getTinyDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getTinyDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTinyDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTinyDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTinyDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTinyDocsByFilterNoPermission failed: unknown result';
  }

  changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRegistrationInfoForDocument(token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      newRegistrationDate: newRegistrationDate,
      newRegistrationNumber: newRegistrationNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeRegistrationInfoForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeRegistrationInfoForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRegistrationInfoForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRegistrationInfoForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRegistrationInfoForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRegistrationInfoForDocument failed: unknown result';
  }

  createChatForDocument (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createChatForDocument(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createChatForDocument (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_createChatForDocument_args(params);
    try {
      this.output.writeMessageBegin('createChatForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createChatForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createChatForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createChatForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createChatForDocument failed: unknown result';
  }

  getDocumentExtShareList (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExtShareList(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExtShareList (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocumentExtShareList_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExtShareList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExtShareList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExtShareList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExtShareList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExtShareList failed: unknown result';
  }

  changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentExtShare(token, documentId, accessPolicy, toAdd, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      toAdd: toAdd,
      toRemove: toRemove
    };
    const args = new DocumentService_changeDocumentExtShare_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentExtShare', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentExtShare();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentExtShare () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentExtShare_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentExtShare failed: unknown result';
  }

  changeAttachmentExtStatus (token, statusMap) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentExtStatus(token, statusMap, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentExtStatus (token, statusMap, callback) {
    const params = {
      token: token,
      statusMap: statusMap
    };
    const args = new DocumentService_changeAttachmentExtStatus_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentExtStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentExtStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentExtStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentExtStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentExtStatus failed: unknown result';
  }

  remindDocumentExecutor (token, cardId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_remindDocumentExecutor(token, cardId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_remindDocumentExecutor (token, cardId, comment, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_remindDocumentExecutor_args(params);
    try {
      this.output.writeMessageBegin('remindDocumentExecutor', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_remindDocumentExecutor();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_remindDocumentExecutor () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_remindDocumentExecutor_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'remindDocumentExecutor failed: unknown result';
  }

  updateReassignResolution (token, cardId, resolution, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateReassignResolution(token, cardId, resolution, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateReassignResolution (token, cardId, resolution, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      resolution: resolution,
      policy: policy
    };
    const args = new DocumentService_updateReassignResolution_args(params);
    try {
      this.output.writeMessageBegin('updateReassignResolution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateReassignResolution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateReassignResolution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateReassignResolution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateReassignResolution failed: unknown result';
  }

  updateSubStatusComment (token, docCommentId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateSubStatusComment(token, docCommentId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateSubStatusComment (token, docCommentId, comment, policy, callback) {
    const params = {
      token: token,
      docCommentId: docCommentId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_updateSubStatusComment_args(params);
    try {
      this.output.writeMessageBegin('updateSubStatusComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateSubStatusComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateSubStatusComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateSubStatusComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateSubStatusComment failed: unknown result';
  }

  changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, patternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentType(token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, patternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, patternId, callback) {
    const params = {
      token: token,
      docId: docId,
      startStageId: startStageId,
      stages: stages,
      contentItems: contentItems,
      roles: roles,
      patternVariables: patternVariables,
      accessPolicy: accessPolicy,
      newRegNumber: newRegNumber,
      patternId: patternId
    };
    const args = new DocumentService_changeDocumentType_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentType failed: unknown result';
  }

  getDocumentRelationModel (token, docId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentRelationModel(token, docId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentRelationModel (token, docId, filter, callback) {
    const params = {
      token: token,
      docId: docId,
      filter: filter
    };
    const args = new DocumentService_getDocumentRelationModel_args(params);
    try {
      this.output.writeMessageBegin('getDocumentRelationModel', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentRelationModel();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentRelationModel () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentRelationModel_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentRelationModel failed: unknown result';
  }

  getNewConvertedAttachmentVersion (token, prevAttId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNewConvertedAttachmentVersion(token, prevAttId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNewConvertedAttachmentVersion (token, prevAttId, callback) {
    const params = {
      token: token,
      prevAttId: prevAttId
    };
    const args = new DocumentService_getNewConvertedAttachmentVersion_args(params);
    try {
      this.output.writeMessageBegin('getNewConvertedAttachmentVersion', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNewConvertedAttachmentVersion();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNewConvertedAttachmentVersion () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getNewConvertedAttachmentVersion_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNewConvertedAttachmentVersion failed: unknown result';
  }

  exportAsXML (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportAsXML(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportAsXML (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_exportAsXML_args(params);
    try {
      this.output.writeMessageBegin('exportAsXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportAsXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportAsXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_exportAsXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportAsXML failed: unknown result';
  }

  importFromXML (token, xml) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_importFromXML(token, xml, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_importFromXML (token, xml, callback) {
    const params = {
      token: token,
      xml: xml
    };
    const args = new DocumentService_importFromXML_args(params);
    try {
      this.output.writeMessageBegin('importFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_importFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_importFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_importFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'importFromXML failed: unknown result';
  }

  getDocContentItemsForChangeType (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocContentItemsForChangeType(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocContentItemsForChangeType (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_getDocContentItemsForChangeType_args(params);
    try {
      this.output.writeMessageBegin('getDocContentItemsForChangeType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocContentItemsForChangeType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocContentItemsForChangeType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocContentItemsForChangeType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocContentItemsForChangeType failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DsignService_getTimeStampToken_args = class {
  constructor(args) {
    this.token = null;
    this.data = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = args.data;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getTimeStampToken_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.STRING, 2);
      output.writeString(this.data);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getTimeStampToken_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getTimeStampToken_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_signAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_signAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 3);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_signAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_signAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_signAttachmentUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.pKeyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_signAttachmentUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 3);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_signAttachmentUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_signAttachmentUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getAllDigitalSigns_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getAllDigitalSigns_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getAllDigitalSigns_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DigitalSign]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new DigitalSign();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getAllDigitalSigns_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCertificateInfo_args = class {
  constructor(args) {
    this.token = null;
    this.digitalSignId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.digitalSignId !== undefined && args.digitalSignId !== null) {
        this.digitalSignId = args.digitalSignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.digitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCertificateInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.digitalSignId !== null && this.digitalSignId !== undefined) {
      output.writeFieldBegin('digitalSignId', Thrift.Type.STRING, 2);
      output.writeString(this.digitalSignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCertificateInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [CertificateInfo]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new CertificateInfo();
            elem18.read(input);
            this.success.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCertificateInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter19 in this.success) {
        if (this.success.hasOwnProperty(iter19)) {
          iter19 = this.success[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCertificateInfoListByUser_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCertificateInfoListByUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCertificateInfoListByUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserKeyData]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new UserKeyData();
            elem23.read(input);
            this.success.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCertificateInfoListByUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter24 in this.success) {
        if (this.success.hasOwnProperty(iter24)) {
          iter24 = this.success[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getSignInfoByCertificate_args = class {
  constructor(args) {
    this.token = null;
    this.data = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.data !== undefined && args.data !== null) {
        this.data = args.data;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.data = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getSignInfoByCertificate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.data !== null && this.data !== undefined) {
      output.writeFieldBegin('data', Thrift.Type.STRING, 2);
      output.writeString(this.data);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getSignInfoByCertificate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new CertificateInfo(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new CertificateInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getSignInfoByCertificate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getSignInfo_args = class {
  constructor(args) {
    this.digitalSignId = null;
    if (args) {
      if (args.digitalSignId !== undefined && args.digitalSignId !== null) {
        this.digitalSignId = args.digitalSignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.digitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getSignInfo_args');
    if (this.digitalSignId !== null && this.digitalSignId !== undefined) {
      output.writeFieldBegin('digitalSignId', Thrift.Type.STRING, 1);
      output.writeString(this.digitalSignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getSignInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new SignInfo(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new SignInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getSignInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getAllPrivateKeys_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getAllPrivateKeys_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getAllPrivateKeys_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PrivateKeyInfo]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new PrivateKeyInfo();
            elem28.read(input);
            this.success.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getAllPrivateKeys_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter29 in this.success) {
        if (this.success.hasOwnProperty(iter29)) {
          iter29 = this.success[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCountPrivateKeys_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCountPrivateKeys_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getCountPrivateKeys_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getCountPrivateKeys_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_addKeyToSecureStorage_args = class {
  constructor(args) {
    this.token = null;
    this.key1 = null;
    this.password = null;
    this.name = null;
    this.fileExt = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.key1 !== undefined && args.key1 !== null) {
        this.key1 = args.key1;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.fileExt !== undefined && args.fileExt !== null) {
        this.fileExt = args.fileExt;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key1 = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.fileExt = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_addKeyToSecureStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.key1 !== null && this.key1 !== undefined) {
      output.writeFieldBegin('key1', Thrift.Type.STRING, 2);
      output.writeBinary(this.key1);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 4);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.fileExt !== null && this.fileExt !== undefined) {
      output.writeFieldBegin('fileExt', Thrift.Type.STRING, 5);
      output.writeString(this.fileExt);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_addKeyToSecureStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new PrivateKeyInfo(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new PrivateKeyInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_addKeyToSecureStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_removeKeyFromSecureStorage_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_removeKeyFromSecureStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_removeKeyFromSecureStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_removeKeyFromSecureStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getDigitalSignByAttachmentId_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getDigitalSignByAttachmentId_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_getDigitalSignByAttachmentId_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp331 = input.readMapBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            if (_i32 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key33 = null;
            let val34 = null;
            key33 = input.readString().value;
            val34 = input.readBool().value;
            this.success[key33] = val34;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_getDigitalSignByAttachmentId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.success));
      for (let kiter35 in this.success) {
        if (this.success.hasOwnProperty(kiter35)) {
          let viter36 = this.success[kiter35];
          output.writeString(kiter35);
          output.writeBool(viter36);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_addSignToAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.p7s = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.p7s !== undefined && args.p7s !== null) {
        this.p7s = Thrift.copyList(args.p7s, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.p7s = [];
          const _rtmp338 = input.readListBegin();
          const _size37 = _rtmp338.size || 0;
          for (let _i39 = 0; _i39 < _size37; ++_i39) {
            let elem40 = null;
            elem40 = input.readBinary().value;
            this.p7s.push(elem40);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_addSignToAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.p7s !== null && this.p7s !== undefined) {
      output.writeFieldBegin('p7s', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.p7s.length);
      for (let iter41 in this.p7s) {
        if (this.p7s.hasOwnProperty(iter41)) {
          iter41 = this.p7s[iter41];
          output.writeBinary(iter41);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignService_addSignToAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DsignService_addSignToAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DsignServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getTimeStampToken (token, data) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTimeStampToken(token, data, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTimeStampToken (token, data, callback) {
    const params = {
      token: token,
      data: data
    };
    const args = new DsignService_getTimeStampToken_args(params);
    try {
      this.output.writeMessageBegin('getTimeStampToken', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTimeStampToken();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTimeStampToken () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getTimeStampToken_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTimeStampToken failed: unknown result';
  }

  signAttachment (token, attachmentId, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_signAttachment(token, attachmentId, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_signAttachment (token, attachmentId, signature, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      signature: signature
    };
    const args = new DsignService_signAttachment_args(params);
    try {
      this.output.writeMessageBegin('signAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_signAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_signAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_signAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'signAttachment failed: unknown result';
  }

  signAttachmentUsingServerKeyStorage (token, attachmentId, pKeyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_signAttachmentUsingServerKeyStorage(token, attachmentId, pKeyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_signAttachmentUsingServerKeyStorage (token, attachmentId, pKeyId, password, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      pKeyId: pKeyId,
      password: password
    };
    const args = new DsignService_signAttachmentUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('signAttachmentUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_signAttachmentUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_signAttachmentUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_signAttachmentUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'signAttachmentUsingServerKeyStorage failed: unknown result';
  }

  getAllDigitalSigns (token, documentId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDigitalSigns(token, documentId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDigitalSigns (token, documentId, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter
    };
    const args = new DsignService_getAllDigitalSigns_args(params);
    try {
      this.output.writeMessageBegin('getAllDigitalSigns', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDigitalSigns();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDigitalSigns () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getAllDigitalSigns_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDigitalSigns failed: unknown result';
  }

  getCertificateInfo (token, digitalSignId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCertificateInfo(token, digitalSignId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCertificateInfo (token, digitalSignId, callback) {
    const params = {
      token: token,
      digitalSignId: digitalSignId
    };
    const args = new DsignService_getCertificateInfo_args(params);
    try {
      this.output.writeMessageBegin('getCertificateInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCertificateInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCertificateInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getCertificateInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCertificateInfo failed: unknown result';
  }

  getCertificateInfoListByUser (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCertificateInfoListByUser(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCertificateInfoListByUser (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new DsignService_getCertificateInfoListByUser_args(params);
    try {
      this.output.writeMessageBegin('getCertificateInfoListByUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCertificateInfoListByUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCertificateInfoListByUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getCertificateInfoListByUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCertificateInfoListByUser failed: unknown result';
  }

  getSignInfoByCertificate (token, data) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getSignInfoByCertificate(token, data, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getSignInfoByCertificate (token, data, callback) {
    const params = {
      token: token,
      data: data
    };
    const args = new DsignService_getSignInfoByCertificate_args(params);
    try {
      this.output.writeMessageBegin('getSignInfoByCertificate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getSignInfoByCertificate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getSignInfoByCertificate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getSignInfoByCertificate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getSignInfoByCertificate failed: unknown result';
  }

  getSignInfo (digitalSignId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getSignInfo(digitalSignId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getSignInfo (digitalSignId, callback) {
    const params = {
      digitalSignId: digitalSignId
    };
    const args = new DsignService_getSignInfo_args(params);
    try {
      this.output.writeMessageBegin('getSignInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getSignInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getSignInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getSignInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getSignInfo failed: unknown result';
  }

  getAllPrivateKeys (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllPrivateKeys(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllPrivateKeys (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DsignService_getAllPrivateKeys_args(params);
    try {
      this.output.writeMessageBegin('getAllPrivateKeys', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllPrivateKeys();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllPrivateKeys () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getAllPrivateKeys_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllPrivateKeys failed: unknown result';
  }

  getCountPrivateKeys (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountPrivateKeys(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountPrivateKeys (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DsignService_getCountPrivateKeys_args(params);
    try {
      this.output.writeMessageBegin('getCountPrivateKeys', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountPrivateKeys();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountPrivateKeys () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getCountPrivateKeys_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountPrivateKeys failed: unknown result';
  }

  addKeyToSecureStorage (token, key1, password, name, fileExt) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addKeyToSecureStorage(token, key1, password, name, fileExt, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addKeyToSecureStorage (token, key1, password, name, fileExt, callback) {
    const params = {
      token: token,
      key1: key1,
      password: password,
      name: name,
      fileExt: fileExt
    };
    const args = new DsignService_addKeyToSecureStorage_args(params);
    try {
      this.output.writeMessageBegin('addKeyToSecureStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addKeyToSecureStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addKeyToSecureStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_addKeyToSecureStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addKeyToSecureStorage failed: unknown result';
  }

  removeKeyFromSecureStorage (token, id) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeKeyFromSecureStorage(token, id, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeKeyFromSecureStorage (token, id, callback) {
    const params = {
      token: token,
      id: id
    };
    const args = new DsignService_removeKeyFromSecureStorage_args(params);
    try {
      this.output.writeMessageBegin('removeKeyFromSecureStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeKeyFromSecureStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeKeyFromSecureStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_removeKeyFromSecureStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeKeyFromSecureStorage failed: unknown result';
  }

  getDigitalSignByAttachmentId (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDigitalSignByAttachmentId(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDigitalSignByAttachmentId (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new DsignService_getDigitalSignByAttachmentId_args(params);
    try {
      this.output.writeMessageBegin('getDigitalSignByAttachmentId', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDigitalSignByAttachmentId();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDigitalSignByAttachmentId () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_getDigitalSignByAttachmentId_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.success) {
      return result.success;
    }
    throw 'getDigitalSignByAttachmentId failed: unknown result';
  }

  addSignToAttachment (token, attachmentId, p7s) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addSignToAttachment(token, attachmentId, p7s, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addSignToAttachment (token, attachmentId, p7s, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      p7s: p7s
    };
    const args = new DsignService_addSignToAttachment_args(params);
    try {
      this.output.writeMessageBegin('addSignToAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addSignToAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addSignToAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DsignService_addSignToAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addSignToAttachment failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

FilledDocumentPatternService_getFilledDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.filledDocumentPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filledDocumentPatternId !== undefined && args.filledDocumentPatternId !== null) {
        this.filledDocumentPatternId = args.filledDocumentPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.filledDocumentPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filledDocumentPatternId !== null && this.filledDocumentPatternId !== undefined) {
      output.writeFieldBegin('filledDocumentPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.filledDocumentPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFilledDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new FreezeDocumentPattern(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new FreezeDocumentPattern();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_createAndCheckFilledDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.freezeDocumentPattern = null;
    this.stages = null;
    this.toUpdate = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.freezeDocumentPattern !== undefined && args.freezeDocumentPattern !== null) {
        this.freezeDocumentPattern = new FreezeDocumentPattern(args.freezeDocumentPattern);
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.toUpdate !== undefined && args.toUpdate !== null) {
        this.toUpdate = Thrift.copyList(args.toUpdate, [PatternProcessRole]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.freezeDocumentPattern = new FreezeDocumentPattern();
          this.freezeDocumentPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new DocumentPatternStage();
            elem8.read(input);
            this.stages.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toUpdate = [];
          const _rtmp310 = input.readListBegin();
          const _size9 = _rtmp310.size || 0;
          for (let _i11 = 0; _i11 < _size9; ++_i11) {
            let elem12 = null;
            elem12 = new PatternProcessRole();
            elem12.read(input);
            this.toUpdate.push(elem12);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_createAndCheckFilledDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.freezeDocumentPattern !== null && this.freezeDocumentPattern !== undefined) {
      output.writeFieldBegin('freezeDocumentPattern', Thrift.Type.STRUCT, 2);
      this.freezeDocumentPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter13 in this.stages) {
        if (this.stages.hasOwnProperty(iter13)) {
          iter13 = this.stages[iter13];
          iter13.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toUpdate !== null && this.toUpdate !== undefined) {
      output.writeFieldBegin('toUpdate', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.toUpdate.length);
      for (let iter14 in this.toUpdate) {
        if (this.toUpdate.hasOwnProperty(iter14)) {
          iter14 = this.toUpdate[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_createAndCheckFilledDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new FreezePatternValidation(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new FreezePatternValidation();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_createAndCheckFilledDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_deleteFilledDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.filledDocumentPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filledDocumentPatternId !== undefined && args.filledDocumentPatternId !== null) {
        this.filledDocumentPatternId = args.filledDocumentPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.filledDocumentPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_deleteFilledDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filledDocumentPatternId !== null && this.filledDocumentPatternId !== undefined) {
      output.writeFieldBegin('filledDocumentPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.filledDocumentPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_deleteFilledDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_deleteFilledDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.filter = null;
    this.selector = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.selector !== undefined && args.selector !== null) {
        this.selector = args.selector;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.selector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.selector !== null && this.selector !== undefined) {
      output.writeFieldBegin('selector', Thrift.Type.I32, 4);
      output.writeI32(this.selector);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new DocumentPatternStage();
            elem18.read(input);
            this.success.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter19 in this.success) {
        if (this.success.hasOwnProperty(iter19)) {
          iter19 = this.success[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFilledDocumentPatternStage_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.stageId = null;
    this.selector = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.selector !== undefined && args.selector !== null) {
        this.selector = args.selector;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.selector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPatternStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.selector !== null && this.selector !== undefined) {
      output.writeFieldBegin('selector', Thrift.Type.I32, 4);
      output.writeI32(this.selector);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 5);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFilledDocumentPatternStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentPatternStage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentPatternStage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPatternStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getSetDecisionInfo_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.freezeLinkId = null;
    this.selector = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.freezeLinkId !== undefined && args.freezeLinkId !== null) {
        this.freezeLinkId = args.freezeLinkId;
      }
      if (args.selector !== undefined && args.selector !== null) {
        this.selector = args.selector;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.freezeLinkId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.selector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getSetDecisionInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.freezeLinkId !== null && this.freezeLinkId !== undefined) {
      output.writeFieldBegin('freezeLinkId', Thrift.Type.STRING, 3);
      output.writeString(this.freezeLinkId);
      output.writeFieldEnd();
    }
    if (this.selector !== null && this.selector !== undefined) {
      output.writeFieldBegin('selector', Thrift.Type.I32, 4);
      output.writeI32(this.selector);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 5);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getSetDecisionInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DesicionInfo(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DesicionInfo();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getSetDecisionInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.stageId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new DocumentPatternStage();
            elem23.read(input);
            this.success.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter24 in this.success) {
        if (this.success.hasOwnProperty(iter24)) {
          iter24 = this.success[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFilledDocumentPatternStageList_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.documentPatternStage = null;
    this.enEditCurrent = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.documentPatternStage !== undefined && args.documentPatternStage !== null) {
        this.documentPatternStage = Thrift.copyList(args.documentPatternStage, [DocumentPatternStage]);
      }
      if (args.enEditCurrent !== undefined && args.enEditCurrent !== null) {
        this.enEditCurrent = args.enEditCurrent;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentPatternStage = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new DocumentPatternStage();
            elem28.read(input);
            this.documentPatternStage.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.enEditCurrent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFilledDocumentPatternStageList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.documentPatternStage !== null && this.documentPatternStage !== undefined) {
      output.writeFieldBegin('documentPatternStage', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentPatternStage.length);
      for (let iter29 in this.documentPatternStage) {
        if (this.documentPatternStage.hasOwnProperty(iter29)) {
          iter29 = this.documentPatternStage[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.enEditCurrent !== null && this.enEditCurrent !== undefined) {
      output.writeFieldBegin('enEditCurrent', Thrift.Type.BOOL, 4);
      output.writeBool(this.enEditCurrent);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFilledDocumentPatternStageList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new DocumentPatternStage();
            elem33.read(input);
            this.success.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFilledDocumentPatternStageList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter34 in this.success) {
        if (this.success.hasOwnProperty(iter34)) {
          iter34 = this.success[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.links = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.links !== undefined && args.links !== null) {
        this.links = Thrift.copyList(args.links, [DocumentPatternStagesLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.links = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new DocumentPatternStagesLink();
            elem38.read(input);
            this.links.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.links !== null && this.links !== undefined) {
      output.writeFieldBegin('links', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.links.length);
      for (let iter39 in this.links) {
        if (this.links.hasOwnProperty(iter39)) {
          iter39 = this.links[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStagesLink]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = new DocumentPatternStagesLink();
            elem43.read(input);
            this.success.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter44 in this.success) {
        if (this.success.hasOwnProperty(iter44)) {
          iter44 = this.success[iter44];
          iter44.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStagesLink]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp346 = input.readListBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = new DocumentPatternStagesLink();
            elem48.read(input);
            this.success.push(elem48);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter49 in this.success) {
        if (this.success.hasOwnProperty(iter49)) {
          iter49 = this.success[iter49];
          iter49.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.stageId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStagesExecutor]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp351 = input.readListBegin();
          const _size50 = _rtmp351.size || 0;
          for (let _i52 = 0; _i52 < _size50; ++_i52) {
            let elem53 = null;
            elem53 = new DocumentPatternStagesExecutor();
            elem53.read(input);
            this.success.push(elem53);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter54 in this.success) {
        if (this.success.hasOwnProperty(iter54)) {
          iter54 = this.success[iter54];
          iter54.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.stageIds = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.stageIds !== undefined && args.stageIds !== null) {
        this.stageIds = Thrift.copyList(args.stageIds, [null]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.stageIds = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = input.readString().value;
            this.stageIds.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.stageIds !== null && this.stageIds !== undefined) {
      output.writeFieldBegin('stageIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.stageIds.length);
      for (let iter59 in this.stageIds) {
        if (this.stageIds.hasOwnProperty(iter59)) {
          iter59 = this.stageIds[iter59];
          output.writeString(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [Thrift.copyList, DocumentPatternStagesExecutor]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp361 = input.readMapBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            if (_i62 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key63 = null;
            let val64 = null;
            key63 = input.readString().value;
            val64 = [];
            const _rtmp366 = input.readListBegin();
            const _size65 = _rtmp366.size || 0;
            for (let _i67 = 0; _i67 < _size65; ++_i67) {
              let elem68 = null;
              elem68 = new DocumentPatternStagesExecutor();
              elem68.read(input);
              val64.push(elem68);
            }
            input.readListEnd();
            this.success[key63] = val64;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
      for (let kiter69 in this.success) {
        if (this.success.hasOwnProperty(kiter69)) {
          let viter70 = this.success[kiter69];
          output.writeString(kiter69);
          output.writeListBegin(Thrift.Type.STRUCT, viter70.length);
          for (let iter71 in viter70) {
            if (viter70.hasOwnProperty(iter71)) {
              iter71 = viter70[iter71];
              iter71.write(output);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFilledDocumentPatternStages_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.stages = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp373 = input.readListBegin();
          const _size72 = _rtmp373.size || 0;
          for (let _i74 = 0; _i74 < _size72; ++_i74) {
            let elem75 = null;
            elem75 = new DocumentPatternStage();
            elem75.read(input);
            this.stages.push(elem75);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFilledDocumentPatternStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter76 in this.stages) {
        if (this.stages.hasOwnProperty(iter76)) {
          iter76 = this.stages[iter76];
          iter76.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFilledDocumentPatternStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFilledDocumentPatternStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_checkFilledDocumentPattern_args = class {
  constructor(args) {
    this.token = null;
    this.fillDocPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.fillDocPatternId !== undefined && args.fillDocPatternId !== null) {
        this.fillDocPatternId = args.fillDocPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fillDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_checkFilledDocumentPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.fillDocPatternId !== null && this.fillDocPatternId !== undefined) {
      output.writeFieldBegin('fillDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.fillDocPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_checkFilledDocumentPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp378 = input.readListBegin();
          const _size77 = _rtmp378.size || 0;
          for (let _i79 = 0; _i79 < _size77; ++_i79) {
            let elem80 = null;
            elem80 = new PreconditionException();
            elem80.read(input);
            this.success.push(elem80);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_checkFilledDocumentPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter81 in this.success) {
        if (this.success.hasOwnProperty(iter81)) {
          iter81 = this.success[iter81];
          iter81.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_args = class {
  constructor(args) {
    this.token = null;
    this.freezeDocPatternId = null;
    this.meetingId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.freezeDocPatternId !== undefined && args.freezeDocPatternId !== null) {
        this.freezeDocPatternId = args.freezeDocPatternId;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.freezeDocPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.freezeDocPatternId !== null && this.freezeDocPatternId !== undefined) {
      output.writeFieldBegin('freezeDocPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.freezeDocPatternId);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 3);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFreezeProcessRoles_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.policy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFreezeProcessRoles_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 3);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFreezeProcessRoles_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternProcessRole]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp383 = input.readListBegin();
          const _size82 = _rtmp383.size || 0;
          for (let _i84 = 0; _i84 < _size82; ++_i84) {
            let elem85 = null;
            elem85 = new PatternProcessRole();
            elem85.read(input);
            this.success.push(elem85);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFreezeProcessRoles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter86 in this.success) {
        if (this.success.hasOwnProperty(iter86)) {
          iter86 = this.success[iter86];
          iter86.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFreezeProcessRoles_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.policy = null;
    this.patternRolesToAdd = null;
    this.keyIdToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
      if (args.patternRolesToAdd !== undefined && args.patternRolesToAdd !== null) {
        this.patternRolesToAdd = Thrift.copyList(args.patternRolesToAdd, [PatternProcessRole]);
      }
      if (args.keyIdToRemove !== undefined && args.keyIdToRemove !== null) {
        this.keyIdToRemove = Thrift.copyList(args.keyIdToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.patternRolesToAdd = [];
          const _rtmp388 = input.readListBegin();
          const _size87 = _rtmp388.size || 0;
          for (let _i89 = 0; _i89 < _size87; ++_i89) {
            let elem90 = null;
            elem90 = new PatternProcessRole();
            elem90.read(input);
            this.patternRolesToAdd.push(elem90);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.keyIdToRemove = [];
          const _rtmp392 = input.readSetBegin();
          const _size91 = _rtmp392.size || 0;
          for (let _i93 = 0; _i93 < _size91; ++_i93) {
            let elem94 = null;
            elem94 = input.readString().value;
            this.keyIdToRemove.push(elem94);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFreezeProcessRoles_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 3);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    if (this.patternRolesToAdd !== null && this.patternRolesToAdd !== undefined) {
      output.writeFieldBegin('patternRolesToAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternRolesToAdd.length);
      for (let iter95 in this.patternRolesToAdd) {
        if (this.patternRolesToAdd.hasOwnProperty(iter95)) {
          iter95 = this.patternRolesToAdd[iter95];
          iter95.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.keyIdToRemove !== null && this.keyIdToRemove !== undefined) {
      output.writeFieldBegin('keyIdToRemove', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.keyIdToRemove.length);
      for (let iter96 in this.keyIdToRemove) {
        if (this.keyIdToRemove.hasOwnProperty(iter96)) {
          iter96 = this.keyIdToRemove[iter96];
          output.writeString(iter96);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFreezeProcessRoles_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternProcessRole]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp398 = input.readListBegin();
          const _size97 = _rtmp398.size || 0;
          for (let _i99 = 0; _i99 < _size97; ++_i99) {
            let elem100 = null;
            elem100 = new PatternProcessRole();
            elem100.read(input);
            this.success.push(elem100);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFreezeProcessRoles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter101 in this.success) {
        if (this.success.hasOwnProperty(iter101)) {
          iter101 = this.success[iter101];
          iter101.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFreezeProcessVariables_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.policy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFreezeProcessVariables_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 3);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_getFreezeProcessVariables_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternVariable]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3103 = input.readListBegin();
          const _size102 = _rtmp3103.size || 0;
          for (let _i104 = 0; _i104 < _size102; ++_i104) {
            let elem105 = null;
            elem105 = new PatternVariable();
            elem105.read(input);
            this.success.push(elem105);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_getFreezeProcessVariables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter106 in this.success) {
        if (this.success.hasOwnProperty(iter106)) {
          iter106 = this.success[iter106];
          iter106.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFreezePatternVariables_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.policy = null;
    this.patternVariablesToAdd = null;
    this.keyIdToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
      if (args.patternVariablesToAdd !== undefined && args.patternVariablesToAdd !== null) {
        this.patternVariablesToAdd = Thrift.copyList(args.patternVariablesToAdd, [PatternVariable]);
      }
      if (args.keyIdToRemove !== undefined && args.keyIdToRemove !== null) {
        this.keyIdToRemove = Thrift.copyList(args.keyIdToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.patternVariablesToAdd = [];
          const _rtmp3108 = input.readListBegin();
          const _size107 = _rtmp3108.size || 0;
          for (let _i109 = 0; _i109 < _size107; ++_i109) {
            let elem110 = null;
            elem110 = new PatternVariable();
            elem110.read(input);
            this.patternVariablesToAdd.push(elem110);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.keyIdToRemove = [];
          const _rtmp3112 = input.readSetBegin();
          const _size111 = _rtmp3112.size || 0;
          for (let _i113 = 0; _i113 < _size111; ++_i113) {
            let elem114 = null;
            elem114 = input.readString().value;
            this.keyIdToRemove.push(elem114);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFreezePatternVariables_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 3);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    if (this.patternVariablesToAdd !== null && this.patternVariablesToAdd !== undefined) {
      output.writeFieldBegin('patternVariablesToAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternVariablesToAdd.length);
      for (let iter115 in this.patternVariablesToAdd) {
        if (this.patternVariablesToAdd.hasOwnProperty(iter115)) {
          iter115 = this.patternVariablesToAdd[iter115];
          iter115.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.keyIdToRemove !== null && this.keyIdToRemove !== undefined) {
      output.writeFieldBegin('keyIdToRemove', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.keyIdToRemove.length);
      for (let iter116 in this.keyIdToRemove) {
        if (this.keyIdToRemove.hasOwnProperty(iter116)) {
          iter116 = this.keyIdToRemove[iter116];
          output.writeString(iter116);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternService_changeFreezePatternVariables_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PatternVariable]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3118 = input.readListBegin();
          const _size117 = _rtmp3118.size || 0;
          for (let _i119 = 0; _i119 < _size117; ++_i119) {
            let elem120 = null;
            elem120 = new PatternVariable();
            elem120.read(input);
            this.success.push(elem120);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilledDocumentPatternService_changeFreezePatternVariables_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter121 in this.success) {
        if (this.success.hasOwnProperty(iter121)) {
          iter121 = this.success[iter121];
          iter121.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilledDocumentPatternServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getFilledDocumentPattern (token, filledDocumentPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFilledDocumentPattern(token, filledDocumentPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFilledDocumentPattern (token, filledDocumentPatternId, callback) {
    const params = {
      token: token,
      filledDocumentPatternId: filledDocumentPatternId
    };
    const args = new FilledDocumentPatternService_getFilledDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('getFilledDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFilledDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFilledDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getFilledDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFilledDocumentPattern failed: unknown result';
  }

  createAndCheckFilledDocumentPattern (token, freezeDocumentPattern, stages, toUpdate) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createAndCheckFilledDocumentPattern(token, freezeDocumentPattern, stages, toUpdate, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createAndCheckFilledDocumentPattern (token, freezeDocumentPattern, stages, toUpdate, callback) {
    const params = {
      token: token,
      freezeDocumentPattern: freezeDocumentPattern,
      stages: stages,
      toUpdate: toUpdate
    };
    const args = new FilledDocumentPatternService_createAndCheckFilledDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('createAndCheckFilledDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createAndCheckFilledDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createAndCheckFilledDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_createAndCheckFilledDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createAndCheckFilledDocumentPattern failed: unknown result';
  }

  deleteFilledDocumentPattern (token, filledDocumentPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteFilledDocumentPattern(token, filledDocumentPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteFilledDocumentPattern (token, filledDocumentPatternId, callback) {
    const params = {
      token: token,
      filledDocumentPatternId: filledDocumentPatternId
    };
    const args = new FilledDocumentPatternService_deleteFilledDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('deleteFilledDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteFilledDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteFilledDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_deleteFilledDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteFilledDocumentPattern failed: unknown result';
  }

  getAllFilledDocumentPatternStages (token, fillDocPatternId, filter, selector) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllFilledDocumentPatternStages(token, fillDocPatternId, filter, selector, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllFilledDocumentPatternStages (token, fillDocPatternId, filter, selector, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      filter: filter,
      selector: selector
    };
    const args = new FilledDocumentPatternService_getAllFilledDocumentPatternStages_args(params);
    try {
      this.output.writeMessageBegin('getAllFilledDocumentPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllFilledDocumentPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllFilledDocumentPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getAllFilledDocumentPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllFilledDocumentPatternStages failed: unknown result';
  }

  getFilledDocumentPatternStage (token, fillDocPatternId, stageId, selector, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFilledDocumentPatternStage(token, fillDocPatternId, stageId, selector, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFilledDocumentPatternStage (token, fillDocPatternId, stageId, selector, policy, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      stageId: stageId,
      selector: selector,
      policy: policy
    };
    const args = new FilledDocumentPatternService_getFilledDocumentPatternStage_args(params);
    try {
      this.output.writeMessageBegin('getFilledDocumentPatternStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFilledDocumentPatternStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFilledDocumentPatternStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getFilledDocumentPatternStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFilledDocumentPatternStage failed: unknown result';
  }

  getSetDecisionInfo (token, fillDocPatternId, freezeLinkId, selector, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getSetDecisionInfo(token, fillDocPatternId, freezeLinkId, selector, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getSetDecisionInfo (token, fillDocPatternId, freezeLinkId, selector, policy, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      freezeLinkId: freezeLinkId,
      selector: selector,
      policy: policy
    };
    const args = new FilledDocumentPatternService_getSetDecisionInfo_args(params);
    try {
      this.output.writeMessageBegin('getSetDecisionInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getSetDecisionInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getSetDecisionInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getSetDecisionInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getSetDecisionInfo failed: unknown result';
  }

  getAllChildFilledDocumentPatternStages (token, fillDocPatternId, stageId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllChildFilledDocumentPatternStages(token, fillDocPatternId, stageId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllChildFilledDocumentPatternStages (token, fillDocPatternId, stageId, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      stageId: stageId
    };
    const args = new FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_args(params);
    try {
      this.output.writeMessageBegin('getAllChildFilledDocumentPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllChildFilledDocumentPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllChildFilledDocumentPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getAllChildFilledDocumentPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllChildFilledDocumentPatternStages failed: unknown result';
  }

  updateFilledDocumentPatternStageList (token, fillDocPatternId, documentPatternStage, enEditCurrent) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateFilledDocumentPatternStageList(token, fillDocPatternId, documentPatternStage, enEditCurrent, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateFilledDocumentPatternStageList (token, fillDocPatternId, documentPatternStage, enEditCurrent, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      documentPatternStage: documentPatternStage,
      enEditCurrent: enEditCurrent
    };
    const args = new FilledDocumentPatternService_updateFilledDocumentPatternStageList_args(params);
    try {
      this.output.writeMessageBegin('updateFilledDocumentPatternStageList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateFilledDocumentPatternStageList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateFilledDocumentPatternStageList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_updateFilledDocumentPatternStageList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateFilledDocumentPatternStageList failed: unknown result';
  }

  updateFilledDocumentPatternStagesLink (token, fillDocPatternId, links) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateFilledDocumentPatternStagesLink(token, fillDocPatternId, links, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateFilledDocumentPatternStagesLink (token, fillDocPatternId, links, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      links: links
    };
    const args = new FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_args(params);
    try {
      this.output.writeMessageBegin('updateFilledDocumentPatternStagesLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateFilledDocumentPatternStagesLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateFilledDocumentPatternStagesLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_updateFilledDocumentPatternStagesLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateFilledDocumentPatternStagesLink failed: unknown result';
  }

  getAllFilledDocumentPatternStagesLink (token, fillDocPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllFilledDocumentPatternStagesLink(token, fillDocPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllFilledDocumentPatternStagesLink (token, fillDocPatternId, filter, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      filter: filter
    };
    const args = new FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_args(params);
    try {
      this.output.writeMessageBegin('getAllFilledDocumentPatternStagesLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllFilledDocumentPatternStagesLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllFilledDocumentPatternStagesLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getAllFilledDocumentPatternStagesLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllFilledDocumentPatternStagesLink failed: unknown result';
  }

  getAllFilledDocumentPatternStageExecutors (token, fillDocPatternId, stageId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllFilledDocumentPatternStageExecutors(token, fillDocPatternId, stageId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllFilledDocumentPatternStageExecutors (token, fillDocPatternId, stageId, filter, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      stageId: stageId,
      filter: filter
    };
    const args = new FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_args(params);
    try {
      this.output.writeMessageBegin('getAllFilledDocumentPatternStageExecutors', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllFilledDocumentPatternStageExecutors();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllFilledDocumentPatternStageExecutors () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getAllFilledDocumentPatternStageExecutors_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllFilledDocumentPatternStageExecutors failed: unknown result';
  }

  getFilledDocumentPatternStagesExecutors (token, fillDocPatternId, stageIds, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFilledDocumentPatternStagesExecutors(token, fillDocPatternId, stageIds, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFilledDocumentPatternStagesExecutors (token, fillDocPatternId, stageIds, filter, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      stageIds: stageIds,
      filter: filter
    };
    const args = new FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_args(params);
    try {
      this.output.writeMessageBegin('getFilledDocumentPatternStagesExecutors', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFilledDocumentPatternStagesExecutors();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFilledDocumentPatternStagesExecutors () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getFilledDocumentPatternStagesExecutors_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFilledDocumentPatternStagesExecutors failed: unknown result';
  }

  changeFilledDocumentPatternStages (token, fillDocPatternId, stages) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeFilledDocumentPatternStages(token, fillDocPatternId, stages, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeFilledDocumentPatternStages (token, fillDocPatternId, stages, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      stages: stages
    };
    const args = new FilledDocumentPatternService_changeFilledDocumentPatternStages_args(params);
    try {
      this.output.writeMessageBegin('changeFilledDocumentPatternStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeFilledDocumentPatternStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeFilledDocumentPatternStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_changeFilledDocumentPatternStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeFilledDocumentPatternStages failed: unknown result';
  }

  checkFilledDocumentPattern (token, fillDocPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_checkFilledDocumentPattern(token, fillDocPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_checkFilledDocumentPattern (token, fillDocPatternId, filter, callback) {
    const params = {
      token: token,
      fillDocPatternId: fillDocPatternId,
      filter: filter
    };
    const args = new FilledDocumentPatternService_checkFilledDocumentPattern_args(params);
    try {
      this.output.writeMessageBegin('checkFilledDocumentPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_checkFilledDocumentPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_checkFilledDocumentPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_checkFilledDocumentPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'checkFilledDocumentPattern failed: unknown result';
  }

  updateFreezeDocumentPatternMeeting (token, freezeDocPatternId, meetingId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateFreezeDocumentPatternMeeting(token, freezeDocPatternId, meetingId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateFreezeDocumentPatternMeeting (token, freezeDocPatternId, meetingId, callback) {
    const params = {
      token: token,
      freezeDocPatternId: freezeDocPatternId,
      meetingId: meetingId
    };
    const args = new FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_args(params);
    try {
      this.output.writeMessageBegin('updateFreezeDocumentPatternMeeting', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateFreezeDocumentPatternMeeting();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateFreezeDocumentPatternMeeting () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_updateFreezeDocumentPatternMeeting_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateFreezeDocumentPatternMeeting failed: unknown result';
  }

  getFreezeProcessRoles (token, docId, policy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFreezeProcessRoles(token, docId, policy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFreezeProcessRoles (token, docId, policy, filter, callback) {
    const params = {
      token: token,
      docId: docId,
      policy: policy,
      filter: filter
    };
    const args = new FilledDocumentPatternService_getFreezeProcessRoles_args(params);
    try {
      this.output.writeMessageBegin('getFreezeProcessRoles', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFreezeProcessRoles();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFreezeProcessRoles () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getFreezeProcessRoles_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFreezeProcessRoles failed: unknown result';
  }

  changeFreezeProcessRoles (token, docId, policy, patternRolesToAdd, keyIdToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeFreezeProcessRoles(token, docId, policy, patternRolesToAdd, keyIdToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeFreezeProcessRoles (token, docId, policy, patternRolesToAdd, keyIdToRemove, callback) {
    const params = {
      token: token,
      docId: docId,
      policy: policy,
      patternRolesToAdd: patternRolesToAdd,
      keyIdToRemove: keyIdToRemove
    };
    const args = new FilledDocumentPatternService_changeFreezeProcessRoles_args(params);
    try {
      this.output.writeMessageBegin('changeFreezeProcessRoles', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeFreezeProcessRoles();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeFreezeProcessRoles () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_changeFreezeProcessRoles_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeFreezeProcessRoles failed: unknown result';
  }

  getFreezeProcessVariables (token, docId, policy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFreezeProcessVariables(token, docId, policy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFreezeProcessVariables (token, docId, policy, filter, callback) {
    const params = {
      token: token,
      docId: docId,
      policy: policy,
      filter: filter
    };
    const args = new FilledDocumentPatternService_getFreezeProcessVariables_args(params);
    try {
      this.output.writeMessageBegin('getFreezeProcessVariables', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFreezeProcessVariables();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFreezeProcessVariables () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_getFreezeProcessVariables_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFreezeProcessVariables failed: unknown result';
  }

  changeFreezePatternVariables (token, docId, policy, patternVariablesToAdd, keyIdToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeFreezePatternVariables(token, docId, policy, patternVariablesToAdd, keyIdToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeFreezePatternVariables (token, docId, policy, patternVariablesToAdd, keyIdToRemove, callback) {
    const params = {
      token: token,
      docId: docId,
      policy: policy,
      patternVariablesToAdd: patternVariablesToAdd,
      keyIdToRemove: keyIdToRemove
    };
    const args = new FilledDocumentPatternService_changeFreezePatternVariables_args(params);
    try {
      this.output.writeMessageBegin('changeFreezePatternVariables', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeFreezePatternVariables();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeFreezePatternVariables () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilledDocumentPatternService_changeFreezePatternVariables_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeFreezePatternVariables failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

FilterService_getAllCustomFields_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllCustomFields_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllCustomFields_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [FilterField]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = new FilterField();
            elem20.read(input);
            this.success.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllCustomFields_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter21 in this.success) {
        if (this.success.hasOwnProperty(iter21)) {
          iter21 = this.success[iter21];
          iter21.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomField_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new FilterField(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new FilterField();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomField_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomField_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new FilterField(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new FilterField();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomField_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomField_args = class {
  constructor(args) {
    this.token = null;
    this.filterId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filterId !== undefined && args.filterId !== null) {
        this.filterId = args.filterId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.filterId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomField_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filterId !== null && this.filterId !== undefined) {
      output.writeFieldBegin('filterId', Thrift.Type.STRING, 2);
      output.writeString(this.filterId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomField_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomField_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllCustomDocFilters_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.personal = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.personal !== undefined && args.personal !== null) {
        this.personal = args.personal;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.personal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllCustomDocFilters_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.personal !== null && this.personal !== undefined) {
      output.writeFieldBegin('personal', Thrift.Type.BOOL, 3);
      output.writeBool(this.personal);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllCustomDocFilters_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocFilter]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp323 = input.readListBegin();
          const _size22 = _rtmp323.size || 0;
          for (let _i24 = 0; _i24 < _size22; ++_i24) {
            let elem25 = null;
            elem25 = new DocFilter();
            elem25.read(input);
            this.success.push(elem25);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllCustomDocFilters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter26 in this.success) {
        if (this.success.hasOwnProperty(iter26)) {
          iter26 = this.success[iter26];
          iter26.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomDocFilter_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.customFilterItems = null;
    this.filterFieldsWithPosition = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new DocFilter(args.filter);
      }
      if (args.customFilterItems !== undefined && args.customFilterItems !== null) {
        this.customFilterItems = Thrift.copyList(args.customFilterItems, [null]);
      }
      if (args.filterFieldsWithPosition !== undefined && args.filterFieldsWithPosition !== null) {
        this.filterFieldsWithPosition = Thrift.copyMap(args.filterFieldsWithPosition, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new DocFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.customFilterItems = [];
          const _rtmp328 = input.readListBegin();
          const _size27 = _rtmp328.size || 0;
          for (let _i29 = 0; _i29 < _size27; ++_i29) {
            let elem30 = null;
            elem30 = input.readString().value;
            this.customFilterItems.push(elem30);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.filterFieldsWithPosition = {};
          const _rtmp332 = input.readMapBegin();
          const _size31 = _rtmp332.size || 0;
          for (let _i33 = 0; _i33 < _size31; ++_i33) {
            if (_i33 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key34 = null;
            let val35 = null;
            key34 = input.readI32().value;
            val35 = input.readString().value;
            this.filterFieldsWithPosition[key34] = val35;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomDocFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.customFilterItems !== null && this.customFilterItems !== undefined) {
      output.writeFieldBegin('customFilterItems', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.customFilterItems.length);
      for (let iter36 in this.customFilterItems) {
        if (this.customFilterItems.hasOwnProperty(iter36)) {
          iter36 = this.customFilterItems[iter36];
          output.writeString(iter36);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.filterFieldsWithPosition !== null && this.filterFieldsWithPosition !== undefined) {
      output.writeFieldBegin('filterFieldsWithPosition', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRING, Thrift.objectLength(this.filterFieldsWithPosition));
      for (let kiter37 in this.filterFieldsWithPosition) {
        if (this.filterFieldsWithPosition.hasOwnProperty(kiter37)) {
          let viter38 = this.filterFieldsWithPosition[kiter37];
          output.writeI32(kiter37);
          output.writeString(viter38);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomDocFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocFilter(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocFilter();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomDocFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomDocFilter_args = class {
  constructor(args) {
    this.token = null;
    this.docFilterId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docFilterId !== undefined && args.docFilterId !== null) {
        this.docFilterId = args.docFilterId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docFilterId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomDocFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docFilterId !== null && this.docFilterId !== undefined) {
      output.writeFieldBegin('docFilterId', Thrift.Type.STRING, 2);
      output.writeString(this.docFilterId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomDocFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomDocFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomFilterItem_args = class {
  constructor(args) {
    this.token = null;
    this.filterItem = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filterItem !== undefined && args.filterItem !== null) {
        this.filterItem = new CustomFilterItem(args.filterItem);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filterItem = new CustomFilterItem();
          this.filterItem.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomFilterItem_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filterItem !== null && this.filterItem !== undefined) {
      output.writeFieldBegin('filterItem', Thrift.Type.STRUCT, 2);
      this.filterItem.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateCustomFilterItem_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new CustomFilterItem(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new CustomFilterItem();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateCustomFilterItem_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomFilterItem_args = class {
  constructor(args) {
    this.token = null;
    this.filterItemId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filterItemId !== undefined && args.filterItemId !== null) {
        this.filterItemId = args.filterItemId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.filterItemId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomFilterItem_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filterItemId !== null && this.filterItemId !== undefined) {
      output.writeFieldBegin('filterItemId', Thrift.Type.STRING, 2);
      output.writeString(this.filterItemId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeCustomFilterItem_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeCustomFilterItem_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_addDocFiltersToUserGroups_args = class {
  constructor(args) {
    this.token = null;
    this.docFilterIds = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docFilterIds !== undefined && args.docFilterIds !== null) {
        this.docFilterIds = Thrift.copyList(args.docFilterIds, [null]);
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.docFilterIds = [];
          const _rtmp340 = input.readListBegin();
          const _size39 = _rtmp340.size || 0;
          for (let _i41 = 0; _i41 < _size39; ++_i41) {
            let elem42 = null;
            elem42 = input.readString().value;
            this.docFilterIds.push(elem42);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp344 = input.readListBegin();
          const _size43 = _rtmp344.size || 0;
          for (let _i45 = 0; _i45 < _size43; ++_i45) {
            let elem46 = null;
            elem46 = new UserOrGroup();
            elem46.read(input);
            this.userOrGroups.push(elem46);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_addDocFiltersToUserGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docFilterIds !== null && this.docFilterIds !== undefined) {
      output.writeFieldBegin('docFilterIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.docFilterIds.length);
      for (let iter47 in this.docFilterIds) {
        if (this.docFilterIds.hasOwnProperty(iter47)) {
          iter47 = this.docFilterIds[iter47];
          output.writeString(iter47);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter48 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter48)) {
          iter48 = this.userOrGroups[iter48];
          iter48.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_addDocFiltersToUserGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_addDocFiltersToUserGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeDocFiltersFromUserGroups_args = class {
  constructor(args) {
    this.token = null;
    this.docFilterIds = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docFilterIds !== undefined && args.docFilterIds !== null) {
        this.docFilterIds = Thrift.copyList(args.docFilterIds, [null]);
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.docFilterIds = [];
          const _rtmp350 = input.readListBegin();
          const _size49 = _rtmp350.size || 0;
          for (let _i51 = 0; _i51 < _size49; ++_i51) {
            let elem52 = null;
            elem52 = input.readString().value;
            this.docFilterIds.push(elem52);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp354 = input.readListBegin();
          const _size53 = _rtmp354.size || 0;
          for (let _i55 = 0; _i55 < _size53; ++_i55) {
            let elem56 = null;
            elem56 = new UserOrGroup();
            elem56.read(input);
            this.userOrGroups.push(elem56);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeDocFiltersFromUserGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docFilterIds !== null && this.docFilterIds !== undefined) {
      output.writeFieldBegin('docFilterIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.docFilterIds.length);
      for (let iter57 in this.docFilterIds) {
        if (this.docFilterIds.hasOwnProperty(iter57)) {
          iter57 = this.docFilterIds[iter57];
          output.writeString(iter57);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter58 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter58)) {
          iter58 = this.userOrGroups[iter58];
          iter58.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_removeDocFiltersFromUserGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_removeDocFiltersFromUserGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllDocFiltersByUserOrGroup_args = class {
  constructor(args) {
    this.token = null;
    this.type = null;
    this.userOrGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllDocFiltersByUserOrGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 2);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 3);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllDocFiltersByUserOrGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocFilter]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp360 = input.readListBegin();
          const _size59 = _rtmp360.size || 0;
          for (let _i61 = 0; _i61 < _size59; ++_i61) {
            let elem62 = null;
            elem62 = new DocFilter();
            elem62.read(input);
            this.success.push(elem62);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllDocFiltersByUserOrGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter63 in this.success) {
        if (this.success.hasOwnProperty(iter63)) {
          iter63 = this.success[iter63];
          iter63.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllUserOrGroupsByDocFilterId_args = class {
  constructor(args) {
    this.token = null;
    this.docFilterId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docFilterId !== undefined && args.docFilterId !== null) {
        this.docFilterId = args.docFilterId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docFilterId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllUserOrGroupsByDocFilterId_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docFilterId !== null && this.docFilterId !== undefined) {
      output.writeFieldBegin('docFilterId', Thrift.Type.STRING, 2);
      output.writeString(this.docFilterId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getAllUserOrGroupsByDocFilterId_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp365 = input.readListBegin();
          const _size64 = _rtmp365.size || 0;
          for (let _i66 = 0; _i66 < _size64; ++_i66) {
            let elem67 = null;
            elem67 = new UserOrGroup();
            elem67.read(input);
            this.success.push(elem67);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getAllUserOrGroupsByDocFilterId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter68 in this.success) {
        if (this.success.hasOwnProperty(iter68)) {
          iter68 = this.success[iter68];
          iter68.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_exportDocFilters_args = class {
  constructor(args) {
    this.token = null;
    this.docFilterIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docFilterIds !== undefined && args.docFilterIds !== null) {
        this.docFilterIds = Thrift.copyList(args.docFilterIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.docFilterIds = [];
          const _rtmp370 = input.readListBegin();
          const _size69 = _rtmp370.size || 0;
          for (let _i71 = 0; _i71 < _size69; ++_i71) {
            let elem72 = null;
            elem72 = input.readString().value;
            this.docFilterIds.push(elem72);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_exportDocFilters_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docFilterIds !== null && this.docFilterIds !== undefined) {
      output.writeFieldBegin('docFilterIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.docFilterIds.length);
      for (let iter73 in this.docFilterIds) {
        if (this.docFilterIds.hasOwnProperty(iter73)) {
          iter73 = this.docFilterIds[iter73];
          output.writeString(iter73);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_exportDocFilters_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_exportDocFilters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_importDocFilters_args = class {
  constructor(args) {
    this.token = null;
    this.json = null;
    this.clearExistFilters = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.json !== undefined && args.json !== null) {
        this.json = args.json;
      }
      if (args.clearExistFilters !== undefined && args.clearExistFilters !== null) {
        this.clearExistFilters = args.clearExistFilters;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.json = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.clearExistFilters = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_importDocFilters_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.json !== null && this.json !== undefined) {
      output.writeFieldBegin('json', Thrift.Type.STRING, 2);
      output.writeBinary(this.json);
      output.writeFieldEnd();
    }
    if (this.clearExistFilters !== null && this.clearExistFilters !== undefined) {
      output.writeFieldBegin('clearExistFilters', Thrift.Type.BOOL, 3);
      output.writeBool(this.clearExistFilters);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_importDocFilters_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp375 = input.readMapBegin();
          const _size74 = _rtmp375.size || 0;
          for (let _i76 = 0; _i76 < _size74; ++_i76) {
            if (_i76 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key77 = null;
            let val78 = null;
            key77 = input.readString().value;
            val78 = input.readString().value;
            this.success[key77] = val78;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_importDocFilters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter79 in this.success) {
        if (this.success.hasOwnProperty(kiter79)) {
          let viter80 = this.success[kiter79];
          output.writeString(kiter79);
          output.writeString(viter80);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateUserPreferencesFilter_args = class {
  constructor(args) {
    this.token = null;
    this.filterPreferenceList = null;
    this.forRegistry = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filterPreferenceList !== undefined && args.filterPreferenceList !== null) {
        this.filterPreferenceList = Thrift.copyList(args.filterPreferenceList, [UserPreferencesFilter]);
      }
      if (args.forRegistry !== undefined && args.forRegistry !== null) {
        this.forRegistry = args.forRegistry;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.filterPreferenceList = [];
          const _rtmp382 = input.readListBegin();
          const _size81 = _rtmp382.size || 0;
          for (let _i83 = 0; _i83 < _size81; ++_i83) {
            let elem84 = null;
            elem84 = new UserPreferencesFilter();
            elem84.read(input);
            this.filterPreferenceList.push(elem84);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.forRegistry = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateUserPreferencesFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filterPreferenceList !== null && this.filterPreferenceList !== undefined) {
      output.writeFieldBegin('filterPreferenceList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.filterPreferenceList.length);
      for (let iter85 in this.filterPreferenceList) {
        if (this.filterPreferenceList.hasOwnProperty(iter85)) {
          iter85 = this.filterPreferenceList[iter85];
          iter85.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.forRegistry !== null && this.forRegistry !== undefined) {
      output.writeFieldBegin('forRegistry', Thrift.Type.BOOL, 3);
      output.writeBool(this.forRegistry);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_createOrUpdateUserPreferencesFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_createOrUpdateUserPreferencesFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getDocFilterUserDefineList_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getDocFilterUserDefineList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_getDocFilterUserDefineList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocFilter]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp387 = input.readListBegin();
          const _size86 = _rtmp387.size || 0;
          for (let _i88 = 0; _i88 < _size86; ++_i88) {
            let elem89 = null;
            elem89 = new DocFilter();
            elem89.read(input);
            this.success.push(elem89);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_getDocFilterUserDefineList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter90 in this.success) {
        if (this.success.hasOwnProperty(iter90)) {
          iter90 = this.success[iter90];
          iter90.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_changeDocFilterUserDefine_args = class {
  constructor(args) {
    this.token = null;
    this.toUpdate = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toUpdate !== undefined && args.toUpdate !== null) {
        this.toUpdate = Thrift.copyList(args.toUpdate, [DocFilter]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toUpdate = [];
          const _rtmp392 = input.readListBegin();
          const _size91 = _rtmp392.size || 0;
          for (let _i93 = 0; _i93 < _size91; ++_i93) {
            let elem94 = null;
            elem94 = new DocFilter();
            elem94.read(input);
            this.toUpdate.push(elem94);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp396 = input.readListBegin();
          const _size95 = _rtmp396.size || 0;
          for (let _i97 = 0; _i97 < _size95; ++_i97) {
            let elem98 = null;
            elem98 = input.readString().value;
            this.toRemove.push(elem98);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_changeDocFilterUserDefine_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toUpdate !== null && this.toUpdate !== undefined) {
      output.writeFieldBegin('toUpdate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toUpdate.length);
      for (let iter99 in this.toUpdate) {
        if (this.toUpdate.hasOwnProperty(iter99)) {
          iter99 = this.toUpdate[iter99];
          iter99.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter100 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter100)) {
          iter100 = this.toRemove[iter100];
          output.writeString(iter100);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_changeDocFilterUserDefine_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_changeDocFilterUserDefine_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_checkCustomDocFilters_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_checkCustomDocFilters_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterService_checkCustomDocFilters_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3102 = input.readListBegin();
          const _size101 = _rtmp3102.size || 0;
          for (let _i103 = 0; _i103 < _size101; ++_i103) {
            let elem104 = null;
            elem104 = input.readString().value;
            this.success.push(elem104);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterService_checkCustomDocFilters_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter105 in this.success) {
        if (this.success.hasOwnProperty(iter105)) {
          iter105 = this.success[iter105];
          output.writeString(iter105);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FilterServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllCustomFields (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllCustomFields(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllCustomFields (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new FilterService_getAllCustomFields_args(params);
    try {
      this.output.writeMessageBegin('getAllCustomFields', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllCustomFields();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllCustomFields () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_getAllCustomFields_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllCustomFields failed: unknown result';
  }

  createOrUpdateCustomField (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateCustomField(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateCustomField (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new FilterService_createOrUpdateCustomField_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateCustomField', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateCustomField();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateCustomField () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_createOrUpdateCustomField_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateCustomField failed: unknown result';
  }

  removeCustomField (token, filterId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeCustomField(token, filterId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeCustomField (token, filterId, callback) {
    const params = {
      token: token,
      filterId: filterId
    };
    const args = new FilterService_removeCustomField_args(params);
    try {
      this.output.writeMessageBegin('removeCustomField', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeCustomField();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeCustomField () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_removeCustomField_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeCustomField failed: unknown result';
  }

  getAllCustomDocFilters (token, filter, personal) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllCustomDocFilters(token, filter, personal, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllCustomDocFilters (token, filter, personal, callback) {
    const params = {
      token: token,
      filter: filter,
      personal: personal
    };
    const args = new FilterService_getAllCustomDocFilters_args(params);
    try {
      this.output.writeMessageBegin('getAllCustomDocFilters', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllCustomDocFilters();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllCustomDocFilters () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_getAllCustomDocFilters_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllCustomDocFilters failed: unknown result';
  }

  createOrUpdateCustomDocFilter (token, filter, customFilterItems, filterFieldsWithPosition) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateCustomDocFilter(token, filter, customFilterItems, filterFieldsWithPosition, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateCustomDocFilter (token, filter, customFilterItems, filterFieldsWithPosition, callback) {
    const params = {
      token: token,
      filter: filter,
      customFilterItems: customFilterItems,
      filterFieldsWithPosition: filterFieldsWithPosition
    };
    const args = new FilterService_createOrUpdateCustomDocFilter_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateCustomDocFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateCustomDocFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateCustomDocFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_createOrUpdateCustomDocFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateCustomDocFilter failed: unknown result';
  }

  removeCustomDocFilter (token, docFilterId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeCustomDocFilter(token, docFilterId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeCustomDocFilter (token, docFilterId, callback) {
    const params = {
      token: token,
      docFilterId: docFilterId
    };
    const args = new FilterService_removeCustomDocFilter_args(params);
    try {
      this.output.writeMessageBegin('removeCustomDocFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeCustomDocFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeCustomDocFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_removeCustomDocFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeCustomDocFilter failed: unknown result';
  }

  createOrUpdateCustomFilterItem (token, filterItem) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateCustomFilterItem(token, filterItem, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateCustomFilterItem (token, filterItem, callback) {
    const params = {
      token: token,
      filterItem: filterItem
    };
    const args = new FilterService_createOrUpdateCustomFilterItem_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateCustomFilterItem', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateCustomFilterItem();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateCustomFilterItem () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_createOrUpdateCustomFilterItem_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateCustomFilterItem failed: unknown result';
  }

  removeCustomFilterItem (token, filterItemId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeCustomFilterItem(token, filterItemId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeCustomFilterItem (token, filterItemId, callback) {
    const params = {
      token: token,
      filterItemId: filterItemId
    };
    const args = new FilterService_removeCustomFilterItem_args(params);
    try {
      this.output.writeMessageBegin('removeCustomFilterItem', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeCustomFilterItem();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeCustomFilterItem () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_removeCustomFilterItem_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeCustomFilterItem failed: unknown result';
  }

  addDocFiltersToUserGroups (token, docFilterIds, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addDocFiltersToUserGroups(token, docFilterIds, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addDocFiltersToUserGroups (token, docFilterIds, userOrGroups, callback) {
    const params = {
      token: token,
      docFilterIds: docFilterIds,
      userOrGroups: userOrGroups
    };
    const args = new FilterService_addDocFiltersToUserGroups_args(params);
    try {
      this.output.writeMessageBegin('addDocFiltersToUserGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addDocFiltersToUserGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addDocFiltersToUserGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_addDocFiltersToUserGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addDocFiltersToUserGroups failed: unknown result';
  }

  removeDocFiltersFromUserGroups (token, docFilterIds, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeDocFiltersFromUserGroups(token, docFilterIds, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeDocFiltersFromUserGroups (token, docFilterIds, userOrGroups, callback) {
    const params = {
      token: token,
      docFilterIds: docFilterIds,
      userOrGroups: userOrGroups
    };
    const args = new FilterService_removeDocFiltersFromUserGroups_args(params);
    try {
      this.output.writeMessageBegin('removeDocFiltersFromUserGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeDocFiltersFromUserGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeDocFiltersFromUserGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_removeDocFiltersFromUserGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeDocFiltersFromUserGroups failed: unknown result';
  }

  getAllDocFiltersByUserOrGroup (token, type, userOrGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocFiltersByUserOrGroup(token, type, userOrGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocFiltersByUserOrGroup (token, type, userOrGroupId, filter, callback) {
    const params = {
      token: token,
      type: type,
      userOrGroupId: userOrGroupId,
      filter: filter
    };
    const args = new FilterService_getAllDocFiltersByUserOrGroup_args(params);
    try {
      this.output.writeMessageBegin('getAllDocFiltersByUserOrGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocFiltersByUserOrGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocFiltersByUserOrGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_getAllDocFiltersByUserOrGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocFiltersByUserOrGroup failed: unknown result';
  }

  getAllUserOrGroupsByDocFilterId (token, docFilterId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUserOrGroupsByDocFilterId(token, docFilterId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUserOrGroupsByDocFilterId (token, docFilterId, filter, callback) {
    const params = {
      token: token,
      docFilterId: docFilterId,
      filter: filter
    };
    const args = new FilterService_getAllUserOrGroupsByDocFilterId_args(params);
    try {
      this.output.writeMessageBegin('getAllUserOrGroupsByDocFilterId', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUserOrGroupsByDocFilterId();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUserOrGroupsByDocFilterId () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_getAllUserOrGroupsByDocFilterId_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUserOrGroupsByDocFilterId failed: unknown result';
  }

  exportDocFilters (token, docFilterIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportDocFilters(token, docFilterIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportDocFilters (token, docFilterIds, callback) {
    const params = {
      token: token,
      docFilterIds: docFilterIds
    };
    const args = new FilterService_exportDocFilters_args(params);
    try {
      this.output.writeMessageBegin('exportDocFilters', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportDocFilters();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportDocFilters () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_exportDocFilters_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportDocFilters failed: unknown result';
  }

  importDocFilters (token, json, clearExistFilters) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_importDocFilters(token, json, clearExistFilters, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_importDocFilters (token, json, clearExistFilters, callback) {
    const params = {
      token: token,
      json: json,
      clearExistFilters: clearExistFilters
    };
    const args = new FilterService_importDocFilters_args(params);
    try {
      this.output.writeMessageBegin('importDocFilters', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_importDocFilters();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_importDocFilters () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_importDocFilters_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'importDocFilters failed: unknown result';
  }

  createOrUpdateUserPreferencesFilter (token, filterPreferenceList, forRegistry) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateUserPreferencesFilter(token, filterPreferenceList, forRegistry, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateUserPreferencesFilter (token, filterPreferenceList, forRegistry, callback) {
    const params = {
      token: token,
      filterPreferenceList: filterPreferenceList,
      forRegistry: forRegistry
    };
    const args = new FilterService_createOrUpdateUserPreferencesFilter_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateUserPreferencesFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateUserPreferencesFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateUserPreferencesFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_createOrUpdateUserPreferencesFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateUserPreferencesFilter failed: unknown result';
  }

  getDocFilterUserDefineList (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocFilterUserDefineList(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocFilterUserDefineList (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new FilterService_getDocFilterUserDefineList_args(params);
    try {
      this.output.writeMessageBegin('getDocFilterUserDefineList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocFilterUserDefineList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocFilterUserDefineList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_getDocFilterUserDefineList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocFilterUserDefineList failed: unknown result';
  }

  changeDocFilterUserDefine (token, toUpdate, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocFilterUserDefine(token, toUpdate, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocFilterUserDefine (token, toUpdate, toRemove, callback) {
    const params = {
      token: token,
      toUpdate: toUpdate,
      toRemove: toRemove
    };
    const args = new FilterService_changeDocFilterUserDefine_args(params);
    try {
      this.output.writeMessageBegin('changeDocFilterUserDefine', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocFilterUserDefine();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocFilterUserDefine () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_changeDocFilterUserDefine_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocFilterUserDefine failed: unknown result';
  }

  checkCustomDocFilters (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_checkCustomDocFilters(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_checkCustomDocFilters (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new FilterService_checkCustomDocFilters_args(params);
    try {
      this.output.writeMessageBegin('checkCustomDocFilters', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_checkCustomDocFilters();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_checkCustomDocFilters () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new FilterService_checkCustomDocFilters_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'checkCustomDocFilters failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


HBColumnType = {
  'TEXT' : 0,
  'NUMBER' : 1,
  'USER_CHOICE' : 2,
  'GLOBAL_TEXT' : 3,
  'HAND_BOOK' : 4
};
HBColumnOrderType = {
  'CREATE_DATE' : 0,
  'ALPHABETICAL' : 1,
  'NUMERIC' : 2
};
ThriftTransportType = {
  'HTTP' : 0,
  'SOCKET' : 1
};
ThriftProtocolType = {
  'JSON' : 0,
  'BIN' : 1
};
HBValue = class {
  constructor(args) {
    this.id = null;
    this.value = null;
    this.user = null;
    this.type = null;
    this.depRowId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = Thrift.copyMap(args.value, [null]);
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.depRowId !== undefined && args.depRowId !== null) {
        this.depRowId = args.depRowId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.value = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readString().value;
            val4 = input.readString().value;
            this.value[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.depRowId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBValue');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.value));
      for (let kiter5 in this.value) {
        if (this.value.hasOwnProperty(kiter5)) {
          let viter6 = this.value[kiter5];
          output.writeString(kiter5);
          output.writeString(viter6);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 3);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.depRowId !== null && this.depRowId !== undefined) {
      output.writeFieldBegin('depRowId', Thrift.Type.STRING, 5);
      output.writeString(this.depRowId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HBColumnValue = class {
  constructor(args) {
    this.value = null;
    this.depColumnId = null;
    this.depValue = null;
    if (args) {
      if (args.value !== undefined && args.value !== null) {
        this.value = new HBValue(args.value);
      }
      if (args.depColumnId !== undefined && args.depColumnId !== null) {
        this.depColumnId = args.depColumnId;
      }
      if (args.depValue !== undefined && args.depValue !== null) {
        this.depValue = new HBValue(args.depValue);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.value = new HBValue();
          this.value.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.depColumnId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.depValue = new HBValue();
          this.depValue.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBColumnValue');
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRUCT, 1);
      this.value.write(output);
      output.writeFieldEnd();
    }
    if (this.depColumnId !== null && this.depColumnId !== undefined) {
      output.writeFieldBegin('depColumnId', Thrift.Type.STRING, 2);
      output.writeString(this.depColumnId);
      output.writeFieldEnd();
    }
    if (this.depValue !== null && this.depValue !== undefined) {
      output.writeFieldBegin('depValue', Thrift.Type.STRUCT, 3);
      this.depValue.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HBRow = class {
  constructor(args) {
    this.id = null;
    this.order = null;
    this.values = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.values !== undefined && args.values !== null) {
        this.values = Thrift.copyMap(args.values, [HBColumnValue]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.order = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.values = {};
          const _rtmp38 = input.readMapBegin();
          const _size7 = _rtmp38.size || 0;
          for (let _i9 = 0; _i9 < _size7; ++_i9) {
            if (_i9 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key10 = null;
            let val11 = null;
            key10 = input.readString().value;
            val11 = new HBColumnValue();
            val11.read(input);
            this.values[key10] = val11;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBRow');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I64, 2);
      output.writeI64(this.order);
      output.writeFieldEnd();
    }
    if (this.values !== null && this.values !== undefined) {
      output.writeFieldBegin('values', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.values));
      for (let kiter12 in this.values) {
        if (this.values.hasOwnProperty(kiter12)) {
          let viter13 = this.values[kiter12];
          output.writeString(kiter12);
          viter13.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HBColumn = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.requiredColumn = null;
    this.seqNum = null;
    this.searchable = null;
    this.columnType = null;
    this.extId = null;
    this.deleteDate = null;
    this.uniqVal = null;
    this.columnKey = null;
    this.depHandBook = null;
    this.depColumnId = null;
    this.orderRule = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.requiredColumn !== undefined && args.requiredColumn !== null) {
        this.requiredColumn = args.requiredColumn;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.searchable !== undefined && args.searchable !== null) {
        this.searchable = args.searchable;
      }
      if (args.columnType !== undefined && args.columnType !== null) {
        this.columnType = args.columnType;
      }
      if (args.extId !== undefined && args.extId !== null) {
        this.extId = args.extId;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.uniqVal !== undefined && args.uniqVal !== null) {
        this.uniqVal = args.uniqVal;
      }
      if (args.columnKey !== undefined && args.columnKey !== null) {
        this.columnKey = args.columnKey;
      }
      if (args.depHandBook !== undefined && args.depHandBook !== null) {
        this.depHandBook = new HandBook(args.depHandBook);
      }
      if (args.depColumnId !== undefined && args.depColumnId !== null) {
        this.depColumnId = args.depColumnId;
      }
      if (args.orderRule !== undefined && args.orderRule !== null) {
        this.orderRule = args.orderRule;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.requiredColumn = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.searchable = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.columnType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.extId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.uniqVal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.columnKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.depHandBook = new HandBook();
          this.depHandBook.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.depColumnId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.orderRule = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBColumn');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.requiredColumn !== null && this.requiredColumn !== undefined) {
      output.writeFieldBegin('requiredColumn', Thrift.Type.BOOL, 3);
      output.writeBool(this.requiredColumn);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 4);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.searchable !== null && this.searchable !== undefined) {
      output.writeFieldBegin('searchable', Thrift.Type.BOOL, 5);
      output.writeBool(this.searchable);
      output.writeFieldEnd();
    }
    if (this.columnType !== null && this.columnType !== undefined) {
      output.writeFieldBegin('columnType', Thrift.Type.I32, 6);
      output.writeI32(this.columnType);
      output.writeFieldEnd();
    }
    if (this.extId !== null && this.extId !== undefined) {
      output.writeFieldBegin('extId', Thrift.Type.STRING, 7);
      output.writeString(this.extId);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.uniqVal !== null && this.uniqVal !== undefined) {
      output.writeFieldBegin('uniqVal', Thrift.Type.BOOL, 9);
      output.writeBool(this.uniqVal);
      output.writeFieldEnd();
    }
    if (this.columnKey !== null && this.columnKey !== undefined) {
      output.writeFieldBegin('columnKey', Thrift.Type.STRING, 10);
      output.writeString(this.columnKey);
      output.writeFieldEnd();
    }
    if (this.depHandBook !== null && this.depHandBook !== undefined) {
      output.writeFieldBegin('depHandBook', Thrift.Type.STRUCT, 11);
      this.depHandBook.write(output);
      output.writeFieldEnd();
    }
    if (this.depColumnId !== null && this.depColumnId !== undefined) {
      output.writeFieldBegin('depColumnId', Thrift.Type.STRING, 12);
      output.writeString(this.depColumnId);
      output.writeFieldEnd();
    }
    if (this.orderRule !== null && this.orderRule !== undefined) {
      output.writeFieldBegin('orderRule', Thrift.Type.I32, 13);
      output.writeI32(this.orderRule);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBook = class {
  constructor(args) {
    this.id = null;
    this.hBookName = null;
    this.guiId = null;
    this.fixed = null;
    this.accountIds = null;
    this.columns = null;
    this.hbContentAdmins = null;
    this.allowEdit = null;
    this.thriftURL = null;
    this.copyValue = null;
    this.transportType = null;
    this.protocolType = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.hBookName !== undefined && args.hBookName !== null) {
        this.hBookName = args.hBookName;
      }
      if (args.guiId !== undefined && args.guiId !== null) {
        this.guiId = args.guiId;
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
      if (args.columns !== undefined && args.columns !== null) {
        this.columns = Thrift.copyList(args.columns, [HBColumn]);
      }
      if (args.hbContentAdmins !== undefined && args.hbContentAdmins !== null) {
        this.hbContentAdmins = Thrift.copyList(args.hbContentAdmins, [UserOrGroup]);
      }
      if (args.allowEdit !== undefined && args.allowEdit !== null) {
        this.allowEdit = args.allowEdit;
      }
      if (args.thriftURL !== undefined && args.thriftURL !== null) {
        this.thriftURL = args.thriftURL;
      }
      if (args.copyValue !== undefined && args.copyValue !== null) {
        this.copyValue = args.copyValue;
      }
      if (args.transportType !== undefined && args.transportType !== null) {
        this.transportType = args.transportType;
      }
      if (args.protocolType !== undefined && args.protocolType !== null) {
        this.protocolType = args.protocolType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hBookName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.guiId = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.accountIds = [];
          const _rtmp315 = input.readSetBegin();
          const _size14 = _rtmp315.size || 0;
          for (let _i16 = 0; _i16 < _size14; ++_i16) {
            let elem17 = null;
            elem17 = input.readString().value;
            this.accountIds.push(elem17);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.columns = [];
          const _rtmp319 = input.readListBegin();
          const _size18 = _rtmp319.size || 0;
          for (let _i20 = 0; _i20 < _size18; ++_i20) {
            let elem21 = null;
            elem21 = new HBColumn();
            elem21.read(input);
            this.columns.push(elem21);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.hbContentAdmins = [];
          const _rtmp323 = input.readListBegin();
          const _size22 = _rtmp323.size || 0;
          for (let _i24 = 0; _i24 < _size22; ++_i24) {
            let elem25 = null;
            elem25 = new UserOrGroup();
            elem25.read(input);
            this.hbContentAdmins.push(elem25);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.allowEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.thriftURL = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.copyValue = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.transportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.protocolType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBook');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.hBookName !== null && this.hBookName !== undefined) {
      output.writeFieldBegin('hBookName', Thrift.Type.STRING, 2);
      output.writeString(this.hBookName);
      output.writeFieldEnd();
    }
    if (this.guiId !== null && this.guiId !== undefined) {
      output.writeFieldBegin('guiId', Thrift.Type.I64, 3);
      output.writeI64(this.guiId);
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 4);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter26 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter26)) {
          iter26 = this.accountIds[iter26];
          output.writeString(iter26);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.columns !== null && this.columns !== undefined) {
      output.writeFieldBegin('columns', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
      for (let iter27 in this.columns) {
        if (this.columns.hasOwnProperty(iter27)) {
          iter27 = this.columns[iter27];
          iter27.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.hbContentAdmins !== null && this.hbContentAdmins !== undefined) {
      output.writeFieldBegin('hbContentAdmins', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.hbContentAdmins.length);
      for (let iter28 in this.hbContentAdmins) {
        if (this.hbContentAdmins.hasOwnProperty(iter28)) {
          iter28 = this.hbContentAdmins[iter28];
          iter28.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.allowEdit !== null && this.allowEdit !== undefined) {
      output.writeFieldBegin('allowEdit', Thrift.Type.BOOL, 8);
      output.writeBool(this.allowEdit);
      output.writeFieldEnd();
    }
    if (this.thriftURL !== null && this.thriftURL !== undefined) {
      output.writeFieldBegin('thriftURL', Thrift.Type.STRING, 9);
      output.writeString(this.thriftURL);
      output.writeFieldEnd();
    }
    if (this.copyValue !== null && this.copyValue !== undefined) {
      output.writeFieldBegin('copyValue', Thrift.Type.BOOL, 10);
      output.writeBool(this.copyValue);
      output.writeFieldEnd();
    }
    if (this.transportType !== null && this.transportType !== undefined) {
      output.writeFieldBegin('transportType', Thrift.Type.I32, 11);
      output.writeI32(this.transportType);
      output.writeFieldEnd();
    }
    if (this.protocolType !== null && this.protocolType !== undefined) {
      output.writeFieldBegin('protocolType', Thrift.Type.I32, 12);
      output.writeI32(this.protocolType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

HandBookService_getAllHandBooks_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBooks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getAllHandBooks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [HandBook]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new HandBook();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBooks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getCountAllHandBooks_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getCountAllHandBooks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getCountAllHandBooks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getCountAllHandBooks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getHandBookById_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    this.withDeletedColumns = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.withDeletedColumns !== undefined && args.withDeletedColumns !== null) {
        this.withDeletedColumns = args.withDeletedColumns;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.withDeletedColumns = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getHandBookById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.withDeletedColumns !== null && this.withDeletedColumns !== undefined) {
      output.writeFieldBegin('withDeletedColumns', Thrift.Type.BOOL, 3);
      output.writeBool(this.withDeletedColumns);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getHandBookById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HandBook(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HandBook();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getHandBookById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_createOrUpdateHandBook_args = class {
  constructor(args) {
    this.token = null;
    this.handBook = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.handBook !== undefined && args.handBook !== null) {
        this.handBook = new HandBook(args.handBook);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.handBook = new HandBook();
          this.handBook.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_createOrUpdateHandBook_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.handBook !== null && this.handBook !== undefined) {
      output.writeFieldBegin('handBook', Thrift.Type.STRUCT, 2);
      this.handBook.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_createOrUpdateHandBook_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HandBook(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HandBook();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_createOrUpdateHandBook_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_refreshHandBookStructure_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_refreshHandBookStructure_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 2);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_refreshHandBookStructure_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [Thrift.copyList, HBColumn]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp36 = input.readMapBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            if (_i7 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key8 = null;
            let val9 = null;
            key8 = input.readString().value;
            val9 = [];
            const _rtmp311 = input.readListBegin();
            const _size10 = _rtmp311.size || 0;
            for (let _i12 = 0; _i12 < _size10; ++_i12) {
              let elem13 = null;
              elem13 = new HBColumn();
              elem13.read(input);
              val9.push(elem13);
            }
            input.readListEnd();
            this.success[key8] = val9;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_refreshHandBookStructure_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
      for (let kiter14 in this.success) {
        if (this.success.hasOwnProperty(kiter14)) {
          let viter15 = this.success[kiter14];
          output.writeString(kiter14);
          output.writeListBegin(Thrift.Type.STRUCT, viter15.length);
          for (let iter16 in viter15) {
            if (viter15.hasOwnProperty(iter16)) {
              iter16 = viter15[iter16];
              iter16.write(output);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_createOrUpdateHBRows_args = class {
  constructor(args) {
    this.token = null;
    this.hbId = null;
    this.rows = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.hbId !== undefined && args.hbId !== null) {
        this.hbId = args.hbId;
      }
      if (args.rows !== undefined && args.rows !== null) {
        this.rows = Thrift.copyList(args.rows, [HBRow]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hbId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.rows = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = new HBRow();
            elem20.read(input);
            this.rows.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_createOrUpdateHBRows_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.hbId !== null && this.hbId !== undefined) {
      output.writeFieldBegin('hbId', Thrift.Type.STRING, 2);
      output.writeString(this.hbId);
      output.writeFieldEnd();
    }
    if (this.rows !== null && this.rows !== undefined) {
      output.writeFieldBegin('rows', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
      for (let iter21 in this.rows) {
        if (this.rows.hasOwnProperty(iter21)) {
          iter21 = this.rows[iter21];
          iter21.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_createOrUpdateHBRows_result = class {
  constructor(args) {
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_createOrUpdateHBRows_result');
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getAllHandBookRows_args = class {
  constructor(args) {
    this.token = null;
    this.hbId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.hbId !== undefined && args.hbId !== null) {
        this.hbId = args.hbId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hbId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBookRows_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.hbId !== null && this.hbId !== undefined) {
      output.writeFieldBegin('hbId', Thrift.Type.STRING, 2);
      output.writeString(this.hbId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getAllHandBookRows_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [HBRow]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp323 = input.readListBegin();
          const _size22 = _rtmp323.size || 0;
          for (let _i24 = 0; _i24 < _size22; ++_i24) {
            let elem25 = null;
            elem25 = new HBRow();
            elem25.read(input);
            this.success.push(elem25);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBookRows_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter26 in this.success) {
        if (this.success.hasOwnProperty(iter26)) {
          iter26 = this.success[iter26];
          iter26.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getAllHandBookRowsCount_args = class {
  constructor(args) {
    this.token = null;
    this.hbId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.hbId !== undefined && args.hbId !== null) {
        this.hbId = args.hbId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hbId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBookRowsCount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.hbId !== null && this.hbId !== undefined) {
      output.writeFieldBegin('hbId', Thrift.Type.STRING, 2);
      output.writeString(this.hbId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getAllHandBookRowsCount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getAllHandBookRowsCount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getHandBookValues_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getHandBookValues_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_getHandBookValues_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [HBValue]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp328 = input.readListBegin();
          const _size27 = _rtmp328.size || 0;
          for (let _i29 = 0; _i29 < _size27; ++_i29) {
            let elem30 = null;
            elem30 = new HBValue();
            elem30.read(input);
            this.success.push(elem30);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_getHandBookValues_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter31 in this.success) {
        if (this.success.hasOwnProperty(iter31)) {
          iter31 = this.success[iter31];
          iter31.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_removeHandBook_args = class {
  constructor(args) {
    this.token = null;
    this.hbId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.hbId !== undefined && args.hbId !== null) {
        this.hbId = args.hbId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hbId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_removeHandBook_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.hbId !== null && this.hbId !== undefined) {
      output.writeFieldBegin('hbId', Thrift.Type.STRING, 2);
      output.writeString(this.hbId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_removeHandBook_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_removeHandBook_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_removeHandBookRow_args = class {
  constructor(args) {
    this.token = null;
    this.hbId = null;
    this.rowId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.hbId !== undefined && args.hbId !== null) {
        this.hbId = args.hbId;
      }
      if (args.rowId !== undefined && args.rowId !== null) {
        this.rowId = args.rowId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.hbId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.rowId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_removeHandBookRow_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.hbId !== null && this.hbId !== undefined) {
      output.writeFieldBegin('hbId', Thrift.Type.STRING, 2);
      output.writeString(this.hbId);
      output.writeFieldEnd();
    }
    if (this.rowId !== null && this.rowId !== undefined) {
      output.writeFieldBegin('rowId', Thrift.Type.STRING, 3);
      output.writeString(this.rowId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookService_removeHandBookRow_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HandBookService_removeHandBookRow_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HandBookServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllHandBooks (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllHandBooks(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllHandBooks (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new HandBookService_getAllHandBooks_args(params);
    try {
      this.output.writeMessageBegin('getAllHandBooks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllHandBooks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllHandBooks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getAllHandBooks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllHandBooks failed: unknown result';
  }

  getCountAllHandBooks (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllHandBooks(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllHandBooks (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new HandBookService_getCountAllHandBooks_args(params);
    try {
      this.output.writeMessageBegin('getCountAllHandBooks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllHandBooks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllHandBooks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getCountAllHandBooks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllHandBooks failed: unknown result';
  }

  getHandBookById (token, id, withDeletedColumns) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getHandBookById(token, id, withDeletedColumns, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getHandBookById (token, id, withDeletedColumns, callback) {
    const params = {
      token: token,
      id: id,
      withDeletedColumns: withDeletedColumns
    };
    const args = new HandBookService_getHandBookById_args(params);
    try {
      this.output.writeMessageBegin('getHandBookById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getHandBookById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getHandBookById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getHandBookById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getHandBookById failed: unknown result';
  }

  createOrUpdateHandBook (token, handBook) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateHandBook(token, handBook, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateHandBook (token, handBook, callback) {
    const params = {
      token: token,
      handBook: handBook
    };
    const args = new HandBookService_createOrUpdateHandBook_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateHandBook', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateHandBook();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateHandBook () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_createOrUpdateHandBook_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateHandBook failed: unknown result';
  }

  refreshHandBookStructure (token, id) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_refreshHandBookStructure(token, id, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_refreshHandBookStructure (token, id, callback) {
    const params = {
      token: token,
      id: id
    };
    const args = new HandBookService_refreshHandBookStructure_args(params);
    try {
      this.output.writeMessageBegin('refreshHandBookStructure', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_refreshHandBookStructure();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_refreshHandBookStructure () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_refreshHandBookStructure_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'refreshHandBookStructure failed: unknown result';
  }

  createOrUpdateHBRows (token, hbId, rows) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateHBRows(token, hbId, rows, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateHBRows (token, hbId, rows, callback) {
    const params = {
      token: token,
      hbId: hbId,
      rows: rows
    };
    const args = new HandBookService_createOrUpdateHBRows_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateHBRows', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateHBRows();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateHBRows () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_createOrUpdateHBRows_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    return;
  }

  getAllHandBookRows (token, hbId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllHandBookRows(token, hbId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllHandBookRows (token, hbId, filter, callback) {
    const params = {
      token: token,
      hbId: hbId,
      filter: filter
    };
    const args = new HandBookService_getAllHandBookRows_args(params);
    try {
      this.output.writeMessageBegin('getAllHandBookRows', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllHandBookRows();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllHandBookRows () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getAllHandBookRows_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllHandBookRows failed: unknown result';
  }

  getAllHandBookRowsCount (token, hbId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllHandBookRowsCount(token, hbId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllHandBookRowsCount (token, hbId, filter, callback) {
    const params = {
      token: token,
      hbId: hbId,
      filter: filter
    };
    const args = new HandBookService_getAllHandBookRowsCount_args(params);
    try {
      this.output.writeMessageBegin('getAllHandBookRowsCount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllHandBookRowsCount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllHandBookRowsCount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getAllHandBookRowsCount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllHandBookRowsCount failed: unknown result';
  }

  getHandBookValues (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getHandBookValues(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getHandBookValues (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new HandBookService_getHandBookValues_args(params);
    try {
      this.output.writeMessageBegin('getHandBookValues', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getHandBookValues();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getHandBookValues () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_getHandBookValues_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getHandBookValues failed: unknown result';
  }

  removeHandBook (token, hbId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeHandBook(token, hbId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeHandBook (token, hbId, callback) {
    const params = {
      token: token,
      hbId: hbId
    };
    const args = new HandBookService_removeHandBook_args(params);
    try {
      this.output.writeMessageBegin('removeHandBook', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeHandBook();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeHandBook () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_removeHandBook_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeHandBook failed: unknown result';
  }

  removeHandBookRow (token, hbId, rowId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeHandBookRow(token, hbId, rowId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeHandBookRow (token, hbId, rowId, callback) {
    const params = {
      token: token,
      hbId: hbId,
      rowId: rowId
    };
    const args = new HandBookService_removeHandBookRow_args(params);
    try {
      this.output.writeMessageBegin('removeHandBookRow', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeHandBookRow();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeHandBookRow () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HandBookService_removeHandBookRow_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeHandBookRow failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

HistoryService_getAllDeadlineHistories_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getAllDeadlineHistories_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getAllDeadlineHistories_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DeadlineHistory]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new DeadlineHistory();
            elem8.read(input);
            this.success.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getAllDeadlineHistories_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter9 in this.success) {
        if (this.success.hasOwnProperty(iter9)) {
          iter9 = this.success[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    this.useAdmin = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.useAdmin !== undefined && args.useAdmin !== null) {
        this.useAdmin = args.useAdmin;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.useAdmin = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.useAdmin !== null && this.useAdmin !== undefined) {
      output.writeFieldBegin('useAdmin', Thrift.Type.BOOL, 3);
      output.writeBool(this.useAdmin);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getChangeLogByHistory_args = class {
  constructor(args) {
    this.token = null;
    this.historyId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.historyId !== undefined && args.historyId !== null) {
        this.historyId = args.historyId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.historyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getChangeLogByHistory_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.historyId !== null && this.historyId !== undefined) {
      output.writeFieldBegin('historyId', Thrift.Type.STRING, 2);
      output.writeString(this.historyId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getChangeLogByHistory_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ChangeLog]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new ChangeLog();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getChangeLogByHistory_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getUserHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getUserHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryService_getUserHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryService_getUserHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllDeadlineHistories (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDeadlineHistories(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDeadlineHistories (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new HistoryService_getAllDeadlineHistories_args(params);
    try {
      this.output.writeMessageBegin('getAllDeadlineHistories', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDeadlineHistories();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDeadlineHistories () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HistoryService_getAllDeadlineHistories_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDeadlineHistories failed: unknown result';
  }

  getHistoryPage (token, filter, useAdmin) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getHistoryPage(token, filter, useAdmin, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getHistoryPage (token, filter, useAdmin, callback) {
    const params = {
      token: token,
      filter: filter,
      useAdmin: useAdmin
    };
    const args = new HistoryService_getHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HistoryService_getHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getHistoryPage failed: unknown result';
  }

  getChangeLogByHistory (token, historyId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getChangeLogByHistory(token, historyId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getChangeLogByHistory (token, historyId, callback) {
    const params = {
      token: token,
      historyId: historyId
    };
    const args = new HistoryService_getChangeLogByHistory_args(params);
    try {
      this.output.writeMessageBegin('getChangeLogByHistory', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getChangeLogByHistory();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getChangeLogByHistory () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HistoryService_getChangeLogByHistory_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getChangeLogByHistory failed: unknown result';
  }

  getUserHistoryPage (token, userId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUserHistoryPage(token, userId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUserHistoryPage (token, userId, filter, callback) {
    const params = {
      token: token,
      userId: userId,
      filter: filter
    };
    const args = new HistoryService_getUserHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getUserHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUserHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUserHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new HistoryService_getUserHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUserHistoryPage failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


JobTaskStatus = {
  'CREATE' : 0,
  'IN_PROCESS' : 1,
  'FAILED' : 2,
  'SUCCESS' : 3,
  'CANCEL' : 4
};
JobTaskType = {
  'HANDOVER' : 0,
  'UPDATE_MASK_FOR_PATTERN' : 1,
  'UPDATE_MASK_FOR_DOCUMENT' : 2,
  'UPDATE_MASK_FOR_USER' : 3,
  'UPDATE_MASK_FOR_GROUP' : 4,
  'UPDATE_MASK_FOR_USERS_GROUP' : 5,
  'ADD_SC_TO_USER_OR_GROUPS' : 6,
  'UPDATE_DOC_ITEMS_SEARCH_VALUE' : 7
};
ExtProtocolType = {
  'REST' : 0,
  'THRIFT' : 1
};
JobTask = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.processedDate = null;
    this.status = null;
    this.type = null;
    this.taskError = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.processedDate !== undefined && args.processedDate !== null) {
        this.processedDate = args.processedDate;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.taskError !== undefined && args.taskError !== null) {
        this.taskError = args.taskError;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.processedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.taskError = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('JobTask');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.processedDate !== null && this.processedDate !== undefined) {
      output.writeFieldBegin('processedDate', Thrift.Type.I64, 3);
      output.writeI64(this.processedDate);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 4);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 5);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.taskError !== null && this.taskError !== undefined) {
      output.writeFieldBegin('taskError', Thrift.Type.STRING, 6);
      output.writeString(this.taskError);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ExternalModule = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.url = null;
    this.nameExternalModule = null;
    this.descriptionExternalModule = null;
    this.user = null;
    this.error = null;
    this.protocolType = null;
    this.accounts = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.url !== undefined && args.url !== null) {
        this.url = args.url;
      }
      if (args.nameExternalModule !== undefined && args.nameExternalModule !== null) {
        this.nameExternalModule = args.nameExternalModule;
      }
      if (args.descriptionExternalModule !== undefined && args.descriptionExternalModule !== null) {
        this.descriptionExternalModule = args.descriptionExternalModule;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
      if (args.protocolType !== undefined && args.protocolType !== null) {
        this.protocolType = args.protocolType;
      }
      if (args.accounts !== undefined && args.accounts !== null) {
        this.accounts = Thrift.copyList(args.accounts, [Account]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.url = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nameExternalModule = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionExternalModule = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.error = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.protocolType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.accounts = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new Account();
            elem3.read(input);
            this.accounts.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ExternalModule');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.url !== null && this.url !== undefined) {
      output.writeFieldBegin('url', Thrift.Type.STRING, 3);
      output.writeString(this.url);
      output.writeFieldEnd();
    }
    if (this.nameExternalModule !== null && this.nameExternalModule !== undefined) {
      output.writeFieldBegin('nameExternalModule', Thrift.Type.STRING, 4);
      output.writeString(this.nameExternalModule);
      output.writeFieldEnd();
    }
    if (this.descriptionExternalModule !== null && this.descriptionExternalModule !== undefined) {
      output.writeFieldBegin('descriptionExternalModule', Thrift.Type.STRING, 5);
      output.writeString(this.descriptionExternalModule);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 6);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRING, 7);
      output.writeString(this.error);
      output.writeFieldEnd();
    }
    if (this.protocolType !== null && this.protocolType !== undefined) {
      output.writeFieldBegin('protocolType', Thrift.Type.I32, 8);
      output.writeI32(this.protocolType);
      output.writeFieldEnd();
    }
    if (this.accounts !== null && this.accounts !== undefined) {
      output.writeFieldBegin('accounts', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.accounts.length);
      for (let iter4 in this.accounts) {
        if (this.accounts.hasOwnProperty(iter4)) {
          iter4 = this.accounts[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
License = class {
  constructor(args) {
    this.validFrom = null;
    this.validTo = null;
    this.key = null;
    this.accountGroup = null;
    this.account = null;
    this.user = null;
    this.autoAssignment = null;
    this.autoAssignmentOrder = null;
    this.userCount = null;
    this.personal = null;
    if (args) {
      if (args.validFrom !== undefined && args.validFrom !== null) {
        this.validFrom = args.validFrom;
      }
      if (args.validTo !== undefined && args.validTo !== null) {
        this.validTo = args.validTo;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.accountGroup !== undefined && args.accountGroup !== null) {
        this.accountGroup = new AccountGroup(args.accountGroup);
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.autoAssignment !== undefined && args.autoAssignment !== null) {
        this.autoAssignment = args.autoAssignment;
      }
      if (args.autoAssignmentOrder !== undefined && args.autoAssignmentOrder !== null) {
        this.autoAssignmentOrder = args.autoAssignmentOrder;
      }
      if (args.userCount !== undefined && args.userCount !== null) {
        this.userCount = args.userCount;
      }
      if (args.personal !== undefined && args.personal !== null) {
        this.personal = args.personal;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I64) {
          this.validFrom = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.validTo = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accountGroup = new AccountGroup();
          this.accountGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.autoAssignment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.autoAssignmentOrder = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.userCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.personal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('License');
    if (this.validFrom !== null && this.validFrom !== undefined) {
      output.writeFieldBegin('validFrom', Thrift.Type.I64, 1);
      output.writeI64(this.validFrom);
      output.writeFieldEnd();
    }
    if (this.validTo !== null && this.validTo !== undefined) {
      output.writeFieldBegin('validTo', Thrift.Type.I64, 2);
      output.writeI64(this.validTo);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 3);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.accountGroup !== null && this.accountGroup !== undefined) {
      output.writeFieldBegin('accountGroup', Thrift.Type.STRUCT, 4);
      this.accountGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 5);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 6);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.autoAssignment !== null && this.autoAssignment !== undefined) {
      output.writeFieldBegin('autoAssignment', Thrift.Type.BOOL, 7);
      output.writeBool(this.autoAssignment);
      output.writeFieldEnd();
    }
    if (this.autoAssignmentOrder !== null && this.autoAssignmentOrder !== undefined) {
      output.writeFieldBegin('autoAssignmentOrder', Thrift.Type.I32, 8);
      output.writeI32(this.autoAssignmentOrder);
      output.writeFieldEnd();
    }
    if (this.userCount !== null && this.userCount !== undefined) {
      output.writeFieldBegin('userCount', Thrift.Type.I32, 9);
      output.writeI32(this.userCount);
      output.writeFieldEnd();
    }
    if (this.personal !== null && this.personal !== undefined) {
      output.writeFieldBegin('personal', Thrift.Type.BOOL, 10);
      output.writeBool(this.personal);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CharMatchingDictionary = class {
  constructor(args) {
    this.id = null;
    this.charSource = null;
    this.charReplace = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.charSource !== undefined && args.charSource !== null) {
        this.charSource = args.charSource;
      }
      if (args.charReplace !== undefined && args.charReplace !== null) {
        this.charReplace = args.charReplace;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.charSource = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.charReplace = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CharMatchingDictionary');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.charSource !== null && this.charSource !== undefined) {
      output.writeFieldBegin('charSource', Thrift.Type.STRING, 2);
      output.writeString(this.charSource);
      output.writeFieldEnd();
    }
    if (this.charReplace !== null && this.charReplace !== undefined) {
      output.writeFieldBegin('charReplace', Thrift.Type.STRING, 3);
      output.writeString(this.charReplace);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserAcc = class {
  constructor(args) {
    this.userOrGroup = null;
    this.acounts = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.acounts !== undefined && args.acounts !== null) {
        this.acounts = Thrift.copyList(args.acounts, [Account]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.acounts = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new Account();
            elem8.read(input);
            this.acounts.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserAcc');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 1);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.acounts !== null && this.acounts !== undefined) {
      output.writeFieldBegin('acounts', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.acounts.length);
      for (let iter9 in this.acounts) {
        if (this.acounts.hasOwnProperty(iter9)) {
          iter9 = this.acounts[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserExt = class {
  constructor(args) {
    this.userOrGroup = null;
    this.login = null;
    this.hasPublicKey = null;
    this.delegates = null;
    this.licenceEndDate = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.hasPublicKey !== undefined && args.hasPublicKey !== null) {
        this.hasPublicKey = args.hasPublicKey;
      }
      if (args.delegates !== undefined && args.delegates !== null) {
        this.delegates = Thrift.copyList(args.delegates, [UserOrGroup]);
      }
      if (args.licenceEndDate !== undefined && args.licenceEndDate !== null) {
        this.licenceEndDate = args.licenceEndDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.hasPublicKey = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.delegates = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new UserOrGroup();
            elem13.read(input);
            this.delegates.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.licenceEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserExt');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 1);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 2);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.hasPublicKey !== null && this.hasPublicKey !== undefined) {
      output.writeFieldBegin('hasPublicKey', Thrift.Type.BOOL, 3);
      output.writeBool(this.hasPublicKey);
      output.writeFieldEnd();
    }
    if (this.delegates !== null && this.delegates !== undefined) {
      output.writeFieldBegin('delegates', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.delegates.length);
      for (let iter14 in this.delegates) {
        if (this.delegates.hasOwnProperty(iter14)) {
          iter14 = this.delegates[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.licenceEndDate !== null && this.licenceEndDate !== undefined) {
      output.writeFieldBegin('licenceEndDate', Thrift.Type.I64, 5);
      output.writeI64(this.licenceEndDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PersonalAccessPeriod = class {
  constructor(args) {
    this.forAllTime = null;
    this.dateStart = null;
    this.dateEnd = null;
    if (args) {
      if (args.forAllTime !== undefined && args.forAllTime !== null) {
        this.forAllTime = args.forAllTime;
      }
      if (args.dateStart !== undefined && args.dateStart !== null) {
        this.dateStart = args.dateStart;
      }
      if (args.dateEnd !== undefined && args.dateEnd !== null) {
        this.dateEnd = args.dateEnd;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.forAllTime = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.dateStart = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.dateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PersonalAccessPeriod');
    if (this.forAllTime !== null && this.forAllTime !== undefined) {
      output.writeFieldBegin('forAllTime', Thrift.Type.BOOL, 1);
      output.writeBool(this.forAllTime);
      output.writeFieldEnd();
    }
    if (this.dateStart !== null && this.dateStart !== undefined) {
      output.writeFieldBegin('dateStart', Thrift.Type.I64, 2);
      output.writeI64(this.dateStart);
      output.writeFieldEnd();
    }
    if (this.dateEnd !== null && this.dateEnd !== undefined) {
      output.writeFieldBegin('dateEnd', Thrift.Type.I64, 3);
      output.writeI64(this.dateEnd);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CopyPersonalAccessSettings = class {
  constructor(args) {
    this.accounts = null;
    this.roles = null;
    this.groups = null;
    this.securityClassifications = null;
    this.documentPeriod = null;
    this.meetings = null;
    this.bpm = null;
    this.blockUser = null;
    this.deleteUser = null;
    this.detachLicense = null;
    this.docPatternGroupIds = null;
    this.docPatternIds = null;
    this.reasonForRemoval = null;
    this.userIdTo = null;
    this.userIdFrom = null;
    if (args) {
      if (args.accounts !== undefined && args.accounts !== null) {
        this.accounts = args.accounts;
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = args.roles;
      }
      if (args.groups !== undefined && args.groups !== null) {
        this.groups = args.groups;
      }
      if (args.securityClassifications !== undefined && args.securityClassifications !== null) {
        this.securityClassifications = args.securityClassifications;
      }
      if (args.documentPeriod !== undefined && args.documentPeriod !== null) {
        this.documentPeriod = new PersonalAccessPeriod(args.documentPeriod);
      }
      if (args.meetings !== undefined && args.meetings !== null) {
        this.meetings = args.meetings;
      }
      if (args.bpm !== undefined && args.bpm !== null) {
        this.bpm = args.bpm;
      }
      if (args.blockUser !== undefined && args.blockUser !== null) {
        this.blockUser = args.blockUser;
      }
      if (args.deleteUser !== undefined && args.deleteUser !== null) {
        this.deleteUser = args.deleteUser;
      }
      if (args.detachLicense !== undefined && args.detachLicense !== null) {
        this.detachLicense = args.detachLicense;
      }
      if (args.docPatternGroupIds !== undefined && args.docPatternGroupIds !== null) {
        this.docPatternGroupIds = Thrift.copyList(args.docPatternGroupIds, [null]);
      }
      if (args.docPatternIds !== undefined && args.docPatternIds !== null) {
        this.docPatternIds = Thrift.copyList(args.docPatternIds, [null]);
      }
      if (args.reasonForRemoval !== undefined && args.reasonForRemoval !== null) {
        this.reasonForRemoval = args.reasonForRemoval;
      }
      if (args.userIdTo !== undefined && args.userIdTo !== null) {
        this.userIdTo = args.userIdTo;
      }
      if (args.userIdFrom !== undefined && args.userIdFrom !== null) {
        this.userIdFrom = args.userIdFrom;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.accounts = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.roles = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.groups = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.securityClassifications = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPeriod = new PersonalAccessPeriod();
          this.documentPeriod.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.meetings = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.bpm = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.blockUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.deleteUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.detachLicense = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.LIST) {
          this.docPatternGroupIds = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = input.readString().value;
            this.docPatternGroupIds.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.LIST) {
          this.docPatternIds = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = input.readString().value;
            this.docPatternIds.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.reasonForRemoval = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.userIdTo = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.userIdFrom = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CopyPersonalAccessSettings');
    if (this.accounts !== null && this.accounts !== undefined) {
      output.writeFieldBegin('accounts', Thrift.Type.BOOL, 1);
      output.writeBool(this.accounts);
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.BOOL, 2);
      output.writeBool(this.roles);
      output.writeFieldEnd();
    }
    if (this.groups !== null && this.groups !== undefined) {
      output.writeFieldBegin('groups', Thrift.Type.BOOL, 3);
      output.writeBool(this.groups);
      output.writeFieldEnd();
    }
    if (this.securityClassifications !== null && this.securityClassifications !== undefined) {
      output.writeFieldBegin('securityClassifications', Thrift.Type.BOOL, 4);
      output.writeBool(this.securityClassifications);
      output.writeFieldEnd();
    }
    if (this.documentPeriod !== null && this.documentPeriod !== undefined) {
      output.writeFieldBegin('documentPeriod', Thrift.Type.STRUCT, 5);
      this.documentPeriod.write(output);
      output.writeFieldEnd();
    }
    if (this.meetings !== null && this.meetings !== undefined) {
      output.writeFieldBegin('meetings', Thrift.Type.BOOL, 6);
      output.writeBool(this.meetings);
      output.writeFieldEnd();
    }
    if (this.bpm !== null && this.bpm !== undefined) {
      output.writeFieldBegin('bpm', Thrift.Type.BOOL, 7);
      output.writeBool(this.bpm);
      output.writeFieldEnd();
    }
    if (this.blockUser !== null && this.blockUser !== undefined) {
      output.writeFieldBegin('blockUser', Thrift.Type.BOOL, 8);
      output.writeBool(this.blockUser);
      output.writeFieldEnd();
    }
    if (this.deleteUser !== null && this.deleteUser !== undefined) {
      output.writeFieldBegin('deleteUser', Thrift.Type.BOOL, 9);
      output.writeBool(this.deleteUser);
      output.writeFieldEnd();
    }
    if (this.detachLicense !== null && this.detachLicense !== undefined) {
      output.writeFieldBegin('detachLicense', Thrift.Type.BOOL, 10);
      output.writeBool(this.detachLicense);
      output.writeFieldEnd();
    }
    if (this.docPatternGroupIds !== null && this.docPatternGroupIds !== undefined) {
      output.writeFieldBegin('docPatternGroupIds', Thrift.Type.LIST, 11);
      output.writeListBegin(Thrift.Type.STRING, this.docPatternGroupIds.length);
      for (let iter23 in this.docPatternGroupIds) {
        if (this.docPatternGroupIds.hasOwnProperty(iter23)) {
          iter23 = this.docPatternGroupIds[iter23];
          output.writeString(iter23);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docPatternIds !== null && this.docPatternIds !== undefined) {
      output.writeFieldBegin('docPatternIds', Thrift.Type.LIST, 12);
      output.writeListBegin(Thrift.Type.STRING, this.docPatternIds.length);
      for (let iter24 in this.docPatternIds) {
        if (this.docPatternIds.hasOwnProperty(iter24)) {
          iter24 = this.docPatternIds[iter24];
          output.writeString(iter24);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.reasonForRemoval !== null && this.reasonForRemoval !== undefined) {
      output.writeFieldBegin('reasonForRemoval', Thrift.Type.STRING, 13);
      output.writeString(this.reasonForRemoval);
      output.writeFieldEnd();
    }
    if (this.userIdTo !== null && this.userIdTo !== undefined) {
      output.writeFieldBegin('userIdTo', Thrift.Type.STRING, 14);
      output.writeString(this.userIdTo);
      output.writeFieldEnd();
    }
    if (this.userIdFrom !== null && this.userIdFrom !== undefined) {
      output.writeFieldBegin('userIdFrom', Thrift.Type.STRING, 15);
      output.writeString(this.userIdFrom);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


MatchingUserGroup = class {
  constructor(args) {
    this.stageName = null;
    this.users = null;
    this.iteration = null;
    if (args) {
      if (args.stageName !== undefined && args.stageName !== null) {
        this.stageName = args.stageName;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.stageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new UserOrGroup();
            elem3.read(input);
            this.users.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MatchingUserGroup');
    if (this.stageName !== null && this.stageName !== undefined) {
      output.writeFieldBegin('stageName', Thrift.Type.STRING, 1);
      output.writeString(this.stageName);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter4 in this.users) {
        if (this.users.hasOwnProperty(iter4)) {
          iter4 = this.users[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 3);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AggregationDocumentData = class {
  constructor(args) {
    this.document = null;
    this.comments = null;
    this.relations = null;
    this.contentTabs = null;
    this.securityClassifications = null;
    this.deadlineHistories = null;
    this.attachments = null;
    this.reportTemplates = null;
    this.permissions = null;
    this.errors = null;
    this.matchingUserGroup = null;
    this.contentHolders = null;
    this.policy = null;
    if (args) {
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.comments !== undefined && args.comments !== null) {
        this.comments = Thrift.copyList(args.comments, [DocumentComment]);
      }
      if (args.relations !== undefined && args.relations !== null) {
        this.relations = Thrift.copyList(args.relations, [DocumentRelation]);
      }
      if (args.contentTabs !== undefined && args.contentTabs !== null) {
        this.contentTabs = Thrift.copyList(args.contentTabs, [ContentTab]);
      }
      if (args.securityClassifications !== undefined && args.securityClassifications !== null) {
        this.securityClassifications = Thrift.copyList(args.securityClassifications, [SecurityClassification]);
      }
      if (args.deadlineHistories !== undefined && args.deadlineHistories !== null) {
        this.deadlineHistories = Thrift.copyList(args.deadlineHistories, [DeadlineHistory]);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [Attachment]);
      }
      if (args.reportTemplates !== undefined && args.reportTemplates !== null) {
        this.reportTemplates = Thrift.copyList(args.reportTemplates, [ReportTemplate]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new DocPermissions(args.permissions);
      }
      if (args.errors !== undefined && args.errors !== null) {
        this.errors = Thrift.copyMap(args.errors, [null]);
      }
      if (args.matchingUserGroup !== undefined && args.matchingUserGroup !== null) {
        this.matchingUserGroup = Thrift.copyList(args.matchingUserGroup, [MatchingUserGroup]);
      }
      if (args.contentHolders !== undefined && args.contentHolders !== null) {
        this.contentHolders = Thrift.copyList(args.contentHolders, [ContentHolderShowPlace]);
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.comments = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new DocumentComment();
            elem8.read(input);
            this.comments.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.relations = [];
          const _rtmp310 = input.readListBegin();
          const _size9 = _rtmp310.size || 0;
          for (let _i11 = 0; _i11 < _size9; ++_i11) {
            let elem12 = null;
            elem12 = new DocumentRelation();
            elem12.read(input);
            this.relations.push(elem12);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.contentTabs = [];
          const _rtmp314 = input.readListBegin();
          const _size13 = _rtmp314.size || 0;
          for (let _i15 = 0; _i15 < _size13; ++_i15) {
            let elem16 = null;
            elem16 = new ContentTab();
            elem16.read(input);
            this.contentTabs.push(elem16);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassifications = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = new SecurityClassification();
            elem20.read(input);
            this.securityClassifications.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.deadlineHistories = [];
          const _rtmp322 = input.readListBegin();
          const _size21 = _rtmp322.size || 0;
          for (let _i23 = 0; _i23 < _size21; ++_i23) {
            let elem24 = null;
            elem24 = new DeadlineHistory();
            elem24.read(input);
            this.deadlineHistories.push(elem24);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new Attachment();
            elem28.read(input);
            this.attachments.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.reportTemplates = [];
          const _rtmp330 = input.readListBegin();
          const _size29 = _rtmp330.size || 0;
          for (let _i31 = 0; _i31 < _size29; ++_i31) {
            let elem32 = null;
            elem32 = new ReportTemplate();
            elem32.read(input);
            this.reportTemplates.push(elem32);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new DocPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.MAP) {
          this.errors = {};
          const _rtmp334 = input.readMapBegin();
          const _size33 = _rtmp334.size || 0;
          for (let _i35 = 0; _i35 < _size33; ++_i35) {
            if (_i35 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key36 = null;
            let val37 = null;
            key36 = input.readString().value;
            val37 = input.readString().value;
            this.errors[key36] = val37;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.LIST) {
          this.matchingUserGroup = [];
          const _rtmp339 = input.readListBegin();
          const _size38 = _rtmp339.size || 0;
          for (let _i40 = 0; _i40 < _size38; ++_i40) {
            let elem41 = null;
            elem41 = new MatchingUserGroup();
            elem41.read(input);
            this.matchingUserGroup.push(elem41);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.LIST) {
          this.contentHolders = [];
          const _rtmp343 = input.readListBegin();
          const _size42 = _rtmp343.size || 0;
          for (let _i44 = 0; _i44 < _size42; ++_i44) {
            let elem45 = null;
            elem45 = new ContentHolderShowPlace();
            elem45.read(input);
            this.contentHolders.push(elem45);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AggregationDocumentData');
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 1);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.comments !== null && this.comments !== undefined) {
      output.writeFieldBegin('comments', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.comments.length);
      for (let iter46 in this.comments) {
        if (this.comments.hasOwnProperty(iter46)) {
          iter46 = this.comments[iter46];
          iter46.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.relations !== null && this.relations !== undefined) {
      output.writeFieldBegin('relations', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.relations.length);
      for (let iter47 in this.relations) {
        if (this.relations.hasOwnProperty(iter47)) {
          iter47 = this.relations[iter47];
          iter47.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.contentTabs !== null && this.contentTabs !== undefined) {
      output.writeFieldBegin('contentTabs', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentTabs.length);
      for (let iter48 in this.contentTabs) {
        if (this.contentTabs.hasOwnProperty(iter48)) {
          iter48 = this.contentTabs[iter48];
          iter48.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.securityClassifications !== null && this.securityClassifications !== undefined) {
      output.writeFieldBegin('securityClassifications', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.securityClassifications.length);
      for (let iter49 in this.securityClassifications) {
        if (this.securityClassifications.hasOwnProperty(iter49)) {
          iter49 = this.securityClassifications[iter49];
          iter49.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.deadlineHistories !== null && this.deadlineHistories !== undefined) {
      output.writeFieldBegin('deadlineHistories', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.deadlineHistories.length);
      for (let iter50 in this.deadlineHistories) {
        if (this.deadlineHistories.hasOwnProperty(iter50)) {
          iter50 = this.deadlineHistories[iter50];
          iter50.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter51 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter51)) {
          iter51 = this.attachments[iter51];
          iter51.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.reportTemplates !== null && this.reportTemplates !== undefined) {
      output.writeFieldBegin('reportTemplates', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.reportTemplates.length);
      for (let iter52 in this.reportTemplates) {
        if (this.reportTemplates.hasOwnProperty(iter52)) {
          iter52 = this.reportTemplates[iter52];
          iter52.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 11);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    if (this.errors !== null && this.errors !== undefined) {
      output.writeFieldBegin('errors', Thrift.Type.MAP, 12);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.errors));
      for (let kiter53 in this.errors) {
        if (this.errors.hasOwnProperty(kiter53)) {
          let viter54 = this.errors[kiter53];
          output.writeString(kiter53);
          output.writeString(viter54);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.matchingUserGroup !== null && this.matchingUserGroup !== undefined) {
      output.writeFieldBegin('matchingUserGroup', Thrift.Type.LIST, 13);
      output.writeListBegin(Thrift.Type.STRUCT, this.matchingUserGroup.length);
      for (let iter55 in this.matchingUserGroup) {
        if (this.matchingUserGroup.hasOwnProperty(iter55)) {
          iter55 = this.matchingUserGroup[iter55];
          iter55.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.contentHolders !== null && this.contentHolders !== undefined) {
      output.writeFieldBegin('contentHolders', Thrift.Type.LIST, 14);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentHolders.length);
      for (let iter56 in this.contentHolders) {
        if (this.contentHolders.hasOwnProperty(iter56)) {
          iter56 = this.contentHolders[iter56];
          iter56.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 15);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Registry = class {
  constructor(args) {
    this.id = null;
    this.regName = null;
    this.regDescription = null;
    this.viewRule = null;
    this.userOrGrList = null;
    this.accountList = null;
    this.autoDownload = null;
    this.position = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.regName !== undefined && args.regName !== null) {
        this.regName = args.regName;
      }
      if (args.regDescription !== undefined && args.regDescription !== null) {
        this.regDescription = args.regDescription;
      }
      if (args.viewRule !== undefined && args.viewRule !== null) {
        this.viewRule = args.viewRule;
      }
      if (args.userOrGrList !== undefined && args.userOrGrList !== null) {
        this.userOrGrList = Thrift.copyList(args.userOrGrList, [UserOrGroup]);
      }
      if (args.accountList !== undefined && args.accountList !== null) {
        this.accountList = Thrift.copyList(args.accountList, [Account]);
      }
      if (args.autoDownload !== undefined && args.autoDownload !== null) {
        this.autoDownload = args.autoDownload;
      }
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.regName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.regDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.viewRule = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGrList = [];
          const _rtmp358 = input.readListBegin();
          const _size57 = _rtmp358.size || 0;
          for (let _i59 = 0; _i59 < _size57; ++_i59) {
            let elem60 = null;
            elem60 = new UserOrGroup();
            elem60.read(input);
            this.userOrGrList.push(elem60);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.accountList = [];
          const _rtmp362 = input.readListBegin();
          const _size61 = _rtmp362.size || 0;
          for (let _i63 = 0; _i63 < _size61; ++_i63) {
            let elem64 = null;
            elem64 = new Account();
            elem64.read(input);
            this.accountList.push(elem64);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.autoDownload = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.position = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Registry');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.regName !== null && this.regName !== undefined) {
      output.writeFieldBegin('regName', Thrift.Type.STRING, 2);
      output.writeString(this.regName);
      output.writeFieldEnd();
    }
    if (this.regDescription !== null && this.regDescription !== undefined) {
      output.writeFieldBegin('regDescription', Thrift.Type.STRING, 3);
      output.writeString(this.regDescription);
      output.writeFieldEnd();
    }
    if (this.viewRule !== null && this.viewRule !== undefined) {
      output.writeFieldBegin('viewRule', Thrift.Type.STRING, 4);
      output.writeString(this.viewRule);
      output.writeFieldEnd();
    }
    if (this.userOrGrList !== null && this.userOrGrList !== undefined) {
      output.writeFieldBegin('userOrGrList', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGrList.length);
      for (let iter65 in this.userOrGrList) {
        if (this.userOrGrList.hasOwnProperty(iter65)) {
          iter65 = this.userOrGrList[iter65];
          iter65.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accountList !== null && this.accountList !== undefined) {
      output.writeFieldBegin('accountList', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.accountList.length);
      for (let iter66 in this.accountList) {
        if (this.accountList.hasOwnProperty(iter66)) {
          iter66 = this.accountList[iter66];
          iter66.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.autoDownload !== null && this.autoDownload !== undefined) {
      output.writeFieldBegin('autoDownload', Thrift.Type.BOOL, 7);
      output.writeBool(this.autoDownload);
      output.writeFieldEnd();
    }
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.I32, 8);
      output.writeI32(this.position);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


DeviceType = {
  'ANDROID' : 0,
  'IOS' : 1,
  'WEB' : 2
};
Device = class {
  constructor(args) {
    this.firebaseId = null;
    this.clientId = null;
    this.createDate = null;
    this.lastWorkDate = null;
    this.type = null;
    this.deviceId = null;
    if (args) {
      if (args.firebaseId !== undefined && args.firebaseId !== null) {
        this.firebaseId = args.firebaseId;
      }
      if (args.clientId !== undefined && args.clientId !== null) {
        this.clientId = args.clientId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.lastWorkDate !== undefined && args.lastWorkDate !== null) {
        this.lastWorkDate = args.lastWorkDate;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.deviceId !== undefined && args.deviceId !== null) {
        this.deviceId = args.deviceId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.firebaseId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.clientId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.lastWorkDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.deviceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Device');
    if (this.firebaseId !== null && this.firebaseId !== undefined) {
      output.writeFieldBegin('firebaseId', Thrift.Type.STRING, 1);
      output.writeString(this.firebaseId);
      output.writeFieldEnd();
    }
    if (this.clientId !== null && this.clientId !== undefined) {
      output.writeFieldBegin('clientId', Thrift.Type.STRING, 2);
      output.writeString(this.clientId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 3);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.lastWorkDate !== null && this.lastWorkDate !== undefined) {
      output.writeFieldBegin('lastWorkDate', Thrift.Type.I64, 4);
      output.writeI64(this.lastWorkDate);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 5);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.deviceId !== null && this.deviceId !== undefined) {
      output.writeFieldBegin('deviceId', Thrift.Type.STRING, 6);
      output.writeString(this.deviceId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AuthSession = class {
  constructor(args) {
    this.id = null;
    this.expireDate = null;
    this.createDate = null;
    this.updateDate = null;
    this.ip1 = null;
    this.ip2 = null;
    this.clientInfo = null;
    this.roles = null;
    this.delegateClientInfo = null;
    this.needChangePassword = null;
    this.token = null;
    this.langCode = null;
    this.blockedRoles = null;
    this.deviceId = null;
    this.deviceType = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.expireDate !== undefined && args.expireDate !== null) {
        this.expireDate = args.expireDate;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.updateDate !== undefined && args.updateDate !== null) {
        this.updateDate = args.updateDate;
      }
      if (args.ip1 !== undefined && args.ip1 !== null) {
        this.ip1 = args.ip1;
      }
      if (args.ip2 !== undefined && args.ip2 !== null) {
        this.ip2 = args.ip2;
      }
      if (args.clientInfo !== undefined && args.clientInfo !== null) {
        this.clientInfo = new UserOrGroup(args.clientInfo);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [null]);
      }
      if (args.delegateClientInfo !== undefined && args.delegateClientInfo !== null) {
        this.delegateClientInfo = new UserOrGroup(args.delegateClientInfo);
      }
      if (args.needChangePassword !== undefined && args.needChangePassword !== null) {
        this.needChangePassword = args.needChangePassword;
      }
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
      if (args.blockedRoles !== undefined && args.blockedRoles !== null) {
        this.blockedRoles = Thrift.copyList(args.blockedRoles, [null]);
      }
      if (args.deviceId !== undefined && args.deviceId !== null) {
        this.deviceId = args.deviceId;
      }
      if (args.deviceType !== undefined && args.deviceType !== null) {
        this.deviceType = args.deviceType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.expireDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.updateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.ip1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.ip2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.clientInfo = new UserOrGroup();
          this.clientInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.SET) {
          this.roles = [];
          const _rtmp31 = input.readSetBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString().value;
            this.roles.push(elem3);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.delegateClientInfo = new UserOrGroup();
          this.delegateClientInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.needChangePassword = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.SET) {
          this.blockedRoles = [];
          const _rtmp35 = input.readSetBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = input.readString().value;
            this.blockedRoles.push(elem7);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.deviceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.deviceType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AuthSession');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.expireDate !== null && this.expireDate !== undefined) {
      output.writeFieldBegin('expireDate', Thrift.Type.I64, 2);
      output.writeI64(this.expireDate);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 3);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.updateDate !== null && this.updateDate !== undefined) {
      output.writeFieldBegin('updateDate', Thrift.Type.I64, 4);
      output.writeI64(this.updateDate);
      output.writeFieldEnd();
    }
    if (this.ip1 !== null && this.ip1 !== undefined) {
      output.writeFieldBegin('ip1', Thrift.Type.STRING, 5);
      output.writeString(this.ip1);
      output.writeFieldEnd();
    }
    if (this.ip2 !== null && this.ip2 !== undefined) {
      output.writeFieldBegin('ip2', Thrift.Type.STRING, 6);
      output.writeString(this.ip2);
      output.writeFieldEnd();
    }
    if (this.clientInfo !== null && this.clientInfo !== undefined) {
      output.writeFieldBegin('clientInfo', Thrift.Type.STRUCT, 7);
      this.clientInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.SET, 8);
      output.writeSetBegin(Thrift.Type.STRING, this.roles.length);
      for (let iter8 in this.roles) {
        if (this.roles.hasOwnProperty(iter8)) {
          iter8 = this.roles[iter8];
          output.writeString(iter8);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.delegateClientInfo !== null && this.delegateClientInfo !== undefined) {
      output.writeFieldBegin('delegateClientInfo', Thrift.Type.STRUCT, 9);
      this.delegateClientInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.needChangePassword !== null && this.needChangePassword !== undefined) {
      output.writeFieldBegin('needChangePassword', Thrift.Type.BOOL, 10);
      output.writeBool(this.needChangePassword);
      output.writeFieldEnd();
    }
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 11);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 12);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    if (this.blockedRoles !== null && this.blockedRoles !== undefined) {
      output.writeFieldBegin('blockedRoles', Thrift.Type.SET, 13);
      output.writeSetBegin(Thrift.Type.STRING, this.blockedRoles.length);
      for (let iter9 in this.blockedRoles) {
        if (this.blockedRoles.hasOwnProperty(iter9)) {
          iter9 = this.blockedRoles[iter9];
          output.writeString(iter9);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.deviceId !== null && this.deviceId !== undefined) {
      output.writeFieldBegin('deviceId', Thrift.Type.STRING, 14);
      output.writeString(this.deviceId);
      output.writeFieldEnd();
    }
    if (this.deviceType !== null && this.deviceType !== undefined) {
      output.writeFieldBegin('deviceType', Thrift.Type.I32, 15);
      output.writeI32(this.deviceType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


CalendarSharingMode = {
  'READ_ONLY' : 0,
  'READ_WRITE' : 1
};
CalendarEvent = class {
  constructor(args) {
    this.id = null;
    this.startDate = null;
    this.endDate = null;
    this.nameCalendarEvent = null;
    this.descriptionCalendarEvent = null;
    this.remindDate = null;
    this.jiraPeriod = null;
    this.authorId = null;
    this.color = null;
    this.location = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.startDate !== undefined && args.startDate !== null) {
        this.startDate = args.startDate;
      }
      if (args.endDate !== undefined && args.endDate !== null) {
        this.endDate = args.endDate;
      }
      if (args.nameCalendarEvent !== undefined && args.nameCalendarEvent !== null) {
        this.nameCalendarEvent = args.nameCalendarEvent;
      }
      if (args.descriptionCalendarEvent !== undefined && args.descriptionCalendarEvent !== null) {
        this.descriptionCalendarEvent = args.descriptionCalendarEvent;
      }
      if (args.remindDate !== undefined && args.remindDate !== null) {
        this.remindDate = args.remindDate;
      }
      if (args.jiraPeriod !== undefined && args.jiraPeriod !== null) {
        this.jiraPeriod = args.jiraPeriod;
      }
      if (args.authorId !== undefined && args.authorId !== null) {
        this.authorId = args.authorId;
      }
      if (args.color !== undefined && args.color !== null) {
        this.color = args.color;
      }
      if (args.location !== undefined && args.location !== null) {
        this.location = args.location;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.startDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.endDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nameCalendarEvent = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionCalendarEvent = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.remindDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.jiraPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.authorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.color = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.location = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarEvent');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.startDate !== null && this.startDate !== undefined) {
      output.writeFieldBegin('startDate', Thrift.Type.I64, 2);
      output.writeI64(this.startDate);
      output.writeFieldEnd();
    }
    if (this.endDate !== null && this.endDate !== undefined) {
      output.writeFieldBegin('endDate', Thrift.Type.I64, 3);
      output.writeI64(this.endDate);
      output.writeFieldEnd();
    }
    if (this.nameCalendarEvent !== null && this.nameCalendarEvent !== undefined) {
      output.writeFieldBegin('nameCalendarEvent', Thrift.Type.STRING, 4);
      output.writeString(this.nameCalendarEvent);
      output.writeFieldEnd();
    }
    if (this.descriptionCalendarEvent !== null && this.descriptionCalendarEvent !== undefined) {
      output.writeFieldBegin('descriptionCalendarEvent', Thrift.Type.STRING, 5);
      output.writeString(this.descriptionCalendarEvent);
      output.writeFieldEnd();
    }
    if (this.remindDate !== null && this.remindDate !== undefined) {
      output.writeFieldBegin('remindDate', Thrift.Type.I64, 6);
      output.writeI64(this.remindDate);
      output.writeFieldEnd();
    }
    if (this.jiraPeriod !== null && this.jiraPeriod !== undefined) {
      output.writeFieldBegin('jiraPeriod', Thrift.Type.STRING, 7);
      output.writeString(this.jiraPeriod);
      output.writeFieldEnd();
    }
    if (this.authorId !== null && this.authorId !== undefined) {
      output.writeFieldBegin('authorId', Thrift.Type.STRING, 8);
      output.writeString(this.authorId);
      output.writeFieldEnd();
    }
    if (this.color !== null && this.color !== undefined) {
      output.writeFieldBegin('color', Thrift.Type.STRING, 9);
      output.writeString(this.color);
      output.writeFieldEnd();
    }
    if (this.location !== null && this.location !== undefined) {
      output.writeFieldBegin('location', Thrift.Type.STRING, 10);
      output.writeString(this.location);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarSharing = class {
  constructor(args) {
    this.id = null;
    this.userOrGroup = null;
    this.mode = null;
    this.creator = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.mode !== undefined && args.mode !== null) {
        this.mode = args.mode;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.mode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarSharing');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 2);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.mode !== null && this.mode !== undefined) {
      output.writeFieldBegin('mode', Thrift.Type.I32, 3);
      output.writeI32(this.mode);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 4);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Deadline = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.numberDocument = null;
    this.documentName = null;
    this.documentPatternId = null;
    this.authorName = null;
    this.actionType = null;
    this.assignedDate = null;
    this.reassignedDate = null;
    this.deadlineDate = null;
    this.control = null;
    this.informedAboutDeadline = null;
    this.documentSystemNumber = null;
    this.documentStatus = null;
    this.icon = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.numberDocument !== undefined && args.numberDocument !== null) {
        this.numberDocument = args.numberDocument;
      }
      if (args.documentName !== undefined && args.documentName !== null) {
        this.documentName = args.documentName;
      }
      if (args.documentPatternId !== undefined && args.documentPatternId !== null) {
        this.documentPatternId = args.documentPatternId;
      }
      if (args.authorName !== undefined && args.authorName !== null) {
        this.authorName = args.authorName;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.assignedDate !== undefined && args.assignedDate !== null) {
        this.assignedDate = args.assignedDate;
      }
      if (args.reassignedDate !== undefined && args.reassignedDate !== null) {
        this.reassignedDate = args.reassignedDate;
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.control !== undefined && args.control !== null) {
        this.control = args.control;
      }
      if (args.informedAboutDeadline !== undefined && args.informedAboutDeadline !== null) {
        this.informedAboutDeadline = args.informedAboutDeadline;
      }
      if (args.documentSystemNumber !== undefined && args.documentSystemNumber !== null) {
        this.documentSystemNumber = args.documentSystemNumber;
      }
      if (args.documentStatus !== undefined && args.documentStatus !== null) {
        this.documentStatus = args.documentStatus;
      }
      if (args.icon !== undefined && args.icon !== null) {
        this.icon = args.icon;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.numberDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.documentPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.authorName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.assignedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.reassignedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.control = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.informedAboutDeadline = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.documentSystemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.documentStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Deadline');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.numberDocument !== null && this.numberDocument !== undefined) {
      output.writeFieldBegin('numberDocument', Thrift.Type.STRING, 3);
      output.writeString(this.numberDocument);
      output.writeFieldEnd();
    }
    if (this.documentName !== null && this.documentName !== undefined) {
      output.writeFieldBegin('documentName', Thrift.Type.STRING, 4);
      output.writeString(this.documentName);
      output.writeFieldEnd();
    }
    if (this.documentPatternId !== null && this.documentPatternId !== undefined) {
      output.writeFieldBegin('documentPatternId', Thrift.Type.STRING, 5);
      output.writeString(this.documentPatternId);
      output.writeFieldEnd();
    }
    if (this.authorName !== null && this.authorName !== undefined) {
      output.writeFieldBegin('authorName', Thrift.Type.STRING, 6);
      output.writeString(this.authorName);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 7);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.assignedDate !== null && this.assignedDate !== undefined) {
      output.writeFieldBegin('assignedDate', Thrift.Type.I64, 8);
      output.writeI64(this.assignedDate);
      output.writeFieldEnd();
    }
    if (this.reassignedDate !== null && this.reassignedDate !== undefined) {
      output.writeFieldBegin('reassignedDate', Thrift.Type.I64, 9);
      output.writeI64(this.reassignedDate);
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 10);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.control !== null && this.control !== undefined) {
      output.writeFieldBegin('control', Thrift.Type.BOOL, 11);
      output.writeBool(this.control);
      output.writeFieldEnd();
    }
    if (this.informedAboutDeadline !== null && this.informedAboutDeadline !== undefined) {
      output.writeFieldBegin('informedAboutDeadline', Thrift.Type.BOOL, 12);
      output.writeBool(this.informedAboutDeadline);
      output.writeFieldEnd();
    }
    if (this.documentSystemNumber !== null && this.documentSystemNumber !== undefined) {
      output.writeFieldBegin('documentSystemNumber', Thrift.Type.STRING, 13);
      output.writeString(this.documentSystemNumber);
      output.writeFieldEnd();
    }
    if (this.documentStatus !== null && this.documentStatus !== undefined) {
      output.writeFieldBegin('documentStatus', Thrift.Type.I32, 14);
      output.writeI32(this.documentStatus);
      output.writeFieldEnd();
    }
    if (this.icon !== null && this.icon !== undefined) {
      output.writeFieldBegin('icon', Thrift.Type.I32, 15);
      output.writeI32(this.icon);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CalendarBusinessEvent = class {
  constructor(args) {
    this.id = null;
    this.eDescription = null;
    this.user = null;
    this.events = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.eDescription !== undefined && args.eDescription !== null) {
        this.eDescription = args.eDescription;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = args.user;
      }
      if (args.events !== undefined && args.events !== null) {
        this.events = Thrift.copyList(args.events, [CalendarEvent]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.eDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.user = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.events = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new CalendarEvent();
            elem3.read(input);
            this.events.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CalendarBusinessEvent');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.eDescription !== null && this.eDescription !== undefined) {
      output.writeFieldBegin('eDescription', Thrift.Type.STRING, 2);
      output.writeString(this.eDescription);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.BOOL, 3);
      output.writeBool(this.user);
      output.writeFieldEnd();
    }
    if (this.events !== null && this.events !== undefined) {
      output.writeFieldBegin('events', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.events.length);
      for (let iter4 in this.events) {
        if (this.events.hasOwnProperty(iter4)) {
          iter4 = this.events[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
WeekendDictionary = class {
  constructor(args) {
    this.id = null;
    this.weekendDate = null;
    this.holiday = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.weekendDate !== undefined && args.weekendDate !== null) {
        this.weekendDate = args.weekendDate;
      }
      if (args.holiday !== undefined && args.holiday !== null) {
        this.holiday = args.holiday;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.weekendDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.holiday = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('WeekendDictionary');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.weekendDate !== null && this.weekendDate !== undefined) {
      output.writeFieldBegin('weekendDate', Thrift.Type.I64, 2);
      output.writeI64(this.weekendDate);
      output.writeFieldEnd();
    }
    if (this.holiday !== null && this.holiday !== undefined) {
      output.writeFieldBegin('holiday', Thrift.Type.BOOL, 3);
      output.writeBool(this.holiday);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


PatternRoles = {
  'VIEW' : 0,
  'CREATE' : 1,
  'INBOX' : 2,
  'OUTBOX' : 3,
  'ADMIN' : 4
};
RuleSelector = {
  'EDIT' : 0,
  'DECISION' : 1,
  'DOC_RULE' : 2
};
AvailablePattarnStageForm = {
  'CIRCLE' : 0,
  'RECTANGLE' : 1,
  'DIAMOND' : 2,
  'TRIANGLERIGHT' : 3,
  'TRIANGLEDOWN' : 4,
  'TRIANGLELEFT' : 5,
  'TRIANGLEUP' : 6,
  'PENTAGON' : 7,
  'HEXAGON' : 8,
  'RING' : 9,
  'NOTALLOWED' : 10,
  'ACTOR' : 11,
  'BPMMTASKMESSAGE' : 12,
  'BPMMEVENTTIMER' : 13,
  'BPMMEVENTCONDITIONAL' : 14,
  'BPMMTASKSCRIPT' : 15,
  'ROUNDEDRECTANGLE' : 16
};
ModifyEnable = {
  'ENABLED' : 0,
  'PARTIAL' : 1,
  'DISABLED' : 2
};
AvailablePatternStageType = {
  'INTERNAL' : 0,
  'AUTO' : 1,
  'EXTERNAL' : 2,
  'SUB_PATTERN' : 3,
  'REPORT' : 4,
  'HIDDEN' : 5,
  'WAIT_CHILD_DOCS' : 6,
  'CREATE_CHILD_BY_ROLE' : 7,
  'EMAIL' : 8,
  'SMS' : 9
};
PatternData = class {
  constructor(args) {
    this.stages = null;
    this.links = null;
    if (args) {
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.links !== undefined && args.links !== null) {
        this.links = Thrift.copyList(args.links, [DocumentPatternStagesLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new DocumentPatternStage();
            elem3.read(input);
            this.stages.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.links = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = new DocumentPatternStagesLink();
            elem7.read(input);
            this.links.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternData');
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter8 in this.stages) {
        if (this.stages.hasOwnProperty(iter8)) {
          iter8 = this.stages[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.links !== null && this.links !== undefined) {
      output.writeFieldBegin('links', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.links.length);
      for (let iter9 in this.links) {
        if (this.links.hasOwnProperty(iter9)) {
          iter9 = this.links[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternStagesExecutor = class {
  constructor(args) {
    this.id = null;
    this.docStageId = null;
    this.userOrGroup = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.docStageId !== undefined && args.docStageId !== null) {
        this.docStageId = args.docStageId;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternStagesExecutor');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.docStageId !== null && this.docStageId !== undefined) {
      output.writeFieldBegin('docStageId', Thrift.Type.STRING, 2);
      output.writeString(this.docStageId);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 3);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DigitalView = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.creatorId = null;
    this.documentPattern = null;
    this.oName = null;
    this.context = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.documentPattern !== undefined && args.documentPattern !== null) {
        this.documentPattern = args.documentPattern;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.context !== undefined && args.context !== null) {
        this.context = args.context;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.context = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DigitalView');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 3);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.documentPattern !== null && this.documentPattern !== undefined) {
      output.writeFieldBegin('documentPattern', Thrift.Type.STRING, 4);
      output.writeString(this.documentPattern);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 5);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.context !== null && this.context !== undefined) {
      output.writeFieldBegin('context', Thrift.Type.STRING, 6);
      output.writeString(this.context);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AvailablePatternStage = class {
  constructor(args) {
    this.id = null;
    this.formAvail = null;
    this.img = null;
    this.nameAvail = null;
    this.descriptionAvail = null;
    this.status = null;
    this.adParams = null;
    this.availableAnswers = null;
    this.fixedDecisions = null;
    this.availType = null;
    this.color = null;
    this.scale = null;
    this.orderNum = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.formAvail !== undefined && args.formAvail !== null) {
        this.formAvail = args.formAvail;
      }
      if (args.img !== undefined && args.img !== null) {
        this.img = args.img;
      }
      if (args.nameAvail !== undefined && args.nameAvail !== null) {
        this.nameAvail = args.nameAvail;
      }
      if (args.descriptionAvail !== undefined && args.descriptionAvail !== null) {
        this.descriptionAvail = args.descriptionAvail;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [StageParam]);
      }
      if (args.availableAnswers !== undefined && args.availableAnswers !== null) {
        this.availableAnswers = Thrift.copyList(args.availableAnswers, [null]);
      }
      if (args.fixedDecisions !== undefined && args.fixedDecisions !== null) {
        this.fixedDecisions = args.fixedDecisions;
      }
      if (args.availType !== undefined && args.availType !== null) {
        this.availType = args.availType;
      }
      if (args.color !== undefined && args.color !== null) {
        this.color = args.color;
      }
      if (args.scale !== undefined && args.scale !== null) {
        this.scale = args.scale;
      }
      if (args.orderNum !== undefined && args.orderNum !== null) {
        this.orderNum = args.orderNum;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.formAvail = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.img = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nameAvail = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionAvail = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new StageParam();
            elem13.read(input);
            this.adParams.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.SET) {
          this.availableAnswers = [];
          const _rtmp315 = input.readSetBegin();
          const _size14 = _rtmp315.size || 0;
          for (let _i16 = 0; _i16 < _size14; ++_i16) {
            let elem17 = null;
            elem17 = input.readString().value;
            this.availableAnswers.push(elem17);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.fixedDecisions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.availType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.color = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.scale = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.orderNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AvailablePatternStage');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.formAvail !== null && this.formAvail !== undefined) {
      output.writeFieldBegin('formAvail', Thrift.Type.I32, 2);
      output.writeI32(this.formAvail);
      output.writeFieldEnd();
    }
    if (this.img !== null && this.img !== undefined) {
      output.writeFieldBegin('img', Thrift.Type.STRING, 3);
      output.writeString(this.img);
      output.writeFieldEnd();
    }
    if (this.nameAvail !== null && this.nameAvail !== undefined) {
      output.writeFieldBegin('nameAvail', Thrift.Type.STRING, 4);
      output.writeString(this.nameAvail);
      output.writeFieldEnd();
    }
    if (this.descriptionAvail !== null && this.descriptionAvail !== undefined) {
      output.writeFieldBegin('descriptionAvail', Thrift.Type.STRING, 5);
      output.writeString(this.descriptionAvail);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 6);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter18 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter18)) {
          iter18 = this.adParams[iter18];
          iter18.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.availableAnswers !== null && this.availableAnswers !== undefined) {
      output.writeFieldBegin('availableAnswers', Thrift.Type.SET, 8);
      output.writeSetBegin(Thrift.Type.STRING, this.availableAnswers.length);
      for (let iter19 in this.availableAnswers) {
        if (this.availableAnswers.hasOwnProperty(iter19)) {
          iter19 = this.availableAnswers[iter19];
          output.writeString(iter19);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.fixedDecisions !== null && this.fixedDecisions !== undefined) {
      output.writeFieldBegin('fixedDecisions', Thrift.Type.I32, 9);
      output.writeI32(this.fixedDecisions);
      output.writeFieldEnd();
    }
    if (this.availType !== null && this.availType !== undefined) {
      output.writeFieldBegin('availType', Thrift.Type.I32, 10);
      output.writeI32(this.availType);
      output.writeFieldEnd();
    }
    if (this.color !== null && this.color !== undefined) {
      output.writeFieldBegin('color', Thrift.Type.STRING, 11);
      output.writeString(this.color);
      output.writeFieldEnd();
    }
    if (this.scale !== null && this.scale !== undefined) {
      output.writeFieldBegin('scale', Thrift.Type.I32, 12);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.orderNum !== null && this.orderNum !== undefined) {
      output.writeFieldBegin('orderNum', Thrift.Type.I32, 13);
      output.writeI32(this.orderNum);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternAttachmentTemplate = class {
  constructor(args) {
    this.id = null;
    this.creatorId = null;
    this.createDate = null;
    this.patternId = null;
    this.oName = null;
    this.size = null;
    this.externalId = null;
    this.autoAdd = null;
    this.disableEditAutoAttachmentOnCreate = null;
    this.disableDeleteAutoAttachmentOnCreate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.size !== undefined && args.size !== null) {
        this.size = args.size;
      }
      if (args.externalId !== undefined && args.externalId !== null) {
        this.externalId = args.externalId;
      }
      if (args.autoAdd !== undefined && args.autoAdd !== null) {
        this.autoAdd = args.autoAdd;
      }
      if (args.disableEditAutoAttachmentOnCreate !== undefined && args.disableEditAutoAttachmentOnCreate !== null) {
        this.disableEditAutoAttachmentOnCreate = args.disableEditAutoAttachmentOnCreate;
      }
      if (args.disableDeleteAutoAttachmentOnCreate !== undefined && args.disableDeleteAutoAttachmentOnCreate !== null) {
        this.disableDeleteAutoAttachmentOnCreate = args.disableDeleteAutoAttachmentOnCreate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.size = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.externalId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.autoAdd = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.disableEditAutoAttachmentOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.disableDeleteAutoAttachmentOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternAttachmentTemplate');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 2);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 3);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 4);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 5);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
      output.writeFieldBegin('size', Thrift.Type.I64, 6);
      output.writeI64(this.size);
      output.writeFieldEnd();
    }
    if (this.externalId !== null && this.externalId !== undefined) {
      output.writeFieldBegin('externalId', Thrift.Type.STRING, 7);
      output.writeString(this.externalId);
      output.writeFieldEnd();
    }
    if (this.autoAdd !== null && this.autoAdd !== undefined) {
      output.writeFieldBegin('autoAdd', Thrift.Type.BOOL, 8);
      output.writeBool(this.autoAdd);
      output.writeFieldEnd();
    }
    if (this.disableEditAutoAttachmentOnCreate !== null && this.disableEditAutoAttachmentOnCreate !== undefined) {
      output.writeFieldBegin('disableEditAutoAttachmentOnCreate', Thrift.Type.BOOL, 9);
      output.writeBool(this.disableEditAutoAttachmentOnCreate);
      output.writeFieldEnd();
    }
    if (this.disableDeleteAutoAttachmentOnCreate !== null && this.disableDeleteAutoAttachmentOnCreate !== undefined) {
      output.writeFieldBegin('disableDeleteAutoAttachmentOnCreate', Thrift.Type.BOOL, 10);
      output.writeBool(this.disableDeleteAutoAttachmentOnCreate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternUserGroup = class {
  constructor(args) {
    this.userOrGroup = null;
    this.roles = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.SET) {
          this.roles = [];
          const _rtmp321 = input.readSetBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = input.readString().value;
            this.roles.push(elem23);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternUserGroup');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 1);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.SET, 2);
      output.writeSetBegin(Thrift.Type.STRING, this.roles.length);
      for (let iter24 in this.roles) {
        if (this.roles.hasOwnProperty(iter24)) {
          iter24 = this.roles[iter24];
          output.writeString(iter24);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternRelationInfo = class {
  constructor(args) {
    this.id = null;
    this.name = null;
    this.descript = null;
    this.isValidState = null;
    this.documentPatternGroup = null;
    this.account = null;
    this.patternType = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.descript !== undefined && args.descript !== null) {
        this.descript = args.descript;
      }
      if (args.isValidState !== undefined && args.isValidState !== null) {
        this.isValidState = args.isValidState;
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.patternType !== undefined && args.patternType !== null) {
        this.patternType = args.patternType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.isValidState = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.patternType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternRelationInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.descript !== null && this.descript !== undefined) {
      output.writeFieldBegin('descript', Thrift.Type.STRING, 3);
      output.writeString(this.descript);
      output.writeFieldEnd();
    }
    if (this.isValidState !== null && this.isValidState !== undefined) {
      output.writeFieldBegin('isValidState', Thrift.Type.BOOL, 4);
      output.writeBool(this.isValidState);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 5);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 6);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.patternType !== null && this.patternType !== undefined) {
      output.writeFieldBegin('patternType', Thrift.Type.I32, 7);
      output.writeI32(this.patternType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternRelationLink = class {
  constructor(args) {
    this.parentId = null;
    this.childId = null;
    this.stageType = null;
    this.stageName = null;
    if (args) {
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.childId !== undefined && args.childId !== null) {
        this.childId = args.childId;
      }
      if (args.stageType !== undefined && args.stageType !== null) {
        this.stageType = args.stageType;
      }
      if (args.stageName !== undefined && args.stageName !== null) {
        this.stageName = args.stageName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.childId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.stageType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.stageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternRelationLink');
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 1);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.childId !== null && this.childId !== undefined) {
      output.writeFieldBegin('childId', Thrift.Type.STRING, 2);
      output.writeString(this.childId);
      output.writeFieldEnd();
    }
    if (this.stageType !== null && this.stageType !== undefined) {
      output.writeFieldBegin('stageType', Thrift.Type.I32, 3);
      output.writeI32(this.stageType);
      output.writeFieldEnd();
    }
    if (this.stageName !== null && this.stageName !== undefined) {
      output.writeFieldBegin('stageName', Thrift.Type.STRING, 4);
      output.writeString(this.stageName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternRelationModel = class {
  constructor(args) {
    this.patternId = null;
    this.relationInfoList = null;
    this.relationLinkList = null;
    if (args) {
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.relationInfoList !== undefined && args.relationInfoList !== null) {
        this.relationInfoList = Thrift.copyList(args.relationInfoList, [PatternRelationInfo]);
      }
      if (args.relationLinkList !== undefined && args.relationLinkList !== null) {
        this.relationLinkList = Thrift.copyList(args.relationLinkList, [PatternRelationLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.relationInfoList = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new PatternRelationInfo();
            elem28.read(input);
            this.relationInfoList.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.relationLinkList = [];
          const _rtmp330 = input.readListBegin();
          const _size29 = _rtmp330.size || 0;
          for (let _i31 = 0; _i31 < _size29; ++_i31) {
            let elem32 = null;
            elem32 = new PatternRelationLink();
            elem32.read(input);
            this.relationLinkList.push(elem32);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternRelationModel');
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 1);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.relationInfoList !== null && this.relationInfoList !== undefined) {
      output.writeFieldBegin('relationInfoList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.relationInfoList.length);
      for (let iter33 in this.relationInfoList) {
        if (this.relationInfoList.hasOwnProperty(iter33)) {
          iter33 = this.relationInfoList[iter33];
          iter33.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.relationLinkList !== null && this.relationLinkList !== undefined) {
      output.writeFieldBegin('relationLinkList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.relationLinkList.length);
      for (let iter34 in this.relationLinkList) {
        if (this.relationLinkList.hasOwnProperty(iter34)) {
          iter34 = this.relationLinkList[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
InfoForCreateDoc = class {
  constructor(args) {
    this.stages = null;
    this.scGrifs = null;
    this.templates = null;
    this.holders = null;
    this.permissions = null;
    if (args) {
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.scGrifs !== undefined && args.scGrifs !== null) {
        this.scGrifs = Thrift.copyList(args.scGrifs, [SecurityClassification]);
      }
      if (args.templates !== undefined && args.templates !== null) {
        this.templates = Thrift.copyList(args.templates, [PatternAttachmentTemplate]);
      }
      if (args.holders !== undefined && args.holders !== null) {
        this.holders = Thrift.copyList(args.holders, [ContentHolder]);
      }
      if (args.permissions !== undefined && args.permissions !== null) {
        this.permissions = new DocPermissions(args.permissions);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new DocumentPatternStage();
            elem38.read(input);
            this.stages.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.scGrifs = [];
          const _rtmp340 = input.readListBegin();
          const _size39 = _rtmp340.size || 0;
          for (let _i41 = 0; _i41 < _size39; ++_i41) {
            let elem42 = null;
            elem42 = new SecurityClassification();
            elem42.read(input);
            this.scGrifs.push(elem42);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.templates = [];
          const _rtmp344 = input.readListBegin();
          const _size43 = _rtmp344.size || 0;
          for (let _i45 = 0; _i45 < _size43; ++_i45) {
            let elem46 = null;
            elem46 = new PatternAttachmentTemplate();
            elem46.read(input);
            this.templates.push(elem46);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.holders = [];
          const _rtmp348 = input.readListBegin();
          const _size47 = _rtmp348.size || 0;
          for (let _i49 = 0; _i49 < _size47; ++_i49) {
            let elem50 = null;
            elem50 = new ContentHolder();
            elem50.read(input);
            this.holders.push(elem50);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.permissions = new DocPermissions();
          this.permissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('InfoForCreateDoc');
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter51 in this.stages) {
        if (this.stages.hasOwnProperty(iter51)) {
          iter51 = this.stages[iter51];
          iter51.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.scGrifs !== null && this.scGrifs !== undefined) {
      output.writeFieldBegin('scGrifs', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.scGrifs.length);
      for (let iter52 in this.scGrifs) {
        if (this.scGrifs.hasOwnProperty(iter52)) {
          iter52 = this.scGrifs[iter52];
          iter52.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.templates !== null && this.templates !== undefined) {
      output.writeFieldBegin('templates', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.templates.length);
      for (let iter53 in this.templates) {
        if (this.templates.hasOwnProperty(iter53)) {
          iter53 = this.templates[iter53];
          iter53.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holders !== null && this.holders !== undefined) {
      output.writeFieldBegin('holders', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.holders.length);
      for (let iter54 in this.holders) {
        if (this.holders.hasOwnProperty(iter54)) {
          iter54 = this.holders[iter54];
          iter54.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.permissions !== null && this.permissions !== undefined) {
      output.writeFieldBegin('permissions', Thrift.Type.STRUCT, 5);
      this.permissions.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ExecutionType = {
  'ANY_IMMEDIATELY' : 0,
  'ANY_WAIT_FOR_EXECUTORS' : 1,
  'ALL_EXECUTORS' : 2,
  'MOST_SET_DECISION' : 3
};
DocPatternStageRequirement = {
  'OPTIONAL' : 0,
  'REQUIRED' : 1,
  'PROHIBITED' : 2
};
AttachmentAction = {
  'PUBLISH_DRAFT' : 0,
  'IGNORE_DRAFT' : 1,
  'DELETE_DRAFT' : 2,
  'FIXATE_DRAFT' : 3
};
CloseWindowType = {
  'CLOSE' : 0,
  'NOT_CLOSE' : 1,
  'NOT_CLOSE_UPDATE' : 2
};
DocumentAccessPolicyType = {
  'ACCESS' : 0,
  'REGISTRY' : 1,
  'BY_ROLE' : 2,
  'EXTERNAL' : 3
};
DocumentIconType = {
  'ICON_DRAFT' : 0,
  'ICON_COMPLETE_CANCEL' : 1,
  'ICON_COMPLETE_EDITED' : 2,
  'ICON_COMPLETE' : 3,
  'ICON_IN_WORK_NO_MY_CANCEL' : 4,
  'ICON_IN_WORK_NO_MY_EDITED' : 5,
  'ICON_IN_WORK_NO_MY' : 6,
  'ICON_IN_WORK_EDITED' : 7,
  'ICON_IN_WORK_CANCELED' : 8,
  'ICON_IN_WORK' : 9,
  'ICON_IN_WORK_WARNING_EDITED' : 10,
  'ICON_IN_WORK_WARNING_CANCELED' : 11,
  'ICON_IN_WORK_WARNING' : 12,
  'ICON_IN_WORK_ERROR_EDITED' : 13,
  'ICON_IN_WORK_ERROR_CANCELED' : 14,
  'ICON_IN_WORK_ERROR' : 15,
  'ICON_ARCHIVE' : 16,
  'ICON_ERROR' : 17
};
PatternType = {
  'DOCUMENT' : 0,
  'DISCUSSION_FLOW' : 1,
  'DISCUSSION_QUESTION' : 2,
  'DISCUSSION_PROTOCOL' : 3
};
ContentItemShowType = {
  'SHORT' : 0,
  'FULL' : 1,
  'ALL' : 2
};
ContentItemShowPlace = {
  'INFO' : 0,
  'TAB' : 1,
  'CONTENT' : 2
};
ContentTableViewMode = {
  'TABLE' : 0,
  'BAND' : 1
};
ContentTableSelectMode = {
  'NONE' : 0,
  'SELECT' : 1,
  'MULTISELECT' : 2
};
ContentItemType = {
  'TEXT_FIELD' : 0,
  'COMBO_BOX' : 1,
  'USER_CHOICE' : 2,
  'CALENDAR' : 3,
  'TABLE' : 4,
  'SEPARATOR' : 5,
  'MULTILINE_TEXT_FIELD' : 6,
  'MARK' : 7,
  'CHECKBOX' : 8,
  'SWITCH_ITEM' : 9,
  'HTTP_LINK' : 10,
  'CALENDAR_RANGE' : 11,
  'CONTAINER' : 12,
  'HAND_BOOK' : 13,
  'ORG_STRUCTURE' : 14,
  'ATTACHMENT' : 15,
  'CURRENCY' : 16,
  'BUTTON' : 17
};
VisibilityOfBookmarks = {
  'SHOW' : 0,
  'NOT_SHOW' : 1,
  'EDITING' : 2
};
DocPatternStageStatus = {
  'CREATED' : 0,
  'IN_PROGRESS' : 1,
  'CLOSED' : 2,
  'ARCHIVE' : 3
};
DocPatternStageSubStatus = {
  'DRAFT' : 0,
  'PROJECT' : 1,
  'CONFIRM' : 2,
  'SIGN' : 3,
  'IN_WORK' : 4,
  'IN_EXECUTION' : 5,
  'CLOSED' : 6,
  'ACTING' : 7,
  'CANCELED' : 8,
  'ARCHIVE' : 9,
  'REGISTRATION' : 10,
  'ON_REVISION' : 11,
  'EDITED' : 12
};
DocPatternStageExecPriority = {
  'PARALLEL' : 0,
  'SERIES' : 1
};
DocPatternStageActionType = {
  'VIEW' : 0,
  'CONFIRM' : 1,
  'SIGN' : 2,
  'PERFORM' : 3
};
DispatchState = {
  'INBOX' : 0,
  'OUTBOX' : 1
};
StageParamType = {
  'STRING' : 0,
  'PATTERN' : 1,
  'REPORT' : 2,
  'COMBOBOX' : 3,
  'CHECKBOX' : 4,
  'SCRIPT' : 5,
  'DATETIME' : 6,
  'JIRATIME' : 7,
  'PATTERN_TO_USER' : 8
};
DocumentExecutionOwnerType = {
  'AUTHOR' : 0,
  'RESPONSIBLE' : 1,
  'EXECUTOR' : 2,
  'VIEWER' : 3,
  'SPECTATOR' : 4,
  'SYSTEM' : 5,
  'ADDITIONAL_CONFIRMER' : 6,
  'PERIODICAL_DISABLE' : 7
};
CommentType = {
  'DECISION' : 0,
  'COMMENT' : 1,
  'LINK' : 2,
  'CHANGE_SUB_STATUS' : 3,
  'DECISION_LINK' : 4
};
ExecutionReassignType = {
  'ANY' : 0,
  'CONTROL' : 1,
  'ALL' : 2,
  'ALL_EQUAL' : 3,
  'GROUP' : 4,
  'GROUP_ONE_ENOUGH' : 5
};
DocumentExecutionStatus = {
  'OPEN' : 0,
  'CLOSED' : 1,
  'CLOSED_ADDITIONAL' : 2,
  'FORCED_CLOSURE' : 3,
  'AUTO_CLOSED' : 4,
  'REVOKED' : 5,
  'REMOVED' : 6,
  'NONE' : 7,
  'DISABLED' : 8,
  'SOFT_REMOVED' : 9
};
FilterReassign = {
  'REASSIGN_TO_ME' : 0,
  'MY_REASSIGN' : 1,
  'CONTROL' : 2,
  'ALL_MY_DOCUMENTS' : 3,
  'MY_DOCUMENTS_IN_WORK' : 4,
  'DRAFTS' : 5,
  'MY_COMPLETED_DOCUMENTS' : 6,
  'MY_RESPONSIBLE' : 7,
  'COMPLETED_DOCUMENTS' : 8,
  'UNCOMPLETED_DOCUMENTS' : 9
};
AttachmentType = {
  'ORIGINAL' : 0,
  'PDF' : 1,
  'PNG' : 2,
  'PDF_UNSECURED' : 3
};
AttachmentAccessMode = {
  'NOPREVIEW' : 0,
  'READONLY' : 1,
  'REVIEW' : 2,
  'EDIT' : 3
};
AttachmentExtStatus = {
  'PRIMARY' : 0,
  'SECONDARY' : 1,
  'CARD' : 2,
  'CONTENT' : 3
};
SignInSystem = {
  'NONE' : 0,
  'ALMEX' : 1,
  'EXTERNAL' : 2,
  'BOTH' : 3
};
DocRelationType = {
  'PARENT' : 0,
  'CHILD' : 1,
  'OTHER' : 2,
  'MEETING' : 3
};
DocumentExecutionTypeLink = {
  'ALL' : 0,
  'PARENT' : 1,
  'CHILD' : 2
};
ChangeType = {
  'ADD' : 0,
  'REPLACE' : 1,
  'REMOVE' : 2
};
HistoryLevel = {
  'INFO' : 0,
  'WARNING' : 1,
  'ERROR' : 2
};
TodayTaskType = {
  'ALL' : 0,
  'OPEN' : 1,
  'CLOSED' : 2,
  'EVENT' : 3,
  'MEETING' : 4
};
DocumentExecutionStatisticType = {
  'EXPIRED' : 0,
  'DEADLINE_AFTER_DAY' : 1,
  'NOT_SOON_DEADLINE' : 2
};
AggregationRequiredType = {
  'DOCUMENT' : 0,
  'DOC_COMMENT' : 1,
  'DOC_RELATION' : 2,
  'CONTENT_TAB' : 3,
  'SC' : 4,
  'DEADLINE_HISTORY' : 5,
  'ATTACHMENT' : 6,
  'REPORT_TEMPLATE' : 7,
  'DOC_PERMISSION' : 8,
  'REGISTRY_RULE' : 9,
  'REGISTRY_USERS' : 10,
  'REGISTRY_ACCOUNTS' : 11,
  'MATCHING_USER_GROUP' : 12,
  'CONTENT_HOLDER' : 13
};
AttachmentProcessingType = {
  'NONE' : 0,
  'DELETE' : 1,
  'PROCESS' : 2
};
DocumentTagType = {
  'COLOR' : 0,
  'FAVORITE' : 1,
  'TEXT' : 2
};
AccessRule = class {
  constructor(args) {
    this.forAuthor = null;
    this.forResponsible = null;
    this.forExecutors = null;
    this.forUserOrGroup = null;
    this.forRole = null;
    this.allowList = null;
    this.allowRole = null;
    this.forAllDocView = null;
    if (args) {
      if (args.forAuthor !== undefined && args.forAuthor !== null) {
        this.forAuthor = args.forAuthor;
      }
      if (args.forResponsible !== undefined && args.forResponsible !== null) {
        this.forResponsible = args.forResponsible;
      }
      if (args.forExecutors !== undefined && args.forExecutors !== null) {
        this.forExecutors = args.forExecutors;
      }
      if (args.forUserOrGroup !== undefined && args.forUserOrGroup !== null) {
        this.forUserOrGroup = args.forUserOrGroup;
      }
      if (args.forRole !== undefined && args.forRole !== null) {
        this.forRole = args.forRole;
      }
      if (args.allowList !== undefined && args.allowList !== null) {
        this.allowList = Thrift.copyList(args.allowList, [UserOrGroup]);
      }
      if (args.allowRole !== undefined && args.allowRole !== null) {
        this.allowRole = Thrift.copyList(args.allowRole, [null]);
      }
      if (args.forAllDocView !== undefined && args.forAllDocView !== null) {
        this.forAllDocView = args.forAllDocView;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.forAuthor = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.forResponsible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.forExecutors = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.forUserOrGroup = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.forRole = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.allowList = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new UserOrGroup();
            elem3.read(input);
            this.allowList.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.allowRole = [];
          const _rtmp35 = input.readSetBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = input.readString().value;
            this.allowRole.push(elem7);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forAllDocView = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccessRule');
    if (this.forAuthor !== null && this.forAuthor !== undefined) {
      output.writeFieldBegin('forAuthor', Thrift.Type.BOOL, 1);
      output.writeBool(this.forAuthor);
      output.writeFieldEnd();
    }
    if (this.forResponsible !== null && this.forResponsible !== undefined) {
      output.writeFieldBegin('forResponsible', Thrift.Type.BOOL, 2);
      output.writeBool(this.forResponsible);
      output.writeFieldEnd();
    }
    if (this.forExecutors !== null && this.forExecutors !== undefined) {
      output.writeFieldBegin('forExecutors', Thrift.Type.BOOL, 3);
      output.writeBool(this.forExecutors);
      output.writeFieldEnd();
    }
    if (this.forUserOrGroup !== null && this.forUserOrGroup !== undefined) {
      output.writeFieldBegin('forUserOrGroup', Thrift.Type.BOOL, 4);
      output.writeBool(this.forUserOrGroup);
      output.writeFieldEnd();
    }
    if (this.forRole !== null && this.forRole !== undefined) {
      output.writeFieldBegin('forRole', Thrift.Type.BOOL, 5);
      output.writeBool(this.forRole);
      output.writeFieldEnd();
    }
    if (this.allowList !== null && this.allowList !== undefined) {
      output.writeFieldBegin('allowList', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.allowList.length);
      for (let iter8 in this.allowList) {
        if (this.allowList.hasOwnProperty(iter8)) {
          iter8 = this.allowList[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.allowRole !== null && this.allowRole !== undefined) {
      output.writeFieldBegin('allowRole', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.STRING, this.allowRole.length);
      for (let iter9 in this.allowRole) {
        if (this.allowRole.hasOwnProperty(iter9)) {
          iter9 = this.allowRole[iter9];
          output.writeString(iter9);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.forAllDocView !== null && this.forAllDocView !== undefined) {
      output.writeFieldBegin('forAllDocView', Thrift.Type.BOOL, 8);
      output.writeBool(this.forAllDocView);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternStagesLink = class {
  constructor(args) {
    this.id = null;
    this.parentStageId = null;
    this.childStageId = null;
    this.nameDocPatStageLink = null;
    this.descriptionDocPatStageLink = null;
    this.decision = null;
    this.graphicalParams = null;
    this.execType = null;
    this.movePriority = null;
    this.informUsers = null;
    this.accessRule = null;
    this.allowForCurUser = null;
    this.useByDefault = null;
    this.resolution = null;
    this.signature = null;
    this.autoExecute = null;
    this.jiraPeriod = null;
    this.comment = null;
    this.allowRepeatDecision = null;
    this.attachmentAction = null;
    this.orderLink = null;
    this.preFunctionId = null;
    this.closeWindowType = null;
    this.updateWindowInterval = null;
    this.attachmentForceConver = null;
    this.contentHolder = null;
    this.attachmentRequirement = null;
    this.handBook = null;
    this.hbColumnId = null;
    this.hbResolution = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.parentStageId !== undefined && args.parentStageId !== null) {
        this.parentStageId = args.parentStageId;
      }
      if (args.childStageId !== undefined && args.childStageId !== null) {
        this.childStageId = args.childStageId;
      }
      if (args.nameDocPatStageLink !== undefined && args.nameDocPatStageLink !== null) {
        this.nameDocPatStageLink = args.nameDocPatStageLink;
      }
      if (args.descriptionDocPatStageLink !== undefined && args.descriptionDocPatStageLink !== null) {
        this.descriptionDocPatStageLink = args.descriptionDocPatStageLink;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.graphicalParams !== undefined && args.graphicalParams !== null) {
        this.graphicalParams = args.graphicalParams;
      }
      if (args.execType !== undefined && args.execType !== null) {
        this.execType = args.execType;
      }
      if (args.movePriority !== undefined && args.movePriority !== null) {
        this.movePriority = args.movePriority;
      }
      if (args.informUsers !== undefined && args.informUsers !== null) {
        this.informUsers = Thrift.copyList(args.informUsers, [UserOrGroup]);
      }
      if (args.accessRule !== undefined && args.accessRule !== null) {
        this.accessRule = new AccessRule(args.accessRule);
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
      if (args.useByDefault !== undefined && args.useByDefault !== null) {
        this.useByDefault = args.useByDefault;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.autoExecute !== undefined && args.autoExecute !== null) {
        this.autoExecute = args.autoExecute;
      }
      if (args.jiraPeriod !== undefined && args.jiraPeriod !== null) {
        this.jiraPeriod = args.jiraPeriod;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.allowRepeatDecision !== undefined && args.allowRepeatDecision !== null) {
        this.allowRepeatDecision = args.allowRepeatDecision;
      }
      if (args.attachmentAction !== undefined && args.attachmentAction !== null) {
        this.attachmentAction = args.attachmentAction;
      }
      if (args.orderLink !== undefined && args.orderLink !== null) {
        this.orderLink = args.orderLink;
      }
      if (args.preFunctionId !== undefined && args.preFunctionId !== null) {
        this.preFunctionId = new CompositeId(args.preFunctionId);
      }
      if (args.closeWindowType !== undefined && args.closeWindowType !== null) {
        this.closeWindowType = args.closeWindowType;
      }
      if (args.updateWindowInterval !== undefined && args.updateWindowInterval !== null) {
        this.updateWindowInterval = args.updateWindowInterval;
      }
      if (args.attachmentForceConver !== undefined && args.attachmentForceConver !== null) {
        this.attachmentForceConver = args.attachmentForceConver;
      }
      if (args.contentHolder !== undefined && args.contentHolder !== null) {
        this.contentHolder = new ContentHolder(args.contentHolder);
      }
      if (args.attachmentRequirement !== undefined && args.attachmentRequirement !== null) {
        this.attachmentRequirement = args.attachmentRequirement;
      }
      if (args.handBook !== undefined && args.handBook !== null) {
        this.handBook = new HandBook(args.handBook);
      }
      if (args.hbColumnId !== undefined && args.hbColumnId !== null) {
        this.hbColumnId = args.hbColumnId;
      }
      if (args.hbResolution !== undefined && args.hbResolution !== null) {
        this.hbResolution = args.hbResolution;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parentStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.childStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatStageLink = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatStageLink = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.graphicalParams = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.execType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.movePriority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.informUsers = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new UserOrGroup();
            elem13.read(input);
            this.informUsers.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessRule = new AccessRule();
          this.accessRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.useByDefault = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.resolution = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.signature = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.autoExecute = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.jiraPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.BOOL) {
          this.allowRepeatDecision = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I32) {
          this.attachmentAction = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.I32) {
          this.orderLink = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRUCT) {
          this.preFunctionId = new CompositeId();
          this.preFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I32) {
          this.closeWindowType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.updateWindowInterval = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentForceConver = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentHolder = new ContentHolder();
          this.contentHolder.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I32) {
          this.attachmentRequirement = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRUCT) {
          this.handBook = new HandBook();
          this.handBook.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRING) {
          this.hbColumnId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.BOOL) {
          this.hbResolution = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternStagesLink');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.parentStageId !== null && this.parentStageId !== undefined) {
      output.writeFieldBegin('parentStageId', Thrift.Type.STRING, 2);
      output.writeString(this.parentStageId);
      output.writeFieldEnd();
    }
    if (this.childStageId !== null && this.childStageId !== undefined) {
      output.writeFieldBegin('childStageId', Thrift.Type.STRING, 3);
      output.writeString(this.childStageId);
      output.writeFieldEnd();
    }
    if (this.nameDocPatStageLink !== null && this.nameDocPatStageLink !== undefined) {
      output.writeFieldBegin('nameDocPatStageLink', Thrift.Type.STRING, 4);
      output.writeString(this.nameDocPatStageLink);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatStageLink !== null && this.descriptionDocPatStageLink !== undefined) {
      output.writeFieldBegin('descriptionDocPatStageLink', Thrift.Type.STRING, 5);
      output.writeString(this.descriptionDocPatStageLink);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 6);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.graphicalParams !== null && this.graphicalParams !== undefined) {
      output.writeFieldBegin('graphicalParams', Thrift.Type.STRING, 7);
      output.writeString(this.graphicalParams);
      output.writeFieldEnd();
    }
    if (this.execType !== null && this.execType !== undefined) {
      output.writeFieldBegin('execType', Thrift.Type.I32, 8);
      output.writeI32(this.execType);
      output.writeFieldEnd();
    }
    if (this.movePriority !== null && this.movePriority !== undefined) {
      output.writeFieldBegin('movePriority', Thrift.Type.I32, 9);
      output.writeI32(this.movePriority);
      output.writeFieldEnd();
    }
    if (this.informUsers !== null && this.informUsers !== undefined) {
      output.writeFieldBegin('informUsers', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.informUsers.length);
      for (let iter14 in this.informUsers) {
        if (this.informUsers.hasOwnProperty(iter14)) {
          iter14 = this.informUsers[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessRule !== null && this.accessRule !== undefined) {
      output.writeFieldBegin('accessRule', Thrift.Type.STRUCT, 11);
      this.accessRule.write(output);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 12);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    if (this.useByDefault !== null && this.useByDefault !== undefined) {
      output.writeFieldBegin('useByDefault', Thrift.Type.BOOL, 13);
      output.writeBool(this.useByDefault);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.I32, 14);
      output.writeI32(this.resolution);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.I32, 15);
      output.writeI32(this.signature);
      output.writeFieldEnd();
    }
    if (this.autoExecute !== null && this.autoExecute !== undefined) {
      output.writeFieldBegin('autoExecute', Thrift.Type.BOOL, 16);
      output.writeBool(this.autoExecute);
      output.writeFieldEnd();
    }
    if (this.jiraPeriod !== null && this.jiraPeriod !== undefined) {
      output.writeFieldBegin('jiraPeriod', Thrift.Type.STRING, 17);
      output.writeString(this.jiraPeriod);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 18);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.allowRepeatDecision !== null && this.allowRepeatDecision !== undefined) {
      output.writeFieldBegin('allowRepeatDecision', Thrift.Type.BOOL, 19);
      output.writeBool(this.allowRepeatDecision);
      output.writeFieldEnd();
    }
    if (this.attachmentAction !== null && this.attachmentAction !== undefined) {
      output.writeFieldBegin('attachmentAction', Thrift.Type.I32, 20);
      output.writeI32(this.attachmentAction);
      output.writeFieldEnd();
    }
    if (this.orderLink !== null && this.orderLink !== undefined) {
      output.writeFieldBegin('orderLink', Thrift.Type.I32, 21);
      output.writeI32(this.orderLink);
      output.writeFieldEnd();
    }
    if (this.preFunctionId !== null && this.preFunctionId !== undefined) {
      output.writeFieldBegin('preFunctionId', Thrift.Type.STRUCT, 22);
      this.preFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.closeWindowType !== null && this.closeWindowType !== undefined) {
      output.writeFieldBegin('closeWindowType', Thrift.Type.I32, 23);
      output.writeI32(this.closeWindowType);
      output.writeFieldEnd();
    }
    if (this.updateWindowInterval !== null && this.updateWindowInterval !== undefined) {
      output.writeFieldBegin('updateWindowInterval', Thrift.Type.I32, 24);
      output.writeI32(this.updateWindowInterval);
      output.writeFieldEnd();
    }
    if (this.attachmentForceConver !== null && this.attachmentForceConver !== undefined) {
      output.writeFieldBegin('attachmentForceConver', Thrift.Type.BOOL, 25);
      output.writeBool(this.attachmentForceConver);
      output.writeFieldEnd();
    }
    if (this.contentHolder !== null && this.contentHolder !== undefined) {
      output.writeFieldBegin('contentHolder', Thrift.Type.STRUCT, 26);
      this.contentHolder.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentRequirement !== null && this.attachmentRequirement !== undefined) {
      output.writeFieldBegin('attachmentRequirement', Thrift.Type.I32, 27);
      output.writeI32(this.attachmentRequirement);
      output.writeFieldEnd();
    }
    if (this.handBook !== null && this.handBook !== undefined) {
      output.writeFieldBegin('handBook', Thrift.Type.STRUCT, 28);
      this.handBook.write(output);
      output.writeFieldEnd();
    }
    if (this.hbColumnId !== null && this.hbColumnId !== undefined) {
      output.writeFieldBegin('hbColumnId', Thrift.Type.STRING, 29);
      output.writeString(this.hbColumnId);
      output.writeFieldEnd();
    }
    if (this.hbResolution !== null && this.hbResolution !== undefined) {
      output.writeFieldBegin('hbResolution', Thrift.Type.BOOL, 30);
      output.writeBool(this.hbResolution);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
StageLinkAction = class {
  constructor(args) {
    this.type = null;
    this.userOrGroupId = null;
    this.execId = null;
    this.additionConfirmation = null;
    this.cancelDecision = null;
    this.link = null;
    this.transfer = null;
    this.cardCreateDate = null;
    this.cartTask = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.execId !== undefined && args.execId !== null) {
        this.execId = args.execId;
      }
      if (args.additionConfirmation !== undefined && args.additionConfirmation !== null) {
        this.additionConfirmation = args.additionConfirmation;
      }
      if (args.cancelDecision !== undefined && args.cancelDecision !== null) {
        this.cancelDecision = args.cancelDecision;
      }
      if (args.link !== undefined && args.link !== null) {
        this.link = new DocumentPatternStagesLink(args.link);
      }
      if (args.transfer !== undefined && args.transfer !== null) {
        this.transfer = args.transfer;
      }
      if (args.cardCreateDate !== undefined && args.cardCreateDate !== null) {
        this.cardCreateDate = args.cardCreateDate;
      }
      if (args.cartTask !== undefined && args.cartTask !== null) {
        this.cartTask = args.cartTask;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.execId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.additionConfirmation = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.cancelDecision = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.link = new DocumentPatternStagesLink();
          this.link.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.transfer = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.cardCreateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.cartTask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('StageLinkAction');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.execId !== null && this.execId !== undefined) {
      output.writeFieldBegin('execId', Thrift.Type.STRING, 3);
      output.writeString(this.execId);
      output.writeFieldEnd();
    }
    if (this.additionConfirmation !== null && this.additionConfirmation !== undefined) {
      output.writeFieldBegin('additionConfirmation', Thrift.Type.BOOL, 4);
      output.writeBool(this.additionConfirmation);
      output.writeFieldEnd();
    }
    if (this.cancelDecision !== null && this.cancelDecision !== undefined) {
      output.writeFieldBegin('cancelDecision', Thrift.Type.BOOL, 5);
      output.writeBool(this.cancelDecision);
      output.writeFieldEnd();
    }
    if (this.link !== null && this.link !== undefined) {
      output.writeFieldBegin('link', Thrift.Type.STRUCT, 6);
      this.link.write(output);
      output.writeFieldEnd();
    }
    if (this.transfer !== null && this.transfer !== undefined) {
      output.writeFieldBegin('transfer', Thrift.Type.BOOL, 7);
      output.writeBool(this.transfer);
      output.writeFieldEnd();
    }
    if (this.cardCreateDate !== null && this.cardCreateDate !== undefined) {
      output.writeFieldBegin('cardCreateDate', Thrift.Type.I64, 8);
      output.writeI64(this.cardCreateDate);
      output.writeFieldEnd();
    }
    if (this.cartTask !== null && this.cartTask !== undefined) {
      output.writeFieldBegin('cartTask', Thrift.Type.STRING, 9);
      output.writeString(this.cartTask);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocPermissions = class {
  constructor(args) {
    this.actions = null;
    this.onlineEdit = null;
    this.onlineComment = null;
    this.editDoc = null;
    this.attachmentAdd = null;
    this.attachmentDelete = null;
    this.changeContent = null;
    this.addExecutors = null;
    this.allowAdditionalConf = null;
    this.allowReassign = null;
    this.generateNumber = null;
    this.shareDocument = null;
    this.shareDocumentRevoke = null;
    this.updateResponsible = null;
    this.updateSC = null;
    this.allowRepeatReassign = null;
    this.exList = null;
    this.attachmentSign = null;
    this.allowAdditionalAdminConf = null;
    if (args) {
      if (args.actions !== undefined && args.actions !== null) {
        this.actions = Thrift.copyList(args.actions, [StageLinkAction]);
      }
      if (args.onlineEdit !== undefined && args.onlineEdit !== null) {
        this.onlineEdit = args.onlineEdit;
      }
      if (args.onlineComment !== undefined && args.onlineComment !== null) {
        this.onlineComment = args.onlineComment;
      }
      if (args.editDoc !== undefined && args.editDoc !== null) {
        this.editDoc = args.editDoc;
      }
      if (args.attachmentAdd !== undefined && args.attachmentAdd !== null) {
        this.attachmentAdd = args.attachmentAdd;
      }
      if (args.attachmentDelete !== undefined && args.attachmentDelete !== null) {
        this.attachmentDelete = args.attachmentDelete;
      }
      if (args.changeContent !== undefined && args.changeContent !== null) {
        this.changeContent = args.changeContent;
      }
      if (args.addExecutors !== undefined && args.addExecutors !== null) {
        this.addExecutors = args.addExecutors;
      }
      if (args.allowAdditionalConf !== undefined && args.allowAdditionalConf !== null) {
        this.allowAdditionalConf = args.allowAdditionalConf;
      }
      if (args.allowReassign !== undefined && args.allowReassign !== null) {
        this.allowReassign = args.allowReassign;
      }
      if (args.generateNumber !== undefined && args.generateNumber !== null) {
        this.generateNumber = args.generateNumber;
      }
      if (args.shareDocument !== undefined && args.shareDocument !== null) {
        this.shareDocument = args.shareDocument;
      }
      if (args.shareDocumentRevoke !== undefined && args.shareDocumentRevoke !== null) {
        this.shareDocumentRevoke = args.shareDocumentRevoke;
      }
      if (args.updateResponsible !== undefined && args.updateResponsible !== null) {
        this.updateResponsible = args.updateResponsible;
      }
      if (args.updateSC !== undefined && args.updateSC !== null) {
        this.updateSC = args.updateSC;
      }
      if (args.allowRepeatReassign !== undefined && args.allowRepeatReassign !== null) {
        this.allowRepeatReassign = args.allowRepeatReassign;
      }
      if (args.exList !== undefined && args.exList !== null) {
        this.exList = Thrift.copyList(args.exList, [null]);
      }
      if (args.attachmentSign !== undefined && args.attachmentSign !== null) {
        this.attachmentSign = args.attachmentSign;
      }
      if (args.allowAdditionalAdminConf !== undefined && args.allowAdditionalAdminConf !== null) {
        this.allowAdditionalAdminConf = args.allowAdditionalAdminConf;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.actions = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new StageLinkAction();
            elem18.read(input);
            this.actions.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineComment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.editDoc = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentAdd = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentDelete = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.changeContent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.addExecutors = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.allowAdditionalConf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.allowReassign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.generateNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.shareDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.shareDocumentRevoke = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.updateResponsible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.updateSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.allowRepeatReassign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.LIST) {
          this.exList = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = new PreconditionException();
            elem22.read(input);
            this.exList.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.BOOL) {
          this.allowAdditionalAdminConf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocPermissions');
    if (this.actions !== null && this.actions !== undefined) {
      output.writeFieldBegin('actions', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.actions.length);
      for (let iter23 in this.actions) {
        if (this.actions.hasOwnProperty(iter23)) {
          iter23 = this.actions[iter23];
          iter23.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.onlineEdit !== null && this.onlineEdit !== undefined) {
      output.writeFieldBegin('onlineEdit', Thrift.Type.BOOL, 2);
      output.writeBool(this.onlineEdit);
      output.writeFieldEnd();
    }
    if (this.onlineComment !== null && this.onlineComment !== undefined) {
      output.writeFieldBegin('onlineComment', Thrift.Type.BOOL, 3);
      output.writeBool(this.onlineComment);
      output.writeFieldEnd();
    }
    if (this.editDoc !== null && this.editDoc !== undefined) {
      output.writeFieldBegin('editDoc', Thrift.Type.BOOL, 4);
      output.writeBool(this.editDoc);
      output.writeFieldEnd();
    }
    if (this.attachmentAdd !== null && this.attachmentAdd !== undefined) {
      output.writeFieldBegin('attachmentAdd', Thrift.Type.BOOL, 5);
      output.writeBool(this.attachmentAdd);
      output.writeFieldEnd();
    }
    if (this.attachmentDelete !== null && this.attachmentDelete !== undefined) {
      output.writeFieldBegin('attachmentDelete', Thrift.Type.BOOL, 6);
      output.writeBool(this.attachmentDelete);
      output.writeFieldEnd();
    }
    if (this.changeContent !== null && this.changeContent !== undefined) {
      output.writeFieldBegin('changeContent', Thrift.Type.BOOL, 7);
      output.writeBool(this.changeContent);
      output.writeFieldEnd();
    }
    if (this.addExecutors !== null && this.addExecutors !== undefined) {
      output.writeFieldBegin('addExecutors', Thrift.Type.BOOL, 8);
      output.writeBool(this.addExecutors);
      output.writeFieldEnd();
    }
    if (this.allowAdditionalConf !== null && this.allowAdditionalConf !== undefined) {
      output.writeFieldBegin('allowAdditionalConf', Thrift.Type.BOOL, 9);
      output.writeBool(this.allowAdditionalConf);
      output.writeFieldEnd();
    }
    if (this.allowReassign !== null && this.allowReassign !== undefined) {
      output.writeFieldBegin('allowReassign', Thrift.Type.BOOL, 10);
      output.writeBool(this.allowReassign);
      output.writeFieldEnd();
    }
    if (this.generateNumber !== null && this.generateNumber !== undefined) {
      output.writeFieldBegin('generateNumber', Thrift.Type.BOOL, 11);
      output.writeBool(this.generateNumber);
      output.writeFieldEnd();
    }
    if (this.shareDocument !== null && this.shareDocument !== undefined) {
      output.writeFieldBegin('shareDocument', Thrift.Type.BOOL, 12);
      output.writeBool(this.shareDocument);
      output.writeFieldEnd();
    }
    if (this.shareDocumentRevoke !== null && this.shareDocumentRevoke !== undefined) {
      output.writeFieldBegin('shareDocumentRevoke', Thrift.Type.BOOL, 13);
      output.writeBool(this.shareDocumentRevoke);
      output.writeFieldEnd();
    }
    if (this.updateResponsible !== null && this.updateResponsible !== undefined) {
      output.writeFieldBegin('updateResponsible', Thrift.Type.BOOL, 14);
      output.writeBool(this.updateResponsible);
      output.writeFieldEnd();
    }
    if (this.updateSC !== null && this.updateSC !== undefined) {
      output.writeFieldBegin('updateSC', Thrift.Type.BOOL, 15);
      output.writeBool(this.updateSC);
      output.writeFieldEnd();
    }
    if (this.allowRepeatReassign !== null && this.allowRepeatReassign !== undefined) {
      output.writeFieldBegin('allowRepeatReassign', Thrift.Type.BOOL, 16);
      output.writeBool(this.allowRepeatReassign);
      output.writeFieldEnd();
    }
    if (this.exList !== null && this.exList !== undefined) {
      output.writeFieldBegin('exList', Thrift.Type.LIST, 17);
      output.writeListBegin(Thrift.Type.STRUCT, this.exList.length);
      for (let iter24 in this.exList) {
        if (this.exList.hasOwnProperty(iter24)) {
          iter24 = this.exList[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.attachmentSign !== null && this.attachmentSign !== undefined) {
      output.writeFieldBegin('attachmentSign', Thrift.Type.BOOL, 18);
      output.writeBool(this.attachmentSign);
      output.writeFieldEnd();
    }
    if (this.allowAdditionalAdminConf !== null && this.allowAdditionalAdminConf !== undefined) {
      output.writeFieldBegin('allowAdditionalAdminConf', Thrift.Type.BOOL, 19);
      output.writeBool(this.allowAdditionalAdminConf);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentAccessPolicy = class {
  constructor(args) {
    this.type = null;
    this.policyId = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.policyId !== undefined && args.policyId !== null) {
        this.policyId = args.policyId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.policyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentAccessPolicy');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.policyId !== null && this.policyId !== undefined) {
      output.writeFieldBegin('policyId', Thrift.Type.STRING, 2);
      output.writeString(this.policyId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternGroup = class {
  constructor(args) {
    this.id = null;
    this.nameDocPatGroup = null;
    this.descriptionDocPatGroup = null;
    this.category = null;
    this.enableWorkWithSC = null;
    this.order = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPatGroup !== undefined && args.nameDocPatGroup !== null) {
        this.nameDocPatGroup = args.nameDocPatGroup;
      }
      if (args.descriptionDocPatGroup !== undefined && args.descriptionDocPatGroup !== null) {
        this.descriptionDocPatGroup = args.descriptionDocPatGroup;
      }
      if (args.category !== undefined && args.category !== null) {
        this.category = args.category;
      }
      if (args.enableWorkWithSC !== undefined && args.enableWorkWithSC !== null) {
        this.enableWorkWithSC = args.enableWorkWithSC;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.category = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.enableWorkWithSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPatGroup !== null && this.nameDocPatGroup !== undefined) {
      output.writeFieldBegin('nameDocPatGroup', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPatGroup);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatGroup !== null && this.descriptionDocPatGroup !== undefined) {
      output.writeFieldBegin('descriptionDocPatGroup', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPatGroup);
      output.writeFieldEnd();
    }
    if (this.category !== null && this.category !== undefined) {
      output.writeFieldBegin('category', Thrift.Type.STRING, 4);
      output.writeString(this.category);
      output.writeFieldEnd();
    }
    if (this.enableWorkWithSC !== null && this.enableWorkWithSC !== undefined) {
      output.writeFieldBegin('enableWorkWithSC', Thrift.Type.BOOL, 5);
      output.writeBool(this.enableWorkWithSC);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 6);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItemHBValue = class {
  constructor(args) {
    this.row = null;
    this.column = null;
    this.keyColumn = null;
    if (args) {
      if (args.row !== undefined && args.row !== null) {
        this.row = new HBRow(args.row);
      }
      if (args.column !== undefined && args.column !== null) {
        this.column = new HBColumn(args.column);
      }
      if (args.keyColumn !== undefined && args.keyColumn !== null) {
        this.keyColumn = new HBColumn(args.keyColumn);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row = new HBRow();
          this.row.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.column = new HBColumn();
          this.column.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.keyColumn = new HBColumn();
          this.keyColumn.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItemHBValue');
    if (this.row !== null && this.row !== undefined) {
      output.writeFieldBegin('row', Thrift.Type.STRUCT, 1);
      this.row.write(output);
      output.writeFieldEnd();
    }
    if (this.column !== null && this.column !== undefined) {
      output.writeFieldBegin('column', Thrift.Type.STRUCT, 2);
      this.column.write(output);
      output.writeFieldEnd();
    }
    if (this.keyColumn !== null && this.keyColumn !== undefined) {
      output.writeFieldBegin('keyColumn', Thrift.Type.STRUCT, 4);
      this.keyColumn.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItemValue = class {
  constructor(args) {
    this.strValue = null;
    this.hbValue = null;
    this.strValue2 = null;
    if (args) {
      if (args.strValue !== undefined && args.strValue !== null) {
        this.strValue = args.strValue;
      }
      if (args.hbValue !== undefined && args.hbValue !== null) {
        this.hbValue = new ContentItemHBValue(args.hbValue);
      }
      if (args.strValue2 !== undefined && args.strValue2 !== null) {
        this.strValue2 = args.strValue2;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.strValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.hbValue = new ContentItemHBValue();
          this.hbValue.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.strValue2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItemValue');
    if (this.strValue !== null && this.strValue !== undefined) {
      output.writeFieldBegin('strValue', Thrift.Type.STRING, 1);
      output.writeString(this.strValue);
      output.writeFieldEnd();
    }
    if (this.hbValue !== null && this.hbValue !== undefined) {
      output.writeFieldBegin('hbValue', Thrift.Type.STRUCT, 2);
      this.hbValue.write(output);
      output.writeFieldEnd();
    }
    if (this.strValue2 !== null && this.strValue2 !== undefined) {
      output.writeFieldBegin('strValue2', Thrift.Type.STRING, 3);
      output.writeString(this.strValue2);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentTableDefinition = class {
  constructor(args) {
    this.id = null;
    this.viewMode = null;
    this.selectMode = null;
    this.height = null;
    this.rowHeight = null;
    this.columnDefenition = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.viewMode !== undefined && args.viewMode !== null) {
        this.viewMode = args.viewMode;
      }
      if (args.selectMode !== undefined && args.selectMode !== null) {
        this.selectMode = args.selectMode;
      }
      if (args.height !== undefined && args.height !== null) {
        this.height = args.height;
      }
      if (args.rowHeight !== undefined && args.rowHeight !== null) {
        this.rowHeight = args.rowHeight;
      }
      if (args.columnDefenition !== undefined && args.columnDefenition !== null) {
        this.columnDefenition = Thrift.copyList(args.columnDefenition, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.viewMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.selectMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.height = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.rowHeight = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.columnDefenition = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new ContentItem();
            elem28.read(input);
            this.columnDefenition.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentTableDefinition');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.viewMode !== null && this.viewMode !== undefined) {
      output.writeFieldBegin('viewMode', Thrift.Type.I32, 2);
      output.writeI32(this.viewMode);
      output.writeFieldEnd();
    }
    if (this.selectMode !== null && this.selectMode !== undefined) {
      output.writeFieldBegin('selectMode', Thrift.Type.I32, 3);
      output.writeI32(this.selectMode);
      output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
      output.writeFieldBegin('height', Thrift.Type.STRING, 4);
      output.writeString(this.height);
      output.writeFieldEnd();
    }
    if (this.rowHeight !== null && this.rowHeight !== undefined) {
      output.writeFieldBegin('rowHeight', Thrift.Type.STRING, 5);
      output.writeString(this.rowHeight);
      output.writeFieldEnd();
    }
    if (this.columnDefenition !== null && this.columnDefenition !== undefined) {
      output.writeFieldBegin('columnDefenition', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.columnDefenition.length);
      for (let iter29 in this.columnDefenition) {
        if (this.columnDefenition.hasOwnProperty(iter29)) {
          iter29 = this.columnDefenition[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItem = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.value = null;
    this.type = null;
    this.search = null;
    this.requared = null;
    this.readOnly = null;
    this.order = null;
    this.descriptionContItem = null;
    this.showType = null;
    this.tabId = null;
    this.key = null;
    this.showPlace = null;
    this.handBookId = null;
    this.users = null;
    this.tableDefenition = null;
    this.tableKey = null;
    this.rowNumber = null;
    this.childItems = null;
    this.availableUsers = null;
    this.tMask = null;
    this.listView = null;
    this.visible = null;
    this.visibleScript = null;
    this.readonlyScript = null;
    this.onChangeScript = null;
    this.fields = null;
    this.attributes = null;
    this.tMaskDesc = null;
    this.displayedName = null;
    this.department = null;
    this.attachment = null;
    this.quickFill = null;
    this.onlyActiveUser = null;
    this.maxUserCount = null;
    this.itemHBFilterList = null;
    this.handBook = null;
    this.columnSelector = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = new ContentItemValue(args.value);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.search !== undefined && args.search !== null) {
        this.search = args.search;
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.descriptionContItem !== undefined && args.descriptionContItem !== null) {
        this.descriptionContItem = args.descriptionContItem;
      }
      if (args.showType !== undefined && args.showType !== null) {
        this.showType = args.showType;
      }
      if (args.tabId !== undefined && args.tabId !== null) {
        this.tabId = args.tabId;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.showPlace !== undefined && args.showPlace !== null) {
        this.showPlace = args.showPlace;
      }
      if (args.handBookId !== undefined && args.handBookId !== null) {
        this.handBookId = args.handBookId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.tableDefenition !== undefined && args.tableDefenition !== null) {
        this.tableDefenition = new ContentTableDefinition(args.tableDefenition);
      }
      if (args.tableKey !== undefined && args.tableKey !== null) {
        this.tableKey = args.tableKey;
      }
      if (args.rowNumber !== undefined && args.rowNumber !== null) {
        this.rowNumber = args.rowNumber;
      }
      if (args.childItems !== undefined && args.childItems !== null) {
        this.childItems = Thrift.copyList(args.childItems, [null]);
      }
      if (args.availableUsers !== undefined && args.availableUsers !== null) {
        this.availableUsers = Thrift.copyList(args.availableUsers, [UserOrGroup]);
      }
      if (args.tMask !== undefined && args.tMask !== null) {
        this.tMask = args.tMask;
      }
      if (args.listView !== undefined && args.listView !== null) {
        this.listView = args.listView;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.visibleScript !== undefined && args.visibleScript !== null) {
        this.visibleScript = args.visibleScript;
      }
      if (args.readonlyScript !== undefined && args.readonlyScript !== null) {
        this.readonlyScript = args.readonlyScript;
      }
      if (args.onChangeScript !== undefined && args.onChangeScript !== null) {
        this.onChangeScript = args.onChangeScript;
      }
      if (args.fields !== undefined && args.fields !== null) {
        this.fields = Thrift.copyList(args.fields, [null]);
      }
      if (args.attributes !== undefined && args.attributes !== null) {
        this.attributes = args.attributes;
      }
      if (args.tMaskDesc !== undefined && args.tMaskDesc !== null) {
        this.tMaskDesc = args.tMaskDesc;
      }
      if (args.displayedName !== undefined && args.displayedName !== null) {
        this.displayedName = args.displayedName;
      }
      if (args.department !== undefined && args.department !== null) {
        this.department = new Department(args.department);
      }
      if (args.attachment !== undefined && args.attachment !== null) {
        this.attachment = new Attachment(args.attachment);
      }
      if (args.quickFill !== undefined && args.quickFill !== null) {
        this.quickFill = args.quickFill;
      }
      if (args.onlyActiveUser !== undefined && args.onlyActiveUser !== null) {
        this.onlyActiveUser = args.onlyActiveUser;
      }
      if (args.maxUserCount !== undefined && args.maxUserCount !== null) {
        this.maxUserCount = args.maxUserCount;
      }
      if (args.itemHBFilterList !== undefined && args.itemHBFilterList !== null) {
        this.itemHBFilterList = Thrift.copyList(args.itemHBFilterList, [null]);
      }
      if (args.handBook !== undefined && args.handBook !== null) {
        this.handBook = new HandBook(args.handBook);
      }
      if (args.columnSelector !== undefined && args.columnSelector !== null) {
        this.columnSelector = args.columnSelector;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.value = new ContentItemValue();
          this.value.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.search = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionContItem = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.showType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.tabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.showPlace = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.handBookId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new UserOrGroup();
            elem33.read(input);
            this.users.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRUCT) {
          this.tableDefenition = new ContentTableDefinition();
          this.tableDefenition.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.tableKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.rowNumber = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.LIST) {
          this.childItems = [];
          const _rtmp335 = input.readListBegin();
          const _size34 = _rtmp335.size || 0;
          for (let _i36 = 0; _i36 < _size34; ++_i36) {
            let elem37 = null;
            elem37 = new ContentItem();
            elem37.read(input);
            this.childItems.push(elem37);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.LIST) {
          this.availableUsers = [];
          const _rtmp339 = input.readListBegin();
          const _size38 = _rtmp339.size || 0;
          for (let _i40 = 0; _i40 < _size38; ++_i40) {
            let elem41 = null;
            elem41 = new UserOrGroup();
            elem41.read(input);
            this.availableUsers.push(elem41);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.tMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.listView = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRING) {
          this.visibleScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRING) {
          this.readonlyScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.onChangeScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.LIST) {
          this.fields = [];
          const _rtmp343 = input.readListBegin();
          const _size42 = _rtmp343.size || 0;
          for (let _i44 = 0; _i44 < _size42; ++_i44) {
            let elem45 = null;
            elem45 = input.readString().value;
            this.fields.push(elem45);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.attributes = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRING) {
          this.tMaskDesc = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.displayedName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.STRUCT) {
          this.department = new Department();
          this.department.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachment = new Attachment();
          this.attachment.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.BOOL) {
          this.quickFill = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.BOOL) {
          this.onlyActiveUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.I32) {
          this.maxUserCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.LIST) {
          this.itemHBFilterList = [];
          const _rtmp347 = input.readListBegin();
          const _size46 = _rtmp347.size || 0;
          for (let _i48 = 0; _i48 < _size46; ++_i48) {
            let elem49 = null;
            elem49 = new ContentItemHBFilter();
            elem49.read(input);
            this.itemHBFilterList.push(elem49);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.STRUCT) {
          this.handBook = new HandBook();
          this.handBook.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.I32) {
          this.columnSelector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItem');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRUCT, 3);
      this.value.write(output);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.search !== null && this.search !== undefined) {
      output.writeFieldBegin('search', Thrift.Type.BOOL, 5);
      output.writeBool(this.search);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 6);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 7);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 8);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.descriptionContItem !== null && this.descriptionContItem !== undefined) {
      output.writeFieldBegin('descriptionContItem', Thrift.Type.STRING, 9);
      output.writeString(this.descriptionContItem);
      output.writeFieldEnd();
    }
    if (this.showType !== null && this.showType !== undefined) {
      output.writeFieldBegin('showType', Thrift.Type.I32, 10);
      output.writeI32(this.showType);
      output.writeFieldEnd();
    }
    if (this.tabId !== null && this.tabId !== undefined) {
      output.writeFieldBegin('tabId', Thrift.Type.STRING, 11);
      output.writeString(this.tabId);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 12);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.showPlace !== null && this.showPlace !== undefined) {
      output.writeFieldBegin('showPlace', Thrift.Type.I32, 13);
      output.writeI32(this.showPlace);
      output.writeFieldEnd();
    }
    if (this.handBookId !== null && this.handBookId !== undefined) {
      output.writeFieldBegin('handBookId', Thrift.Type.STRING, 14);
      output.writeString(this.handBookId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 15);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter50 in this.users) {
        if (this.users.hasOwnProperty(iter50)) {
          iter50 = this.users[iter50];
          iter50.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.tableDefenition !== null && this.tableDefenition !== undefined) {
      output.writeFieldBegin('tableDefenition', Thrift.Type.STRUCT, 16);
      this.tableDefenition.write(output);
      output.writeFieldEnd();
    }
    if (this.tableKey !== null && this.tableKey !== undefined) {
      output.writeFieldBegin('tableKey', Thrift.Type.STRING, 17);
      output.writeString(this.tableKey);
      output.writeFieldEnd();
    }
    if (this.rowNumber !== null && this.rowNumber !== undefined) {
      output.writeFieldBegin('rowNumber', Thrift.Type.I32, 18);
      output.writeI32(this.rowNumber);
      output.writeFieldEnd();
    }
    if (this.childItems !== null && this.childItems !== undefined) {
      output.writeFieldBegin('childItems', Thrift.Type.LIST, 19);
      output.writeListBegin(Thrift.Type.STRUCT, this.childItems.length);
      for (let iter51 in this.childItems) {
        if (this.childItems.hasOwnProperty(iter51)) {
          iter51 = this.childItems[iter51];
          iter51.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.availableUsers !== null && this.availableUsers !== undefined) {
      output.writeFieldBegin('availableUsers', Thrift.Type.LIST, 20);
      output.writeListBegin(Thrift.Type.STRUCT, this.availableUsers.length);
      for (let iter52 in this.availableUsers) {
        if (this.availableUsers.hasOwnProperty(iter52)) {
          iter52 = this.availableUsers[iter52];
          iter52.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.tMask !== null && this.tMask !== undefined) {
      output.writeFieldBegin('tMask', Thrift.Type.STRING, 21);
      output.writeString(this.tMask);
      output.writeFieldEnd();
    }
    if (this.listView !== null && this.listView !== undefined) {
      output.writeFieldBegin('listView', Thrift.Type.BOOL, 22);
      output.writeBool(this.listView);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 23);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.visibleScript !== null && this.visibleScript !== undefined) {
      output.writeFieldBegin('visibleScript', Thrift.Type.STRING, 24);
      output.writeString(this.visibleScript);
      output.writeFieldEnd();
    }
    if (this.readonlyScript !== null && this.readonlyScript !== undefined) {
      output.writeFieldBegin('readonlyScript', Thrift.Type.STRING, 25);
      output.writeString(this.readonlyScript);
      output.writeFieldEnd();
    }
    if (this.onChangeScript !== null && this.onChangeScript !== undefined) {
      output.writeFieldBegin('onChangeScript', Thrift.Type.STRING, 26);
      output.writeString(this.onChangeScript);
      output.writeFieldEnd();
    }
    if (this.fields !== null && this.fields !== undefined) {
      output.writeFieldBegin('fields', Thrift.Type.LIST, 27);
      output.writeListBegin(Thrift.Type.STRING, this.fields.length);
      for (let iter53 in this.fields) {
        if (this.fields.hasOwnProperty(iter53)) {
          iter53 = this.fields[iter53];
          output.writeString(iter53);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.attributes !== null && this.attributes !== undefined) {
      output.writeFieldBegin('attributes', Thrift.Type.STRING, 28);
      output.writeString(this.attributes);
      output.writeFieldEnd();
    }
    if (this.tMaskDesc !== null && this.tMaskDesc !== undefined) {
      output.writeFieldBegin('tMaskDesc', Thrift.Type.STRING, 29);
      output.writeString(this.tMaskDesc);
      output.writeFieldEnd();
    }
    if (this.displayedName !== null && this.displayedName !== undefined) {
      output.writeFieldBegin('displayedName', Thrift.Type.STRING, 30);
      output.writeString(this.displayedName);
      output.writeFieldEnd();
    }
    if (this.department !== null && this.department !== undefined) {
      output.writeFieldBegin('department', Thrift.Type.STRUCT, 31);
      this.department.write(output);
      output.writeFieldEnd();
    }
    if (this.attachment !== null && this.attachment !== undefined) {
      output.writeFieldBegin('attachment', Thrift.Type.STRUCT, 32);
      this.attachment.write(output);
      output.writeFieldEnd();
    }
    if (this.quickFill !== null && this.quickFill !== undefined) {
      output.writeFieldBegin('quickFill', Thrift.Type.BOOL, 33);
      output.writeBool(this.quickFill);
      output.writeFieldEnd();
    }
    if (this.onlyActiveUser !== null && this.onlyActiveUser !== undefined) {
      output.writeFieldBegin('onlyActiveUser', Thrift.Type.BOOL, 34);
      output.writeBool(this.onlyActiveUser);
      output.writeFieldEnd();
    }
    if (this.maxUserCount !== null && this.maxUserCount !== undefined) {
      output.writeFieldBegin('maxUserCount', Thrift.Type.I32, 35);
      output.writeI32(this.maxUserCount);
      output.writeFieldEnd();
    }
    if (this.itemHBFilterList !== null && this.itemHBFilterList !== undefined) {
      output.writeFieldBegin('itemHBFilterList', Thrift.Type.LIST, 38);
      output.writeListBegin(Thrift.Type.STRUCT, this.itemHBFilterList.length);
      for (let iter54 in this.itemHBFilterList) {
        if (this.itemHBFilterList.hasOwnProperty(iter54)) {
          iter54 = this.itemHBFilterList[iter54];
          iter54.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.handBook !== null && this.handBook !== undefined) {
      output.writeFieldBegin('handBook', Thrift.Type.STRUCT, 39);
      this.handBook.write(output);
      output.writeFieldEnd();
    }
    if (this.columnSelector !== null && this.columnSelector !== undefined) {
      output.writeFieldBegin('columnSelector', Thrift.Type.I32, 40);
      output.writeI32(this.columnSelector);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItemHBFilter = class {
  constructor(args) {
    this.searchKey = null;
    this.condition = null;
    this.defValue = null;
    this.contentFilterKey = null;
    this.contentFilterColumn = null;
    this.reverseHB = null;
    this.reverseLeftColumn = null;
    this.reverseRightColumn = null;
    if (args) {
      if (args.searchKey !== undefined && args.searchKey !== null) {
        this.searchKey = args.searchKey;
      }
      if (args.condition !== undefined && args.condition !== null) {
        this.condition = args.condition;
      }
      if (args.defValue !== undefined && args.defValue !== null) {
        this.defValue = args.defValue;
      }
      if (args.contentFilterKey !== undefined && args.contentFilterKey !== null) {
        this.contentFilterKey = args.contentFilterKey;
      }
      if (args.contentFilterColumn !== undefined && args.contentFilterColumn !== null) {
        this.contentFilterColumn = new HBColumn(args.contentFilterColumn);
      }
      if (args.reverseHB !== undefined && args.reverseHB !== null) {
        this.reverseHB = new HandBook(args.reverseHB);
      }
      if (args.reverseLeftColumn !== undefined && args.reverseLeftColumn !== null) {
        this.reverseLeftColumn = new HBColumn(args.reverseLeftColumn);
      }
      if (args.reverseRightColumn !== undefined && args.reverseRightColumn !== null) {
        this.reverseRightColumn = new HBColumn(args.reverseRightColumn);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.searchKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.condition = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.defValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.contentFilterKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentFilterColumn = new HBColumn();
          this.contentFilterColumn.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.reverseHB = new HandBook();
          this.reverseHB.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.reverseLeftColumn = new HBColumn();
          this.reverseLeftColumn.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.reverseRightColumn = new HBColumn();
          this.reverseRightColumn.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItemHBFilter');
    if (this.searchKey !== null && this.searchKey !== undefined) {
      output.writeFieldBegin('searchKey', Thrift.Type.STRING, 1);
      output.writeString(this.searchKey);
      output.writeFieldEnd();
    }
    if (this.condition !== null && this.condition !== undefined) {
      output.writeFieldBegin('condition', Thrift.Type.I32, 2);
      output.writeI32(this.condition);
      output.writeFieldEnd();
    }
    if (this.defValue !== null && this.defValue !== undefined) {
      output.writeFieldBegin('defValue', Thrift.Type.STRING, 3);
      output.writeString(this.defValue);
      output.writeFieldEnd();
    }
    if (this.contentFilterKey !== null && this.contentFilterKey !== undefined) {
      output.writeFieldBegin('contentFilterKey', Thrift.Type.STRING, 4);
      output.writeString(this.contentFilterKey);
      output.writeFieldEnd();
    }
    if (this.contentFilterColumn !== null && this.contentFilterColumn !== undefined) {
      output.writeFieldBegin('contentFilterColumn', Thrift.Type.STRUCT, 5);
      this.contentFilterColumn.write(output);
      output.writeFieldEnd();
    }
    if (this.reverseHB !== null && this.reverseHB !== undefined) {
      output.writeFieldBegin('reverseHB', Thrift.Type.STRUCT, 6);
      this.reverseHB.write(output);
      output.writeFieldEnd();
    }
    if (this.reverseLeftColumn !== null && this.reverseLeftColumn !== undefined) {
      output.writeFieldBegin('reverseLeftColumn', Thrift.Type.STRUCT, 7);
      this.reverseLeftColumn.write(output);
      output.writeFieldEnd();
    }
    if (this.reverseRightColumn !== null && this.reverseRightColumn !== undefined) {
      output.writeFieldBegin('reverseRightColumn', Thrift.Type.STRUCT, 8);
      this.reverseRightColumn.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SimpleDocumentPatternOrGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.oDescription = null;
    this.ids = null;
    this.order = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.oDescription !== undefined && args.oDescription !== null) {
        this.oDescription = args.oDescription;
      }
      if (args.ids !== undefined && args.ids !== null) {
        this.ids = Thrift.copyList(args.ids, [null]);
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.ids = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = input.readString().value;
            this.ids.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SimpleDocumentPatternOrGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.oDescription !== null && this.oDescription !== undefined) {
      output.writeFieldBegin('oDescription', Thrift.Type.STRING, 3);
      output.writeString(this.oDescription);
      output.writeFieldEnd();
    }
    if (this.ids !== null && this.ids !== undefined) {
      output.writeFieldBegin('ids', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.ids.length);
      for (let iter59 in this.ids) {
        if (this.ids.hasOwnProperty(iter59)) {
          iter59 = this.ids[iter59];
          output.writeString(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 5);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NomenclatureNumber = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.numberPattern = null;
    this.currentSequenceValue = null;
    this.accountId = null;
    this.account = null;
    this.nomenclatureGroup = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.numberPattern !== undefined && args.numberPattern !== null) {
        this.numberPattern = args.numberPattern;
      }
      if (args.currentSequenceValue !== undefined && args.currentSequenceValue !== null) {
        this.currentSequenceValue = args.currentSequenceValue;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.nomenclatureGroup !== undefined && args.nomenclatureGroup !== null) {
        this.nomenclatureGroup = new NomenclatureGroup(args.nomenclatureGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.numberPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.currentSequenceValue = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureGroup = new NomenclatureGroup();
          this.nomenclatureGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NomenclatureNumber');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.numberPattern !== null && this.numberPattern !== undefined) {
      output.writeFieldBegin('numberPattern', Thrift.Type.STRING, 3);
      output.writeString(this.numberPattern);
      output.writeFieldEnd();
    }
    if (this.currentSequenceValue !== null && this.currentSequenceValue !== undefined) {
      output.writeFieldBegin('currentSequenceValue', Thrift.Type.I64, 4);
      output.writeI64(this.currentSequenceValue);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 5);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 6);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.nomenclatureGroup !== null && this.nomenclatureGroup !== undefined) {
      output.writeFieldBegin('nomenclatureGroup', Thrift.Type.STRUCT, 7);
      this.nomenclatureGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NomenclatureGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.code = null;
    this.storageTerm = null;
    this.articleNumber = null;
    this.remark = null;
    this.nomenclatureNumbers = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.code !== undefined && args.code !== null) {
        this.code = args.code;
      }
      if (args.storageTerm !== undefined && args.storageTerm !== null) {
        this.storageTerm = args.storageTerm;
      }
      if (args.articleNumber !== undefined && args.articleNumber !== null) {
        this.articleNumber = args.articleNumber;
      }
      if (args.remark !== undefined && args.remark !== null) {
        this.remark = args.remark;
      }
      if (args.nomenclatureNumbers !== undefined && args.nomenclatureNumbers !== null) {
        this.nomenclatureNumbers = Thrift.copyList(args.nomenclatureNumbers, [NomenclatureNumber]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.code = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.storageTerm = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.articleNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.remark = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.nomenclatureNumbers = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = new NomenclatureNumber();
            elem63.read(input);
            this.nomenclatureNumbers.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NomenclatureGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.code !== null && this.code !== undefined) {
      output.writeFieldBegin('code', Thrift.Type.STRING, 3);
      output.writeString(this.code);
      output.writeFieldEnd();
    }
    if (this.storageTerm !== null && this.storageTerm !== undefined) {
      output.writeFieldBegin('storageTerm', Thrift.Type.STRING, 4);
      output.writeString(this.storageTerm);
      output.writeFieldEnd();
    }
    if (this.articleNumber !== null && this.articleNumber !== undefined) {
      output.writeFieldBegin('articleNumber', Thrift.Type.STRING, 5);
      output.writeString(this.articleNumber);
      output.writeFieldEnd();
    }
    if (this.remark !== null && this.remark !== undefined) {
      output.writeFieldBegin('remark', Thrift.Type.STRING, 6);
      output.writeString(this.remark);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumbers !== null && this.nomenclatureNumbers !== undefined) {
      output.writeFieldBegin('nomenclatureNumbers', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.nomenclatureNumbers.length);
      for (let iter64 in this.nomenclatureNumbers) {
        if (this.nomenclatureNumbers.hasOwnProperty(iter64)) {
          iter64 = this.nomenclatureNumbers[iter64];
          iter64.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPattern = class {
  constructor(args) {
    this.id = null;
    this.nameDocPattern = null;
    this.descriptionDocPattern = null;
    this.creatorId = null;
    this.modifierId = null;
    this.createDate = null;
    this.modifiedDate = null;
    this.deleteDate = null;
    this.content = null;
    this.isValidState = null;
    this.nomenclatureNumber = null;
    this.documentPatternGroup = null;
    this.scMask = null;
    this.controlDate = null;
    this.useSC = null;
    this.useDocNumber = null;
    this.needGeneratePdf = null;
    this.order = null;
    this.startDocNumber = null;
    this.currentDocNumber = null;
    this.account = null;
    this.hideAuto = null;
    this.hideExt = null;
    this.meetingPattern = null;
    this.patternType = null;
    this.autoGenerateDocName = null;
    this.docNamePattern = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPattern !== undefined && args.nameDocPattern !== null) {
        this.nameDocPattern = args.nameDocPattern;
      }
      if (args.descriptionDocPattern !== undefined && args.descriptionDocPattern !== null) {
        this.descriptionDocPattern = args.descriptionDocPattern;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.modifierId !== undefined && args.modifierId !== null) {
        this.modifierId = args.modifierId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.content !== undefined && args.content !== null) {
        this.content = Thrift.copyList(args.content, [ContentItem]);
      }
      if (args.isValidState !== undefined && args.isValidState !== null) {
        this.isValidState = args.isValidState;
      }
      if (args.nomenclatureNumber !== undefined && args.nomenclatureNumber !== null) {
        this.nomenclatureNumber = new NomenclatureNumber(args.nomenclatureNumber);
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.controlDate !== undefined && args.controlDate !== null) {
        this.controlDate = args.controlDate;
      }
      if (args.useSC !== undefined && args.useSC !== null) {
        this.useSC = args.useSC;
      }
      if (args.useDocNumber !== undefined && args.useDocNumber !== null) {
        this.useDocNumber = args.useDocNumber;
      }
      if (args.needGeneratePdf !== undefined && args.needGeneratePdf !== null) {
        this.needGeneratePdf = args.needGeneratePdf;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.startDocNumber !== undefined && args.startDocNumber !== null) {
        this.startDocNumber = args.startDocNumber;
      }
      if (args.currentDocNumber !== undefined && args.currentDocNumber !== null) {
        this.currentDocNumber = args.currentDocNumber;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.hideAuto !== undefined && args.hideAuto !== null) {
        this.hideAuto = args.hideAuto;
      }
      if (args.hideExt !== undefined && args.hideExt !== null) {
        this.hideExt = args.hideExt;
      }
      if (args.meetingPattern !== undefined && args.meetingPattern !== null) {
        this.meetingPattern = new DocumentPattern(args.meetingPattern);
      }
      if (args.patternType !== undefined && args.patternType !== null) {
        this.patternType = args.patternType;
      }
      if (args.autoGenerateDocName !== undefined && args.autoGenerateDocName !== null) {
        this.autoGenerateDocName = args.autoGenerateDocName;
      }
      if (args.docNamePattern !== undefined && args.docNamePattern !== null) {
        this.docNamePattern = args.docNamePattern;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.modifierId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.content = [];
          const _rtmp366 = input.readListBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = new ContentItem();
            elem68.read(input);
            this.content.push(elem68);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.isValidState = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureNumber = new NomenclatureNumber();
          this.nomenclatureNumber.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.controlDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.useSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.useDocNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.needGeneratePdf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I64) {
          this.startDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I64) {
          this.currentDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hideAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.hideExt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.meetingPattern = new DocumentPattern();
          this.meetingPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.patternType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.autoGenerateDocName = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.docNamePattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPattern');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPattern !== null && this.nameDocPattern !== undefined) {
      output.writeFieldBegin('nameDocPattern', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPattern);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPattern !== null && this.descriptionDocPattern !== undefined) {
      output.writeFieldBegin('descriptionDocPattern', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPattern);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 4);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.modifierId !== null && this.modifierId !== undefined) {
      output.writeFieldBegin('modifierId', Thrift.Type.STRING, 5);
      output.writeString(this.modifierId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 6);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 7);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.content !== null && this.content !== undefined) {
      output.writeFieldBegin('content', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.content.length);
      for (let iter69 in this.content) {
        if (this.content.hasOwnProperty(iter69)) {
          iter69 = this.content[iter69];
          iter69.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.isValidState !== null && this.isValidState !== undefined) {
      output.writeFieldBegin('isValidState', Thrift.Type.BOOL, 10);
      output.writeBool(this.isValidState);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumber !== null && this.nomenclatureNumber !== undefined) {
      output.writeFieldBegin('nomenclatureNumber', Thrift.Type.STRUCT, 11);
      this.nomenclatureNumber.write(output);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 12);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 13);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.controlDate !== null && this.controlDate !== undefined) {
      output.writeFieldBegin('controlDate', Thrift.Type.STRING, 14);
      output.writeString(this.controlDate);
      output.writeFieldEnd();
    }
    if (this.useSC !== null && this.useSC !== undefined) {
      output.writeFieldBegin('useSC', Thrift.Type.BOOL, 15);
      output.writeBool(this.useSC);
      output.writeFieldEnd();
    }
    if (this.useDocNumber !== null && this.useDocNumber !== undefined) {
      output.writeFieldBegin('useDocNumber', Thrift.Type.BOOL, 16);
      output.writeBool(this.useDocNumber);
      output.writeFieldEnd();
    }
    if (this.needGeneratePdf !== null && this.needGeneratePdf !== undefined) {
      output.writeFieldBegin('needGeneratePdf', Thrift.Type.BOOL, 17);
      output.writeBool(this.needGeneratePdf);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 18);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.startDocNumber !== null && this.startDocNumber !== undefined) {
      output.writeFieldBegin('startDocNumber', Thrift.Type.I64, 19);
      output.writeI64(this.startDocNumber);
      output.writeFieldEnd();
    }
    if (this.currentDocNumber !== null && this.currentDocNumber !== undefined) {
      output.writeFieldBegin('currentDocNumber', Thrift.Type.I64, 20);
      output.writeI64(this.currentDocNumber);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 21);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.hideAuto !== null && this.hideAuto !== undefined) {
      output.writeFieldBegin('hideAuto', Thrift.Type.BOOL, 22);
      output.writeBool(this.hideAuto);
      output.writeFieldEnd();
    }
    if (this.hideExt !== null && this.hideExt !== undefined) {
      output.writeFieldBegin('hideExt', Thrift.Type.BOOL, 23);
      output.writeBool(this.hideExt);
      output.writeFieldEnd();
    }
    if (this.meetingPattern !== null && this.meetingPattern !== undefined) {
      output.writeFieldBegin('meetingPattern', Thrift.Type.STRUCT, 24);
      this.meetingPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.patternType !== null && this.patternType !== undefined) {
      output.writeFieldBegin('patternType', Thrift.Type.I32, 25);
      output.writeI32(this.patternType);
      output.writeFieldEnd();
    }
    if (this.autoGenerateDocName !== null && this.autoGenerateDocName !== undefined) {
      output.writeFieldBegin('autoGenerateDocName', Thrift.Type.BOOL, 26);
      output.writeBool(this.autoGenerateDocName);
      output.writeFieldEnd();
    }
    if (this.docNamePattern !== null && this.docNamePattern !== undefined) {
      output.writeFieldBegin('docNamePattern', Thrift.Type.STRING, 27);
      output.writeString(this.docNamePattern);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FreezeDocumentPattern = class {
  constructor(args) {
    this.id = null;
    this.nameDocPattern = null;
    this.descriptionDocPattern = null;
    this.creatorId = null;
    this.modifierId = null;
    this.createDate = null;
    this.modifiedDate = null;
    this.deleteDate = null;
    this.isValidState = null;
    this.docNumberPattern = null;
    this.documentPatternGroup = null;
    this.scMask = null;
    this.controlDate = null;
    this.useSC = null;
    this.useDocNumber = null;
    this.needGeneratePdf = null;
    this.startDocNumber = null;
    this.currentDocNumber = null;
    this.account = null;
    this.originalPatternId = null;
    this.docId = null;
    this.hideAuto = null;
    this.hideExt = null;
    this.meetingPattern = null;
    this.meeting = null;
    this.patternType = null;
    this.autoGenerateDocName = null;
    this.docNamePattern = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPattern !== undefined && args.nameDocPattern !== null) {
        this.nameDocPattern = args.nameDocPattern;
      }
      if (args.descriptionDocPattern !== undefined && args.descriptionDocPattern !== null) {
        this.descriptionDocPattern = args.descriptionDocPattern;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.modifierId !== undefined && args.modifierId !== null) {
        this.modifierId = args.modifierId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.isValidState !== undefined && args.isValidState !== null) {
        this.isValidState = args.isValidState;
      }
      if (args.docNumberPattern !== undefined && args.docNumberPattern !== null) {
        this.docNumberPattern = args.docNumberPattern;
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.controlDate !== undefined && args.controlDate !== null) {
        this.controlDate = args.controlDate;
      }
      if (args.useSC !== undefined && args.useSC !== null) {
        this.useSC = args.useSC;
      }
      if (args.useDocNumber !== undefined && args.useDocNumber !== null) {
        this.useDocNumber = args.useDocNumber;
      }
      if (args.needGeneratePdf !== undefined && args.needGeneratePdf !== null) {
        this.needGeneratePdf = args.needGeneratePdf;
      }
      if (args.startDocNumber !== undefined && args.startDocNumber !== null) {
        this.startDocNumber = args.startDocNumber;
      }
      if (args.currentDocNumber !== undefined && args.currentDocNumber !== null) {
        this.currentDocNumber = args.currentDocNumber;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.originalPatternId !== undefined && args.originalPatternId !== null) {
        this.originalPatternId = args.originalPatternId;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.hideAuto !== undefined && args.hideAuto !== null) {
        this.hideAuto = args.hideAuto;
      }
      if (args.hideExt !== undefined && args.hideExt !== null) {
        this.hideExt = args.hideExt;
      }
      if (args.meetingPattern !== undefined && args.meetingPattern !== null) {
        this.meetingPattern = new DocumentPattern(args.meetingPattern);
      }
      if (args.meeting !== undefined && args.meeting !== null) {
        this.meeting = new Meeting(args.meeting);
      }
      if (args.patternType !== undefined && args.patternType !== null) {
        this.patternType = args.patternType;
      }
      if (args.autoGenerateDocName !== undefined && args.autoGenerateDocName !== null) {
        this.autoGenerateDocName = args.autoGenerateDocName;
      }
      if (args.docNamePattern !== undefined && args.docNamePattern !== null) {
        this.docNamePattern = args.docNamePattern;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.modifierId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.isValidState = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.docNumberPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.controlDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.useSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.useDocNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.needGeneratePdf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I64) {
          this.startDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I64) {
          this.currentDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.originalPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hideAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.hideExt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.meetingPattern = new DocumentPattern();
          this.meetingPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRUCT) {
          this.meeting = new Meeting();
          this.meeting.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.I32) {
          this.patternType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.BOOL) {
          this.autoGenerateDocName = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRING) {
          this.docNamePattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FreezeDocumentPattern');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPattern !== null && this.nameDocPattern !== undefined) {
      output.writeFieldBegin('nameDocPattern', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPattern);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPattern !== null && this.descriptionDocPattern !== undefined) {
      output.writeFieldBegin('descriptionDocPattern', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPattern);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 4);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.modifierId !== null && this.modifierId !== undefined) {
      output.writeFieldBegin('modifierId', Thrift.Type.STRING, 5);
      output.writeString(this.modifierId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 6);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 7);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.isValidState !== null && this.isValidState !== undefined) {
      output.writeFieldBegin('isValidState', Thrift.Type.BOOL, 9);
      output.writeBool(this.isValidState);
      output.writeFieldEnd();
    }
    if (this.docNumberPattern !== null && this.docNumberPattern !== undefined) {
      output.writeFieldBegin('docNumberPattern', Thrift.Type.STRING, 10);
      output.writeString(this.docNumberPattern);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 11);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 12);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.controlDate !== null && this.controlDate !== undefined) {
      output.writeFieldBegin('controlDate', Thrift.Type.STRING, 13);
      output.writeString(this.controlDate);
      output.writeFieldEnd();
    }
    if (this.useSC !== null && this.useSC !== undefined) {
      output.writeFieldBegin('useSC', Thrift.Type.BOOL, 14);
      output.writeBool(this.useSC);
      output.writeFieldEnd();
    }
    if (this.useDocNumber !== null && this.useDocNumber !== undefined) {
      output.writeFieldBegin('useDocNumber', Thrift.Type.BOOL, 15);
      output.writeBool(this.useDocNumber);
      output.writeFieldEnd();
    }
    if (this.needGeneratePdf !== null && this.needGeneratePdf !== undefined) {
      output.writeFieldBegin('needGeneratePdf', Thrift.Type.BOOL, 16);
      output.writeBool(this.needGeneratePdf);
      output.writeFieldEnd();
    }
    if (this.startDocNumber !== null && this.startDocNumber !== undefined) {
      output.writeFieldBegin('startDocNumber', Thrift.Type.I64, 17);
      output.writeI64(this.startDocNumber);
      output.writeFieldEnd();
    }
    if (this.currentDocNumber !== null && this.currentDocNumber !== undefined) {
      output.writeFieldBegin('currentDocNumber', Thrift.Type.I64, 18);
      output.writeI64(this.currentDocNumber);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 19);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.originalPatternId !== null && this.originalPatternId !== undefined) {
      output.writeFieldBegin('originalPatternId', Thrift.Type.STRING, 20);
      output.writeString(this.originalPatternId);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 21);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.hideAuto !== null && this.hideAuto !== undefined) {
      output.writeFieldBegin('hideAuto', Thrift.Type.BOOL, 22);
      output.writeBool(this.hideAuto);
      output.writeFieldEnd();
    }
    if (this.hideExt !== null && this.hideExt !== undefined) {
      output.writeFieldBegin('hideExt', Thrift.Type.BOOL, 23);
      output.writeBool(this.hideExt);
      output.writeFieldEnd();
    }
    if (this.meetingPattern !== null && this.meetingPattern !== undefined) {
      output.writeFieldBegin('meetingPattern', Thrift.Type.STRUCT, 24);
      this.meetingPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.meeting !== null && this.meeting !== undefined) {
      output.writeFieldBegin('meeting', Thrift.Type.STRUCT, 25);
      this.meeting.write(output);
      output.writeFieldEnd();
    }
    if (this.patternType !== null && this.patternType !== undefined) {
      output.writeFieldBegin('patternType', Thrift.Type.I32, 26);
      output.writeI32(this.patternType);
      output.writeFieldEnd();
    }
    if (this.autoGenerateDocName !== null && this.autoGenerateDocName !== undefined) {
      output.writeFieldBegin('autoGenerateDocName', Thrift.Type.BOOL, 32);
      output.writeBool(this.autoGenerateDocName);
      output.writeFieldEnd();
    }
    if (this.docNamePattern !== null && this.docNamePattern !== undefined) {
      output.writeFieldBegin('docNamePattern', Thrift.Type.STRING, 33);
      output.writeString(this.docNamePattern);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternToUser = class {
  constructor(args) {
    this.docPattern = null;
    this.userOrgroup = null;
    if (args) {
      if (args.docPattern !== undefined && args.docPattern !== null) {
        this.docPattern = new DocumentPattern(args.docPattern);
      }
      if (args.userOrgroup !== undefined && args.userOrgroup !== null) {
        this.userOrgroup = new UserOrGroup(args.userOrgroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.docPattern = new DocumentPattern();
          this.docPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrgroup = new UserOrGroup();
          this.userOrgroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternToUser');
    if (this.docPattern !== null && this.docPattern !== undefined) {
      output.writeFieldBegin('docPattern', Thrift.Type.STRUCT, 1);
      this.docPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.userOrgroup !== null && this.userOrgroup !== undefined) {
      output.writeFieldBegin('userOrgroup', Thrift.Type.STRUCT, 2);
      this.userOrgroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
StageParam = class {
  constructor(args) {
    this.key = null;
    this.value = null;
    this.type = null;
    this.oName = null;
    this.multi = null;
    this.inValues = null;
    this.scriptId = null;
    this.req = null;
    this.displayName = null;
    this.subProcessAuthors = null;
    this.pHint = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = Thrift.copyList(args.value, [null]);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = Thrift.copyList(args.oName, [null]);
      }
      if (args.multi !== undefined && args.multi !== null) {
        this.multi = args.multi;
      }
      if (args.inValues !== undefined && args.inValues !== null) {
        this.inValues = Thrift.copyList(args.inValues, [null]);
      }
      if (args.scriptId !== undefined && args.scriptId !== null) {
        this.scriptId = new CompositeId(args.scriptId);
      }
      if (args.req !== undefined && args.req !== null) {
        this.req = args.req;
      }
      if (args.displayName !== undefined && args.displayName !== null) {
        this.displayName = args.displayName;
      }
      if (args.subProcessAuthors !== undefined && args.subProcessAuthors !== null) {
        this.subProcessAuthors = Thrift.copyList(args.subProcessAuthors, [PatternToUser]);
      }
      if (args.pHint !== undefined && args.pHint !== null) {
        this.pHint = args.pHint;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.value = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = input.readString().value;
            this.value.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.oName = [];
          const _rtmp375 = input.readListBegin();
          const _size74 = _rtmp375.size || 0;
          for (let _i76 = 0; _i76 < _size74; ++_i76) {
            let elem77 = null;
            elem77 = input.readString().value;
            this.oName.push(elem77);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.multi = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.inValues = [];
          const _rtmp379 = input.readListBegin();
          const _size78 = _rtmp379.size || 0;
          for (let _i80 = 0; _i80 < _size78; ++_i80) {
            let elem81 = null;
            elem81 = input.readString().value;
            this.inValues.push(elem81);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.scriptId = new CompositeId();
          this.scriptId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.req = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.displayName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.subProcessAuthors = [];
          const _rtmp383 = input.readListBegin();
          const _size82 = _rtmp383.size || 0;
          for (let _i84 = 0; _i84 < _size82; ++_i84) {
            let elem85 = null;
            elem85 = new PatternToUser();
            elem85.read(input);
            this.subProcessAuthors.push(elem85);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.pHint = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('StageParam');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.value.length);
      for (let iter86 in this.value) {
        if (this.value.hasOwnProperty(iter86)) {
          iter86 = this.value[iter86];
          output.writeString(iter86);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.oName.length);
      for (let iter87 in this.oName) {
        if (this.oName.hasOwnProperty(iter87)) {
          iter87 = this.oName[iter87];
          output.writeString(iter87);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.multi !== null && this.multi !== undefined) {
      output.writeFieldBegin('multi', Thrift.Type.BOOL, 5);
      output.writeBool(this.multi);
      output.writeFieldEnd();
    }
    if (this.inValues !== null && this.inValues !== undefined) {
      output.writeFieldBegin('inValues', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.inValues.length);
      for (let iter88 in this.inValues) {
        if (this.inValues.hasOwnProperty(iter88)) {
          iter88 = this.inValues[iter88];
          output.writeString(iter88);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.scriptId !== null && this.scriptId !== undefined) {
      output.writeFieldBegin('scriptId', Thrift.Type.STRUCT, 7);
      this.scriptId.write(output);
      output.writeFieldEnd();
    }
    if (this.req !== null && this.req !== undefined) {
      output.writeFieldBegin('req', Thrift.Type.BOOL, 8);
      output.writeBool(this.req);
      output.writeFieldEnd();
    }
    if (this.displayName !== null && this.displayName !== undefined) {
      output.writeFieldBegin('displayName', Thrift.Type.STRING, 9);
      output.writeString(this.displayName);
      output.writeFieldEnd();
    }
    if (this.subProcessAuthors !== null && this.subProcessAuthors !== undefined) {
      output.writeFieldBegin('subProcessAuthors', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.subProcessAuthors.length);
      for (let iter89 in this.subProcessAuthors) {
        if (this.subProcessAuthors.hasOwnProperty(iter89)) {
          iter89 = this.subProcessAuthors[iter89];
          iter89.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.pHint !== null && this.pHint !== undefined) {
      output.writeFieldBegin('pHint', Thrift.Type.STRING, 11);
      output.writeString(this.pHint);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternStage = class {
  constructor(args) {
    this.id = null;
    this.documentPatternId = null;
    this.nameDocPatStage = null;
    this.descriptionDocPatStage = null;
    this.status = null;
    this.subStatus = null;
    this.actionType = null;
    this.stageReq = null;
    this.deadLine = null;
    this.graphicalParams = null;
    this.availablePatternStageId = null;
    this.movedByDecision = null;
    this.registerDocument = null;
    this.execPriority = null;
    this.dispatchState = null;
    this.hide = null;
    this.userOrGroups = null;
    this.allowAdditionalConf = null;
    this.runPerriodicall = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicJiraEndDate = null;
    this.periodicEndDate = null;
    this.onlineEditRule = null;
    this.onlineCommentRule = null;
    this.changeOnDraft = null;
    this.changeOnEdit = null;
    this.changeOnSetDecision = null;
    this.editDocRule = null;
    this.attachmentAddRule = null;
    this.attachmentDeleteRule = null;
    this.changeContentRule = null;
    this.canEdit = null;
    this.maxSigner = null;
    this.stageParams = null;
    this.availableDecisions = null;
    this.fmEditKey = null;
    this.fmEditPersonal = null;
    this.fmEditClose = null;
    this.fmViewKey = null;
    this.fmViewPersonal = null;
    this.fmViewClose = null;
    this.preFunctionId = null;
    this.postFunctionId = null;
    this.showDocDetails = null;
    this.showChat = null;
    this.showHistory = null;
    this.showAttachments = null;
    this.notifMoveOnEnabled = null;
    this.notifMoveOnChanel = null;
    this.notifPeriodicalEnabled = null;
    this.notifPeriodicalJira = null;
    this.notifPeriodicalChanel = null;
    this.notifCheckDeadlineEnabled = null;
    this.notifCheckDeadlineJira = null;
    this.notifCheckDeadlineChanel = null;
    this.notifCardExpiredEnabled = null;
    this.notifCardExpiredChanel = null;
    this.orderNum = null;
    this.cardActivityPeriod = null;
    this.stageContentHolders = null;
    this.signAttachmentRule = null;
    this.downloadOriginalAttachmentRule = null;
    this.downloadOriginalAttachmentExtension = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentPatternId !== undefined && args.documentPatternId !== null) {
        this.documentPatternId = args.documentPatternId;
      }
      if (args.nameDocPatStage !== undefined && args.nameDocPatStage !== null) {
        this.nameDocPatStage = args.nameDocPatStage;
      }
      if (args.descriptionDocPatStage !== undefined && args.descriptionDocPatStage !== null) {
        this.descriptionDocPatStage = args.descriptionDocPatStage;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.stageReq !== undefined && args.stageReq !== null) {
        this.stageReq = args.stageReq;
      }
      if (args.deadLine !== undefined && args.deadLine !== null) {
        this.deadLine = args.deadLine;
      }
      if (args.graphicalParams !== undefined && args.graphicalParams !== null) {
        this.graphicalParams = args.graphicalParams;
      }
      if (args.availablePatternStageId !== undefined && args.availablePatternStageId !== null) {
        this.availablePatternStageId = args.availablePatternStageId;
      }
      if (args.movedByDecision !== undefined && args.movedByDecision !== null) {
        this.movedByDecision = args.movedByDecision;
      }
      if (args.registerDocument !== undefined && args.registerDocument !== null) {
        this.registerDocument = args.registerDocument;
      }
      if (args.execPriority !== undefined && args.execPriority !== null) {
        this.execPriority = args.execPriority;
      }
      if (args.dispatchState !== undefined && args.dispatchState !== null) {
        this.dispatchState = args.dispatchState;
      }
      if (args.hide !== undefined && args.hide !== null) {
        this.hide = args.hide;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
      if (args.allowAdditionalConf !== undefined && args.allowAdditionalConf !== null) {
        this.allowAdditionalConf = args.allowAdditionalConf;
      }
      if (args.runPerriodicall !== undefined && args.runPerriodicall !== null) {
        this.runPerriodicall = args.runPerriodicall;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicJiraEndDate !== undefined && args.periodicJiraEndDate !== null) {
        this.periodicJiraEndDate = args.periodicJiraEndDate;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.onlineEditRule !== undefined && args.onlineEditRule !== null) {
        this.onlineEditRule = new AccessRule(args.onlineEditRule);
      }
      if (args.onlineCommentRule !== undefined && args.onlineCommentRule !== null) {
        this.onlineCommentRule = new AccessRule(args.onlineCommentRule);
      }
      if (args.changeOnDraft !== undefined && args.changeOnDraft !== null) {
        this.changeOnDraft = args.changeOnDraft;
      }
      if (args.changeOnEdit !== undefined && args.changeOnEdit !== null) {
        this.changeOnEdit = new AccessRule(args.changeOnEdit);
      }
      if (args.changeOnSetDecision !== undefined && args.changeOnSetDecision !== null) {
        this.changeOnSetDecision = new AccessRule(args.changeOnSetDecision);
      }
      if (args.editDocRule !== undefined && args.editDocRule !== null) {
        this.editDocRule = new AccessRule(args.editDocRule);
      }
      if (args.attachmentAddRule !== undefined && args.attachmentAddRule !== null) {
        this.attachmentAddRule = new AccessRule(args.attachmentAddRule);
      }
      if (args.attachmentDeleteRule !== undefined && args.attachmentDeleteRule !== null) {
        this.attachmentDeleteRule = new AccessRule(args.attachmentDeleteRule);
      }
      if (args.changeContentRule !== undefined && args.changeContentRule !== null) {
        this.changeContentRule = new AccessRule(args.changeContentRule);
      }
      if (args.canEdit !== undefined && args.canEdit !== null) {
        this.canEdit = args.canEdit;
      }
      if (args.maxSigner !== undefined && args.maxSigner !== null) {
        this.maxSigner = args.maxSigner;
      }
      if (args.stageParams !== undefined && args.stageParams !== null) {
        this.stageParams = Thrift.copyList(args.stageParams, [StageParam]);
      }
      if (args.availableDecisions !== undefined && args.availableDecisions !== null) {
        this.availableDecisions = Thrift.copyList(args.availableDecisions, [null]);
      }
      if (args.fmEditKey !== undefined && args.fmEditKey !== null) {
        this.fmEditKey = args.fmEditKey;
      }
      if (args.fmEditPersonal !== undefined && args.fmEditPersonal !== null) {
        this.fmEditPersonal = args.fmEditPersonal;
      }
      if (args.fmEditClose !== undefined && args.fmEditClose !== null) {
        this.fmEditClose = args.fmEditClose;
      }
      if (args.fmViewKey !== undefined && args.fmViewKey !== null) {
        this.fmViewKey = args.fmViewKey;
      }
      if (args.fmViewPersonal !== undefined && args.fmViewPersonal !== null) {
        this.fmViewPersonal = args.fmViewPersonal;
      }
      if (args.fmViewClose !== undefined && args.fmViewClose !== null) {
        this.fmViewClose = args.fmViewClose;
      }
      if (args.preFunctionId !== undefined && args.preFunctionId !== null) {
        this.preFunctionId = new CompositeId(args.preFunctionId);
      }
      if (args.postFunctionId !== undefined && args.postFunctionId !== null) {
        this.postFunctionId = new CompositeId(args.postFunctionId);
      }
      if (args.showDocDetails !== undefined && args.showDocDetails !== null) {
        this.showDocDetails = args.showDocDetails;
      }
      if (args.showChat !== undefined && args.showChat !== null) {
        this.showChat = args.showChat;
      }
      if (args.showHistory !== undefined && args.showHistory !== null) {
        this.showHistory = args.showHistory;
      }
      if (args.showAttachments !== undefined && args.showAttachments !== null) {
        this.showAttachments = args.showAttachments;
      }
      if (args.notifMoveOnEnabled !== undefined && args.notifMoveOnEnabled !== null) {
        this.notifMoveOnEnabled = args.notifMoveOnEnabled;
      }
      if (args.notifMoveOnChanel !== undefined && args.notifMoveOnChanel !== null) {
        this.notifMoveOnChanel = args.notifMoveOnChanel;
      }
      if (args.notifPeriodicalEnabled !== undefined && args.notifPeriodicalEnabled !== null) {
        this.notifPeriodicalEnabled = args.notifPeriodicalEnabled;
      }
      if (args.notifPeriodicalJira !== undefined && args.notifPeriodicalJira !== null) {
        this.notifPeriodicalJira = args.notifPeriodicalJira;
      }
      if (args.notifPeriodicalChanel !== undefined && args.notifPeriodicalChanel !== null) {
        this.notifPeriodicalChanel = args.notifPeriodicalChanel;
      }
      if (args.notifCheckDeadlineEnabled !== undefined && args.notifCheckDeadlineEnabled !== null) {
        this.notifCheckDeadlineEnabled = args.notifCheckDeadlineEnabled;
      }
      if (args.notifCheckDeadlineJira !== undefined && args.notifCheckDeadlineJira !== null) {
        this.notifCheckDeadlineJira = args.notifCheckDeadlineJira;
      }
      if (args.notifCheckDeadlineChanel !== undefined && args.notifCheckDeadlineChanel !== null) {
        this.notifCheckDeadlineChanel = args.notifCheckDeadlineChanel;
      }
      if (args.notifCardExpiredEnabled !== undefined && args.notifCardExpiredEnabled !== null) {
        this.notifCardExpiredEnabled = args.notifCardExpiredEnabled;
      }
      if (args.notifCardExpiredChanel !== undefined && args.notifCardExpiredChanel !== null) {
        this.notifCardExpiredChanel = args.notifCardExpiredChanel;
      }
      if (args.orderNum !== undefined && args.orderNum !== null) {
        this.orderNum = args.orderNum;
      }
      if (args.cardActivityPeriod !== undefined && args.cardActivityPeriod !== null) {
        this.cardActivityPeriod = args.cardActivityPeriod;
      }
      if (args.stageContentHolders !== undefined && args.stageContentHolders !== null) {
        this.stageContentHolders = Thrift.copyList(args.stageContentHolders, [null]);
      }
      if (args.signAttachmentRule !== undefined && args.signAttachmentRule !== null) {
        this.signAttachmentRule = new AccessRule(args.signAttachmentRule);
      }
      if (args.downloadOriginalAttachmentRule !== undefined && args.downloadOriginalAttachmentRule !== null) {
        this.downloadOriginalAttachmentRule = new AccessRule(args.downloadOriginalAttachmentRule);
      }
      if (args.downloadOriginalAttachmentExtension !== undefined && args.downloadOriginalAttachmentExtension !== null) {
        this.downloadOriginalAttachmentExtension = args.downloadOriginalAttachmentExtension;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatStage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatStage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.stageReq = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.deadLine = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.graphicalParams = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.availablePatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.movedByDecision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.registerDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.execPriority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.dispatchState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.hide = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp391 = input.readListBegin();
          const _size90 = _rtmp391.size || 0;
          for (let _i92 = 0; _i92 < _size90; ++_i92) {
            let elem93 = null;
            elem93 = new UserOrGroup();
            elem93.read(input);
            this.userOrGroups.push(elem93);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.allowAdditionalConf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.BOOL) {
          this.runPerriodicall = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.periodicJiraEndDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.onlineEditRule = new AccessRule();
          this.onlineEditRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRUCT) {
          this.onlineCommentRule = new AccessRule();
          this.onlineCommentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.changeOnDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeOnEdit = new AccessRule();
          this.changeOnEdit.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeOnSetDecision = new AccessRule();
          this.changeOnSetDecision.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRUCT) {
          this.editDocRule = new AccessRule();
          this.editDocRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentAddRule = new AccessRule();
          this.attachmentAddRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentDeleteRule = new AccessRule();
          this.attachmentDeleteRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeContentRule = new AccessRule();
          this.changeContentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.BOOL) {
          this.canEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.I32) {
          this.maxSigner = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.LIST) {
          this.stageParams = [];
          const _rtmp395 = input.readListBegin();
          const _size94 = _rtmp395.size || 0;
          for (let _i96 = 0; _i96 < _size94; ++_i96) {
            let elem97 = null;
            elem97 = new StageParam();
            elem97.read(input);
            this.stageParams.push(elem97);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.SET) {
          this.availableDecisions = [];
          const _rtmp399 = input.readSetBegin();
          const _size98 = _rtmp399.size || 0;
          for (let _i100 = 0; _i100 < _size98; ++_i100) {
            let elem101 = null;
            elem101 = input.readString().value;
            this.availableDecisions.push(elem101);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.STRING) {
          this.fmEditKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.BOOL) {
          this.fmEditPersonal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.BOOL) {
          this.fmEditClose = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.STRING) {
          this.fmViewKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.BOOL) {
          this.fmViewPersonal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 42:
        if (ftype == Thrift.Type.BOOL) {
          this.fmViewClose = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 43:
        if (ftype == Thrift.Type.STRUCT) {
          this.preFunctionId = new CompositeId();
          this.preFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 44:
        if (ftype == Thrift.Type.STRUCT) {
          this.postFunctionId = new CompositeId();
          this.postFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 45:
        if (ftype == Thrift.Type.I32) {
          this.showDocDetails = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 46:
        if (ftype == Thrift.Type.I32) {
          this.showChat = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 47:
        if (ftype == Thrift.Type.I32) {
          this.showHistory = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 48:
        if (ftype == Thrift.Type.I32) {
          this.showAttachments = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 49:
        if (ftype == Thrift.Type.BOOL) {
          this.notifMoveOnEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 50:
        if (ftype == Thrift.Type.STRING) {
          this.notifMoveOnChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 51:
        if (ftype == Thrift.Type.BOOL) {
          this.notifPeriodicalEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 52:
        if (ftype == Thrift.Type.STRING) {
          this.notifPeriodicalJira = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 53:
        if (ftype == Thrift.Type.STRING) {
          this.notifPeriodicalChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 54:
        if (ftype == Thrift.Type.BOOL) {
          this.notifCheckDeadlineEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 55:
        if (ftype == Thrift.Type.STRING) {
          this.notifCheckDeadlineJira = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 56:
        if (ftype == Thrift.Type.STRING) {
          this.notifCheckDeadlineChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 57:
        if (ftype == Thrift.Type.BOOL) {
          this.notifCardExpiredEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 58:
        if (ftype == Thrift.Type.STRING) {
          this.notifCardExpiredChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 59:
        if (ftype == Thrift.Type.I32) {
          this.orderNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 60:
        if (ftype == Thrift.Type.STRING) {
          this.cardActivityPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 61:
        if (ftype == Thrift.Type.LIST) {
          this.stageContentHolders = [];
          const _rtmp3103 = input.readListBegin();
          const _size102 = _rtmp3103.size || 0;
          for (let _i104 = 0; _i104 < _size102; ++_i104) {
            let elem105 = null;
            elem105 = new ContentHolderShowPlace();
            elem105.read(input);
            this.stageContentHolders.push(elem105);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 62:
        if (ftype == Thrift.Type.STRUCT) {
          this.signAttachmentRule = new AccessRule();
          this.signAttachmentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 63:
        if (ftype == Thrift.Type.STRUCT) {
          this.downloadOriginalAttachmentRule = new AccessRule();
          this.downloadOriginalAttachmentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 64:
        if (ftype == Thrift.Type.STRING) {
          this.downloadOriginalAttachmentExtension = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternStage');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentPatternId !== null && this.documentPatternId !== undefined) {
      output.writeFieldBegin('documentPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.documentPatternId);
      output.writeFieldEnd();
    }
    if (this.nameDocPatStage !== null && this.nameDocPatStage !== undefined) {
      output.writeFieldBegin('nameDocPatStage', Thrift.Type.STRING, 3);
      output.writeString(this.nameDocPatStage);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatStage !== null && this.descriptionDocPatStage !== undefined) {
      output.writeFieldBegin('descriptionDocPatStage', Thrift.Type.STRING, 4);
      output.writeString(this.descriptionDocPatStage);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 5);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 6);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 7);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.stageReq !== null && this.stageReq !== undefined) {
      output.writeFieldBegin('stageReq', Thrift.Type.BOOL, 8);
      output.writeBool(this.stageReq);
      output.writeFieldEnd();
    }
    if (this.deadLine !== null && this.deadLine !== undefined) {
      output.writeFieldBegin('deadLine', Thrift.Type.STRING, 9);
      output.writeString(this.deadLine);
      output.writeFieldEnd();
    }
    if (this.graphicalParams !== null && this.graphicalParams !== undefined) {
      output.writeFieldBegin('graphicalParams', Thrift.Type.STRING, 10);
      output.writeString(this.graphicalParams);
      output.writeFieldEnd();
    }
    if (this.availablePatternStageId !== null && this.availablePatternStageId !== undefined) {
      output.writeFieldBegin('availablePatternStageId', Thrift.Type.STRING, 11);
      output.writeString(this.availablePatternStageId);
      output.writeFieldEnd();
    }
    if (this.movedByDecision !== null && this.movedByDecision !== undefined) {
      output.writeFieldBegin('movedByDecision', Thrift.Type.STRING, 12);
      output.writeString(this.movedByDecision);
      output.writeFieldEnd();
    }
    if (this.registerDocument !== null && this.registerDocument !== undefined) {
      output.writeFieldBegin('registerDocument', Thrift.Type.BOOL, 13);
      output.writeBool(this.registerDocument);
      output.writeFieldEnd();
    }
    if (this.execPriority !== null && this.execPriority !== undefined) {
      output.writeFieldBegin('execPriority', Thrift.Type.I32, 14);
      output.writeI32(this.execPriority);
      output.writeFieldEnd();
    }
    if (this.dispatchState !== null && this.dispatchState !== undefined) {
      output.writeFieldBegin('dispatchState', Thrift.Type.I32, 15);
      output.writeI32(this.dispatchState);
      output.writeFieldEnd();
    }
    if (this.hide !== null && this.hide !== undefined) {
      output.writeFieldBegin('hide', Thrift.Type.BOOL, 16);
      output.writeBool(this.hide);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 17);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter106 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter106)) {
          iter106 = this.userOrGroups[iter106];
          iter106.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.allowAdditionalConf !== null && this.allowAdditionalConf !== undefined) {
      output.writeFieldBegin('allowAdditionalConf', Thrift.Type.BOOL, 18);
      output.writeBool(this.allowAdditionalConf);
      output.writeFieldEnd();
    }
    if (this.runPerriodicall !== null && this.runPerriodicall !== undefined) {
      output.writeFieldBegin('runPerriodicall', Thrift.Type.BOOL, 19);
      output.writeBool(this.runPerriodicall);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 20);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 21);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicJiraEndDate !== null && this.periodicJiraEndDate !== undefined) {
      output.writeFieldBegin('periodicJiraEndDate', Thrift.Type.STRING, 22);
      output.writeString(this.periodicJiraEndDate);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 23);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.onlineEditRule !== null && this.onlineEditRule !== undefined) {
      output.writeFieldBegin('onlineEditRule', Thrift.Type.STRUCT, 24);
      this.onlineEditRule.write(output);
      output.writeFieldEnd();
    }
    if (this.onlineCommentRule !== null && this.onlineCommentRule !== undefined) {
      output.writeFieldBegin('onlineCommentRule', Thrift.Type.STRUCT, 25);
      this.onlineCommentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.changeOnDraft !== null && this.changeOnDraft !== undefined) {
      output.writeFieldBegin('changeOnDraft', Thrift.Type.BOOL, 26);
      output.writeBool(this.changeOnDraft);
      output.writeFieldEnd();
    }
    if (this.changeOnEdit !== null && this.changeOnEdit !== undefined) {
      output.writeFieldBegin('changeOnEdit', Thrift.Type.STRUCT, 27);
      this.changeOnEdit.write(output);
      output.writeFieldEnd();
    }
    if (this.changeOnSetDecision !== null && this.changeOnSetDecision !== undefined) {
      output.writeFieldBegin('changeOnSetDecision', Thrift.Type.STRUCT, 28);
      this.changeOnSetDecision.write(output);
      output.writeFieldEnd();
    }
    if (this.editDocRule !== null && this.editDocRule !== undefined) {
      output.writeFieldBegin('editDocRule', Thrift.Type.STRUCT, 29);
      this.editDocRule.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentAddRule !== null && this.attachmentAddRule !== undefined) {
      output.writeFieldBegin('attachmentAddRule', Thrift.Type.STRUCT, 30);
      this.attachmentAddRule.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentDeleteRule !== null && this.attachmentDeleteRule !== undefined) {
      output.writeFieldBegin('attachmentDeleteRule', Thrift.Type.STRUCT, 31);
      this.attachmentDeleteRule.write(output);
      output.writeFieldEnd();
    }
    if (this.changeContentRule !== null && this.changeContentRule !== undefined) {
      output.writeFieldBegin('changeContentRule', Thrift.Type.STRUCT, 32);
      this.changeContentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.canEdit !== null && this.canEdit !== undefined) {
      output.writeFieldBegin('canEdit', Thrift.Type.BOOL, 33);
      output.writeBool(this.canEdit);
      output.writeFieldEnd();
    }
    if (this.maxSigner !== null && this.maxSigner !== undefined) {
      output.writeFieldBegin('maxSigner', Thrift.Type.I32, 34);
      output.writeI32(this.maxSigner);
      output.writeFieldEnd();
    }
    if (this.stageParams !== null && this.stageParams !== undefined) {
      output.writeFieldBegin('stageParams', Thrift.Type.LIST, 35);
      output.writeListBegin(Thrift.Type.STRUCT, this.stageParams.length);
      for (let iter107 in this.stageParams) {
        if (this.stageParams.hasOwnProperty(iter107)) {
          iter107 = this.stageParams[iter107];
          iter107.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.availableDecisions !== null && this.availableDecisions !== undefined) {
      output.writeFieldBegin('availableDecisions', Thrift.Type.SET, 36);
      output.writeSetBegin(Thrift.Type.STRING, this.availableDecisions.length);
      for (let iter108 in this.availableDecisions) {
        if (this.availableDecisions.hasOwnProperty(iter108)) {
          iter108 = this.availableDecisions[iter108];
          output.writeString(iter108);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.fmEditKey !== null && this.fmEditKey !== undefined) {
      output.writeFieldBegin('fmEditKey', Thrift.Type.STRING, 37);
      output.writeString(this.fmEditKey);
      output.writeFieldEnd();
    }
    if (this.fmEditPersonal !== null && this.fmEditPersonal !== undefined) {
      output.writeFieldBegin('fmEditPersonal', Thrift.Type.BOOL, 38);
      output.writeBool(this.fmEditPersonal);
      output.writeFieldEnd();
    }
    if (this.fmEditClose !== null && this.fmEditClose !== undefined) {
      output.writeFieldBegin('fmEditClose', Thrift.Type.BOOL, 39);
      output.writeBool(this.fmEditClose);
      output.writeFieldEnd();
    }
    if (this.fmViewKey !== null && this.fmViewKey !== undefined) {
      output.writeFieldBegin('fmViewKey', Thrift.Type.STRING, 40);
      output.writeString(this.fmViewKey);
      output.writeFieldEnd();
    }
    if (this.fmViewPersonal !== null && this.fmViewPersonal !== undefined) {
      output.writeFieldBegin('fmViewPersonal', Thrift.Type.BOOL, 41);
      output.writeBool(this.fmViewPersonal);
      output.writeFieldEnd();
    }
    if (this.fmViewClose !== null && this.fmViewClose !== undefined) {
      output.writeFieldBegin('fmViewClose', Thrift.Type.BOOL, 42);
      output.writeBool(this.fmViewClose);
      output.writeFieldEnd();
    }
    if (this.preFunctionId !== null && this.preFunctionId !== undefined) {
      output.writeFieldBegin('preFunctionId', Thrift.Type.STRUCT, 43);
      this.preFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.postFunctionId !== null && this.postFunctionId !== undefined) {
      output.writeFieldBegin('postFunctionId', Thrift.Type.STRUCT, 44);
      this.postFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.showDocDetails !== null && this.showDocDetails !== undefined) {
      output.writeFieldBegin('showDocDetails', Thrift.Type.I32, 45);
      output.writeI32(this.showDocDetails);
      output.writeFieldEnd();
    }
    if (this.showChat !== null && this.showChat !== undefined) {
      output.writeFieldBegin('showChat', Thrift.Type.I32, 46);
      output.writeI32(this.showChat);
      output.writeFieldEnd();
    }
    if (this.showHistory !== null && this.showHistory !== undefined) {
      output.writeFieldBegin('showHistory', Thrift.Type.I32, 47);
      output.writeI32(this.showHistory);
      output.writeFieldEnd();
    }
    if (this.showAttachments !== null && this.showAttachments !== undefined) {
      output.writeFieldBegin('showAttachments', Thrift.Type.I32, 48);
      output.writeI32(this.showAttachments);
      output.writeFieldEnd();
    }
    if (this.notifMoveOnEnabled !== null && this.notifMoveOnEnabled !== undefined) {
      output.writeFieldBegin('notifMoveOnEnabled', Thrift.Type.BOOL, 49);
      output.writeBool(this.notifMoveOnEnabled);
      output.writeFieldEnd();
    }
    if (this.notifMoveOnChanel !== null && this.notifMoveOnChanel !== undefined) {
      output.writeFieldBegin('notifMoveOnChanel', Thrift.Type.STRING, 50);
      output.writeString(this.notifMoveOnChanel);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalEnabled !== null && this.notifPeriodicalEnabled !== undefined) {
      output.writeFieldBegin('notifPeriodicalEnabled', Thrift.Type.BOOL, 51);
      output.writeBool(this.notifPeriodicalEnabled);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalJira !== null && this.notifPeriodicalJira !== undefined) {
      output.writeFieldBegin('notifPeriodicalJira', Thrift.Type.STRING, 52);
      output.writeString(this.notifPeriodicalJira);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalChanel !== null && this.notifPeriodicalChanel !== undefined) {
      output.writeFieldBegin('notifPeriodicalChanel', Thrift.Type.STRING, 53);
      output.writeString(this.notifPeriodicalChanel);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineEnabled !== null && this.notifCheckDeadlineEnabled !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineEnabled', Thrift.Type.BOOL, 54);
      output.writeBool(this.notifCheckDeadlineEnabled);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineJira !== null && this.notifCheckDeadlineJira !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineJira', Thrift.Type.STRING, 55);
      output.writeString(this.notifCheckDeadlineJira);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineChanel !== null && this.notifCheckDeadlineChanel !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineChanel', Thrift.Type.STRING, 56);
      output.writeString(this.notifCheckDeadlineChanel);
      output.writeFieldEnd();
    }
    if (this.notifCardExpiredEnabled !== null && this.notifCardExpiredEnabled !== undefined) {
      output.writeFieldBegin('notifCardExpiredEnabled', Thrift.Type.BOOL, 57);
      output.writeBool(this.notifCardExpiredEnabled);
      output.writeFieldEnd();
    }
    if (this.notifCardExpiredChanel !== null && this.notifCardExpiredChanel !== undefined) {
      output.writeFieldBegin('notifCardExpiredChanel', Thrift.Type.STRING, 58);
      output.writeString(this.notifCardExpiredChanel);
      output.writeFieldEnd();
    }
    if (this.orderNum !== null && this.orderNum !== undefined) {
      output.writeFieldBegin('orderNum', Thrift.Type.I32, 59);
      output.writeI32(this.orderNum);
      output.writeFieldEnd();
    }
    if (this.cardActivityPeriod !== null && this.cardActivityPeriod !== undefined) {
      output.writeFieldBegin('cardActivityPeriod', Thrift.Type.STRING, 60);
      output.writeString(this.cardActivityPeriod);
      output.writeFieldEnd();
    }
    if (this.stageContentHolders !== null && this.stageContentHolders !== undefined) {
      output.writeFieldBegin('stageContentHolders', Thrift.Type.LIST, 61);
      output.writeListBegin(Thrift.Type.STRUCT, this.stageContentHolders.length);
      for (let iter109 in this.stageContentHolders) {
        if (this.stageContentHolders.hasOwnProperty(iter109)) {
          iter109 = this.stageContentHolders[iter109];
          iter109.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.signAttachmentRule !== null && this.signAttachmentRule !== undefined) {
      output.writeFieldBegin('signAttachmentRule', Thrift.Type.STRUCT, 62);
      this.signAttachmentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.downloadOriginalAttachmentRule !== null && this.downloadOriginalAttachmentRule !== undefined) {
      output.writeFieldBegin('downloadOriginalAttachmentRule', Thrift.Type.STRUCT, 63);
      this.downloadOriginalAttachmentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.downloadOriginalAttachmentExtension !== null && this.downloadOriginalAttachmentExtension !== undefined) {
      output.writeFieldBegin('downloadOriginalAttachmentExtension', Thrift.Type.STRING, 64);
      output.writeString(this.downloadOriginalAttachmentExtension);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DesicionInfo = class {
  constructor(args) {
    this.freezeStage = null;
    this.holderShowPlace = null;
    if (args) {
      if (args.freezeStage !== undefined && args.freezeStage !== null) {
        this.freezeStage = new DocumentPatternStage(args.freezeStage);
      }
      if (args.holderShowPlace !== undefined && args.holderShowPlace !== null) {
        this.holderShowPlace = Thrift.copyList(args.holderShowPlace, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.freezeStage = new DocumentPatternStage();
          this.freezeStage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.holderShowPlace = [];
          const _rtmp3111 = input.readListBegin();
          const _size110 = _rtmp3111.size || 0;
          for (let _i112 = 0; _i112 < _size110; ++_i112) {
            let elem113 = null;
            elem113 = new ContentHolderShowPlace();
            elem113.read(input);
            this.holderShowPlace.push(elem113);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DesicionInfo');
    if (this.freezeStage !== null && this.freezeStage !== undefined) {
      output.writeFieldBegin('freezeStage', Thrift.Type.STRUCT, 1);
      this.freezeStage.write(output);
      output.writeFieldEnd();
    }
    if (this.holderShowPlace !== null && this.holderShowPlace !== undefined) {
      output.writeFieldBegin('holderShowPlace', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderShowPlace.length);
      for (let iter114 in this.holderShowPlace) {
        if (this.holderShowPlace.hasOwnProperty(iter114)) {
          iter114 = this.holderShowPlace[iter114];
          iter114.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentComment = class {
  constructor(args) {
    this.id = null;
    this.creatorId = null;
    this.creator = null;
    this.createDate = null;
    this.comment = null;
    this.documentId = null;
    this.executionId = null;
    this.theNewCommentId = null;
    this.oldCommentId = null;
    this.parentId = null;
    this.docSubStatusHistId = null;
    this.commentType = null;
    this.rootCreateDate = null;
    this.rootCreatorId = null;
    this.rootCreator = null;
    this.originalUser = null;
    this.modifierUser = null;
    this.modifiedDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.executionId !== undefined && args.executionId !== null) {
        this.executionId = args.executionId;
      }
      if (args.theNewCommentId !== undefined && args.theNewCommentId !== null) {
        this.theNewCommentId = args.theNewCommentId;
      }
      if (args.oldCommentId !== undefined && args.oldCommentId !== null) {
        this.oldCommentId = args.oldCommentId;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.docSubStatusHistId !== undefined && args.docSubStatusHistId !== null) {
        this.docSubStatusHistId = args.docSubStatusHistId;
      }
      if (args.commentType !== undefined && args.commentType !== null) {
        this.commentType = args.commentType;
      }
      if (args.rootCreateDate !== undefined && args.rootCreateDate !== null) {
        this.rootCreateDate = args.rootCreateDate;
      }
      if (args.rootCreatorId !== undefined && args.rootCreatorId !== null) {
        this.rootCreatorId = args.rootCreatorId;
      }
      if (args.rootCreator !== undefined && args.rootCreator !== null) {
        this.rootCreator = new UserOrGroup(args.rootCreator);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.modifierUser !== undefined && args.modifierUser !== null) {
        this.modifierUser = new UserOrGroup(args.modifierUser);
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.executionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.theNewCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.oldCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.docSubStatusHistId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.commentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.rootCreateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.rootCreatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRUCT) {
          this.rootCreator = new UserOrGroup();
          this.rootCreator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRUCT) {
          this.modifierUser = new UserOrGroup();
          this.modifierUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentComment');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 2);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 3);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 4);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 5);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 6);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.executionId !== null && this.executionId !== undefined) {
      output.writeFieldBegin('executionId', Thrift.Type.STRING, 7);
      output.writeString(this.executionId);
      output.writeFieldEnd();
    }
    if (this.theNewCommentId !== null && this.theNewCommentId !== undefined) {
      output.writeFieldBegin('theNewCommentId', Thrift.Type.STRING, 8);
      output.writeString(this.theNewCommentId);
      output.writeFieldEnd();
    }
    if (this.oldCommentId !== null && this.oldCommentId !== undefined) {
      output.writeFieldBegin('oldCommentId', Thrift.Type.STRING, 9);
      output.writeString(this.oldCommentId);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 10);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.docSubStatusHistId !== null && this.docSubStatusHistId !== undefined) {
      output.writeFieldBegin('docSubStatusHistId', Thrift.Type.STRING, 11);
      output.writeString(this.docSubStatusHistId);
      output.writeFieldEnd();
    }
    if (this.commentType !== null && this.commentType !== undefined) {
      output.writeFieldBegin('commentType', Thrift.Type.I32, 12);
      output.writeI32(this.commentType);
      output.writeFieldEnd();
    }
    if (this.rootCreateDate !== null && this.rootCreateDate !== undefined) {
      output.writeFieldBegin('rootCreateDate', Thrift.Type.I64, 13);
      output.writeI64(this.rootCreateDate);
      output.writeFieldEnd();
    }
    if (this.rootCreatorId !== null && this.rootCreatorId !== undefined) {
      output.writeFieldBegin('rootCreatorId', Thrift.Type.STRING, 14);
      output.writeString(this.rootCreatorId);
      output.writeFieldEnd();
    }
    if (this.rootCreator !== null && this.rootCreator !== undefined) {
      output.writeFieldBegin('rootCreator', Thrift.Type.STRUCT, 15);
      this.rootCreator.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 16);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.modifierUser !== null && this.modifierUser !== undefined) {
      output.writeFieldBegin('modifierUser', Thrift.Type.STRUCT, 17);
      this.modifierUser.write(output);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 18);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExecutionDelegateInfo = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.documentExecutionId = null;
    this.internalActionIteration = null;
    this.originalUserId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.documentExecutionId !== undefined && args.documentExecutionId !== null) {
        this.documentExecutionId = args.documentExecutionId;
      }
      if (args.internalActionIteration !== undefined && args.internalActionIteration !== null) {
        this.internalActionIteration = args.internalActionIteration;
      }
      if (args.originalUserId !== undefined && args.originalUserId !== null) {
        this.originalUserId = args.originalUserId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.internalActionIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.originalUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExecutionDelegateInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.documentExecutionId !== null && this.documentExecutionId !== undefined) {
      output.writeFieldBegin('documentExecutionId', Thrift.Type.STRING, 3);
      output.writeString(this.documentExecutionId);
      output.writeFieldEnd();
    }
    if (this.internalActionIteration !== null && this.internalActionIteration !== undefined) {
      output.writeFieldBegin('internalActionIteration', Thrift.Type.I32, 4);
      output.writeI32(this.internalActionIteration);
      output.writeFieldEnd();
    }
    if (this.originalUserId !== null && this.originalUserId !== undefined) {
      output.writeFieldBegin('originalUserId', Thrift.Type.STRING, 5);
      output.writeString(this.originalUserId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExecution = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.deleteDate = null;
    this.parentId = null;
    this.path = null;
    this.documentId = null;
    this.stageId = null;
    this.iteration = null;
    this.userOGroup = null;
    this.reassignType = null;
    this.deadlineDateTime = null;
    this.executionDateTime = null;
    this.reassignedDateTime = null;
    this.actionType = null;
    this.informedAboutDeadline = null;
    this.ownerType = null;
    this.decision = null;
    this.countAttachment = null;
    this.digitalSignId = null;
    this.closedBy = null;
    this.taskComment = null;
    this.originalUser = null;
    this.comments = null;
    this.internalCreateIteration = null;
    this.internalActionIteration = null;
    this.periodical = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicJiraEndDate = null;
    this.periodicEndDate = null;
    this.delegateInfo = null;
    this.status = null;
    this.handoverUser = null;
    this.taskCommentUpdateDate = null;
    this.taskCommentUpdateBy = null;
    this.reassignDigitalSignId = null;
    this.requireMyParticipation = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.path !== undefined && args.path !== null) {
        this.path = args.path;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.userOGroup !== undefined && args.userOGroup !== null) {
        this.userOGroup = new UserOrGroup(args.userOGroup);
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
      if (args.deadlineDateTime !== undefined && args.deadlineDateTime !== null) {
        this.deadlineDateTime = args.deadlineDateTime;
      }
      if (args.executionDateTime !== undefined && args.executionDateTime !== null) {
        this.executionDateTime = args.executionDateTime;
      }
      if (args.reassignedDateTime !== undefined && args.reassignedDateTime !== null) {
        this.reassignedDateTime = args.reassignedDateTime;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.informedAboutDeadline !== undefined && args.informedAboutDeadline !== null) {
        this.informedAboutDeadline = args.informedAboutDeadline;
      }
      if (args.ownerType !== undefined && args.ownerType !== null) {
        this.ownerType = args.ownerType;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.countAttachment !== undefined && args.countAttachment !== null) {
        this.countAttachment = args.countAttachment;
      }
      if (args.digitalSignId !== undefined && args.digitalSignId !== null) {
        this.digitalSignId = args.digitalSignId;
      }
      if (args.closedBy !== undefined && args.closedBy !== null) {
        this.closedBy = args.closedBy;
      }
      if (args.taskComment !== undefined && args.taskComment !== null) {
        this.taskComment = args.taskComment;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.comments !== undefined && args.comments !== null) {
        this.comments = Thrift.copyList(args.comments, [DocumentComment]);
      }
      if (args.internalCreateIteration !== undefined && args.internalCreateIteration !== null) {
        this.internalCreateIteration = args.internalCreateIteration;
      }
      if (args.internalActionIteration !== undefined && args.internalActionIteration !== null) {
        this.internalActionIteration = args.internalActionIteration;
      }
      if (args.periodical !== undefined && args.periodical !== null) {
        this.periodical = args.periodical;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicJiraEndDate !== undefined && args.periodicJiraEndDate !== null) {
        this.periodicJiraEndDate = args.periodicJiraEndDate;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.delegateInfo !== undefined && args.delegateInfo !== null) {
        this.delegateInfo = Thrift.copyList(args.delegateInfo, [DocumentExecutionDelegateInfo]);
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.handoverUser !== undefined && args.handoverUser !== null) {
        this.handoverUser = new UserOrGroup(args.handoverUser);
      }
      if (args.taskCommentUpdateDate !== undefined && args.taskCommentUpdateDate !== null) {
        this.taskCommentUpdateDate = args.taskCommentUpdateDate;
      }
      if (args.taskCommentUpdateBy !== undefined && args.taskCommentUpdateBy !== null) {
        this.taskCommentUpdateBy = args.taskCommentUpdateBy;
      }
      if (args.reassignDigitalSignId !== undefined && args.reassignDigitalSignId !== null) {
        this.reassignDigitalSignId = args.reassignDigitalSignId;
      }
      if (args.requireMyParticipation !== undefined && args.requireMyParticipation !== null) {
        this.requireMyParticipation = args.requireMyParticipation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.path = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOGroup = new UserOrGroup();
          this.userOGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I64) {
          this.executionDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.reassignedDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.informedAboutDeadline = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.I32) {
          this.ownerType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.countAttachment = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.digitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.closedBy = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.taskComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.LIST) {
          this.comments = [];
          const _rtmp3116 = input.readListBegin();
          const _size115 = _rtmp3116.size || 0;
          for (let _i117 = 0; _i117 < _size115; ++_i117) {
            let elem118 = null;
            elem118 = new DocumentComment();
            elem118.read(input);
            this.comments.push(elem118);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.internalCreateIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.internalActionIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.periodical = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRING) {
          this.periodicJiraEndDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.LIST) {
          this.delegateInfo = [];
          const _rtmp3120 = input.readListBegin();
          const _size119 = _rtmp3120.size || 0;
          for (let _i121 = 0; _i121 < _size119; ++_i121) {
            let elem122 = null;
            elem122 = new DocumentExecutionDelegateInfo();
            elem122.read(input);
            this.delegateInfo.push(elem122);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRUCT) {
          this.handoverUser = new UserOrGroup();
          this.handoverUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.I64) {
          this.taskCommentUpdateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.STRING) {
          this.taskCommentUpdateBy = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.STRING) {
          this.reassignDigitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.BOOL) {
          this.requireMyParticipation = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExecution');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 3);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 4);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.path !== null && this.path !== undefined) {
      output.writeFieldBegin('path', Thrift.Type.STRING, 5);
      output.writeString(this.path);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 6);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 7);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 8);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.userOGroup !== null && this.userOGroup !== undefined) {
      output.writeFieldBegin('userOGroup', Thrift.Type.STRUCT, 9);
      this.userOGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 10);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    if (this.deadlineDateTime !== null && this.deadlineDateTime !== undefined) {
      output.writeFieldBegin('deadlineDateTime', Thrift.Type.I64, 11);
      output.writeI64(this.deadlineDateTime);
      output.writeFieldEnd();
    }
    if (this.executionDateTime !== null && this.executionDateTime !== undefined) {
      output.writeFieldBegin('executionDateTime', Thrift.Type.I64, 12);
      output.writeI64(this.executionDateTime);
      output.writeFieldEnd();
    }
    if (this.reassignedDateTime !== null && this.reassignedDateTime !== undefined) {
      output.writeFieldBegin('reassignedDateTime', Thrift.Type.I64, 13);
      output.writeI64(this.reassignedDateTime);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 14);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.informedAboutDeadline !== null && this.informedAboutDeadline !== undefined) {
      output.writeFieldBegin('informedAboutDeadline', Thrift.Type.BOOL, 15);
      output.writeBool(this.informedAboutDeadline);
      output.writeFieldEnd();
    }
    if (this.ownerType !== null && this.ownerType !== undefined) {
      output.writeFieldBegin('ownerType', Thrift.Type.I32, 16);
      output.writeI32(this.ownerType);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 17);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.countAttachment !== null && this.countAttachment !== undefined) {
      output.writeFieldBegin('countAttachment', Thrift.Type.I32, 18);
      output.writeI32(this.countAttachment);
      output.writeFieldEnd();
    }
    if (this.digitalSignId !== null && this.digitalSignId !== undefined) {
      output.writeFieldBegin('digitalSignId', Thrift.Type.STRING, 19);
      output.writeString(this.digitalSignId);
      output.writeFieldEnd();
    }
    if (this.closedBy !== null && this.closedBy !== undefined) {
      output.writeFieldBegin('closedBy', Thrift.Type.STRING, 20);
      output.writeString(this.closedBy);
      output.writeFieldEnd();
    }
    if (this.taskComment !== null && this.taskComment !== undefined) {
      output.writeFieldBegin('taskComment', Thrift.Type.STRING, 21);
      output.writeString(this.taskComment);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 22);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.comments !== null && this.comments !== undefined) {
      output.writeFieldBegin('comments', Thrift.Type.LIST, 23);
      output.writeListBegin(Thrift.Type.STRUCT, this.comments.length);
      for (let iter123 in this.comments) {
        if (this.comments.hasOwnProperty(iter123)) {
          iter123 = this.comments[iter123];
          iter123.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.internalCreateIteration !== null && this.internalCreateIteration !== undefined) {
      output.writeFieldBegin('internalCreateIteration', Thrift.Type.I32, 24);
      output.writeI32(this.internalCreateIteration);
      output.writeFieldEnd();
    }
    if (this.internalActionIteration !== null && this.internalActionIteration !== undefined) {
      output.writeFieldBegin('internalActionIteration', Thrift.Type.I32, 25);
      output.writeI32(this.internalActionIteration);
      output.writeFieldEnd();
    }
    if (this.periodical !== null && this.periodical !== undefined) {
      output.writeFieldBegin('periodical', Thrift.Type.BOOL, 26);
      output.writeBool(this.periodical);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 27);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 28);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicJiraEndDate !== null && this.periodicJiraEndDate !== undefined) {
      output.writeFieldBegin('periodicJiraEndDate', Thrift.Type.STRING, 29);
      output.writeString(this.periodicJiraEndDate);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 30);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.delegateInfo !== null && this.delegateInfo !== undefined) {
      output.writeFieldBegin('delegateInfo', Thrift.Type.LIST, 31);
      output.writeListBegin(Thrift.Type.STRUCT, this.delegateInfo.length);
      for (let iter124 in this.delegateInfo) {
        if (this.delegateInfo.hasOwnProperty(iter124)) {
          iter124 = this.delegateInfo[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 32);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.handoverUser !== null && this.handoverUser !== undefined) {
      output.writeFieldBegin('handoverUser', Thrift.Type.STRUCT, 33);
      this.handoverUser.write(output);
      output.writeFieldEnd();
    }
    if (this.taskCommentUpdateDate !== null && this.taskCommentUpdateDate !== undefined) {
      output.writeFieldBegin('taskCommentUpdateDate', Thrift.Type.I64, 34);
      output.writeI64(this.taskCommentUpdateDate);
      output.writeFieldEnd();
    }
    if (this.taskCommentUpdateBy !== null && this.taskCommentUpdateBy !== undefined) {
      output.writeFieldBegin('taskCommentUpdateBy', Thrift.Type.STRING, 35);
      output.writeString(this.taskCommentUpdateBy);
      output.writeFieldEnd();
    }
    if (this.reassignDigitalSignId !== null && this.reassignDigitalSignId !== undefined) {
      output.writeFieldBegin('reassignDigitalSignId', Thrift.Type.STRING, 36);
      output.writeString(this.reassignDigitalSignId);
      output.writeFieldEnd();
    }
    if (this.requireMyParticipation !== null && this.requireMyParticipation !== undefined) {
      output.writeFieldBegin('requireMyParticipation', Thrift.Type.BOOL, 37);
      output.writeBool(this.requireMyParticipation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentParticipantGroup = class {
  constructor(args) {
    this.userOrGroup = null;
    this.dispatchState = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = Thrift.copyList(args.userOrGroup, [UserOrGroup]);
      }
      if (args.dispatchState !== undefined && args.dispatchState !== null) {
        this.dispatchState = args.dispatchState;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroup = [];
          const _rtmp3126 = input.readListBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            let elem128 = null;
            elem128 = new UserOrGroup();
            elem128.read(input);
            this.userOrGroup.push(elem128);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dispatchState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentParticipantGroup');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroup.length);
      for (let iter129 in this.userOrGroup) {
        if (this.userOrGroup.hasOwnProperty(iter129)) {
          iter129 = this.userOrGroup[iter129];
          iter129.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.dispatchState !== null && this.dispatchState !== undefined) {
      output.writeFieldBegin('dispatchState', Thrift.Type.I32, 2);
      output.writeI32(this.dispatchState);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Document = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.originalPatternId = null;
    this.filledDocumentPattern = null;
    this.stage = null;
    this.documentDeadlineDate = null;
    this.deleteDate = null;
    this.numberDocument = null;
    this.nameDocument = null;
    this.chatId = null;
    this.status = null;
    this.subStatus = null;
    this.hasExternalLink = null;
    this.reassignedDateTime = null;
    this.cardDeadlineDate = null;
    this.actionMap = null;
    this.ownerType = null;
    this.iteration = null;
    this.systemNumber = null;
    this.additionConfirmer = null;
    this.viewed = null;
    this.hasDigitalSign = null;
    this.currentExecutors = null;
    this.otherUsers = null;
    this.scChangeDate = null;
    this.registrationDate = null;
    this.sender = null;
    this.recipient = null;
    this.originalUser = null;
    this.documentParticipantGroup = null;
    this.controlForDocument = null;
    this.controlForExecutor = null;
    this.tags = null;
    this.account = null;
    this.moveError = null;
    this.encripted = null;
    this.icon = null;
    this.reassignDeadline = null;
    this.countCurrentExecutors = null;
    this.countOtherUsers = null;
    this.countResponsibleUsers = null;
    this.responsibleUsers = null;
    this.countConfirmerUsers = null;
    this.externalNumber = null;
    this.externalRegDate = null;
    this.externalId = null;
    this.items = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.originalPatternId !== undefined && args.originalPatternId !== null) {
        this.originalPatternId = args.originalPatternId;
      }
      if (args.filledDocumentPattern !== undefined && args.filledDocumentPattern !== null) {
        this.filledDocumentPattern = new FreezeDocumentPattern(args.filledDocumentPattern);
      }
      if (args.stage !== undefined && args.stage !== null) {
        this.stage = new DocumentPatternStage(args.stage);
      }
      if (args.documentDeadlineDate !== undefined && args.documentDeadlineDate !== null) {
        this.documentDeadlineDate = args.documentDeadlineDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.numberDocument !== undefined && args.numberDocument !== null) {
        this.numberDocument = args.numberDocument;
      }
      if (args.nameDocument !== undefined && args.nameDocument !== null) {
        this.nameDocument = args.nameDocument;
      }
      if (args.chatId !== undefined && args.chatId !== null) {
        this.chatId = args.chatId;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.hasExternalLink !== undefined && args.hasExternalLink !== null) {
        this.hasExternalLink = args.hasExternalLink;
      }
      if (args.reassignedDateTime !== undefined && args.reassignedDateTime !== null) {
        this.reassignedDateTime = args.reassignedDateTime;
      }
      if (args.cardDeadlineDate !== undefined && args.cardDeadlineDate !== null) {
        this.cardDeadlineDate = args.cardDeadlineDate;
      }
      if (args.actionMap !== undefined && args.actionMap !== null) {
        this.actionMap = Thrift.copyMap(args.actionMap, [null]);
      }
      if (args.ownerType !== undefined && args.ownerType !== null) {
        this.ownerType = args.ownerType;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.systemNumber !== undefined && args.systemNumber !== null) {
        this.systemNumber = args.systemNumber;
      }
      if (args.additionConfirmer !== undefined && args.additionConfirmer !== null) {
        this.additionConfirmer = args.additionConfirmer;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.hasDigitalSign !== undefined && args.hasDigitalSign !== null) {
        this.hasDigitalSign = args.hasDigitalSign;
      }
      if (args.currentExecutors !== undefined && args.currentExecutors !== null) {
        this.currentExecutors = Thrift.copyList(args.currentExecutors, [DocumentExecution]);
      }
      if (args.otherUsers !== undefined && args.otherUsers !== null) {
        this.otherUsers = Thrift.copyList(args.otherUsers, [DocumentExecution]);
      }
      if (args.scChangeDate !== undefined && args.scChangeDate !== null) {
        this.scChangeDate = args.scChangeDate;
      }
      if (args.registrationDate !== undefined && args.registrationDate !== null) {
        this.registrationDate = args.registrationDate;
      }
      if (args.sender !== undefined && args.sender !== null) {
        this.sender = args.sender;
      }
      if (args.recipient !== undefined && args.recipient !== null) {
        this.recipient = args.recipient;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.documentParticipantGroup !== undefined && args.documentParticipantGroup !== null) {
        this.documentParticipantGroup = Thrift.copyList(args.documentParticipantGroup, [DocumentParticipantGroup]);
      }
      if (args.controlForDocument !== undefined && args.controlForDocument !== null) {
        this.controlForDocument = args.controlForDocument;
      }
      if (args.controlForExecutor !== undefined && args.controlForExecutor !== null) {
        this.controlForExecutor = args.controlForExecutor;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.moveError !== undefined && args.moveError !== null) {
        this.moveError = args.moveError;
      }
      if (args.encripted !== undefined && args.encripted !== null) {
        this.encripted = args.encripted;
      }
      if (args.icon !== undefined && args.icon !== null) {
        this.icon = args.icon;
      }
      if (args.reassignDeadline !== undefined && args.reassignDeadline !== null) {
        this.reassignDeadline = args.reassignDeadline;
      }
      if (args.countCurrentExecutors !== undefined && args.countCurrentExecutors !== null) {
        this.countCurrentExecutors = args.countCurrentExecutors;
      }
      if (args.countOtherUsers !== undefined && args.countOtherUsers !== null) {
        this.countOtherUsers = args.countOtherUsers;
      }
      if (args.countResponsibleUsers !== undefined && args.countResponsibleUsers !== null) {
        this.countResponsibleUsers = args.countResponsibleUsers;
      }
      if (args.responsibleUsers !== undefined && args.responsibleUsers !== null) {
        this.responsibleUsers = Thrift.copyList(args.responsibleUsers, [DocumentExecution]);
      }
      if (args.countConfirmerUsers !== undefined && args.countConfirmerUsers !== null) {
        this.countConfirmerUsers = args.countConfirmerUsers;
      }
      if (args.externalNumber !== undefined && args.externalNumber !== null) {
        this.externalNumber = args.externalNumber;
      }
      if (args.externalRegDate !== undefined && args.externalRegDate !== null) {
        this.externalRegDate = args.externalRegDate;
      }
      if (args.externalId !== undefined && args.externalId !== null) {
        this.externalId = args.externalId;
      }
      if (args.items !== undefined && args.items !== null) {
        this.items = Thrift.copyMap(args.items, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.originalPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filledDocumentPattern = new FreezeDocumentPattern();
          this.filledDocumentPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.stage = new DocumentPatternStage();
          this.stage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.documentDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.numberDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.chatId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.hasExternalLink = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I64) {
          this.reassignedDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I64) {
          this.cardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.MAP) {
          this.actionMap = {};
          const _rtmp3131 = input.readMapBegin();
          const _size130 = _rtmp3131.size || 0;
          for (let _i132 = 0; _i132 < _size130; ++_i132) {
            if (_i132 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key133 = null;
            let val134 = null;
            key133 = input.readString().value;
            val134 = input.readI32().value;
            this.actionMap[key133] = val134;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I32) {
          this.ownerType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.systemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.additionConfirmer = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDigitalSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.LIST) {
          this.currentExecutors = [];
          const _rtmp3136 = input.readListBegin();
          const _size135 = _rtmp3136.size || 0;
          for (let _i137 = 0; _i137 < _size135; ++_i137) {
            let elem138 = null;
            elem138 = new DocumentExecution();
            elem138.read(input);
            this.currentExecutors.push(elem138);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.LIST) {
          this.otherUsers = [];
          const _rtmp3140 = input.readListBegin();
          const _size139 = _rtmp3140.size || 0;
          for (let _i141 = 0; _i141 < _size139; ++_i141) {
            let elem142 = null;
            elem142 = new DocumentExecution();
            elem142.read(input);
            this.otherUsers.push(elem142);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I64) {
          this.scChangeDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.I64) {
          this.registrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.BOOL) {
          this.sender = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.BOOL) {
          this.recipient = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.LIST) {
          this.documentParticipantGroup = [];
          const _rtmp3144 = input.readListBegin();
          const _size143 = _rtmp3144.size || 0;
          for (let _i145 = 0; _i145 < _size143; ++_i145) {
            let elem146 = null;
            elem146 = new DocumentParticipantGroup();
            elem146.read(input);
            this.documentParticipantGroup.push(elem146);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.controlForDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.BOOL) {
          this.controlForExecutor = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.LIST) {
          this.tags = [];
          const _rtmp3148 = input.readListBegin();
          const _size147 = _rtmp3148.size || 0;
          for (let _i149 = 0; _i149 < _size147; ++_i149) {
            let elem150 = null;
            elem150 = input.readString().value;
            this.tags.push(elem150);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.BOOL) {
          this.moveError = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.BOOL) {
          this.encripted = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.I32) {
          this.icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.I64) {
          this.reassignDeadline = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.I32) {
          this.countCurrentExecutors = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.I32) {
          this.countOtherUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.I32) {
          this.countResponsibleUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 42:
        if (ftype == Thrift.Type.LIST) {
          this.responsibleUsers = [];
          const _rtmp3152 = input.readListBegin();
          const _size151 = _rtmp3152.size || 0;
          for (let _i153 = 0; _i153 < _size151; ++_i153) {
            let elem154 = null;
            elem154 = new DocumentExecution();
            elem154.read(input);
            this.responsibleUsers.push(elem154);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 43:
        if (ftype == Thrift.Type.I32) {
          this.countConfirmerUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 44:
        if (ftype == Thrift.Type.STRING) {
          this.externalNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 45:
        if (ftype == Thrift.Type.I64) {
          this.externalRegDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 46:
        if (ftype == Thrift.Type.STRING) {
          this.externalId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 47:
        if (ftype == Thrift.Type.MAP) {
          this.items = {};
          const _rtmp3156 = input.readMapBegin();
          const _size155 = _rtmp3156.size || 0;
          for (let _i157 = 0; _i157 < _size155; ++_i157) {
            if (_i157 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key158 = null;
            let val159 = null;
            key158 = input.readString().value;
            val159 = input.readString().value;
            this.items[key158] = val159;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Document');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.originalPatternId !== null && this.originalPatternId !== undefined) {
      output.writeFieldBegin('originalPatternId', Thrift.Type.STRING, 3);
      output.writeString(this.originalPatternId);
      output.writeFieldEnd();
    }
    if (this.filledDocumentPattern !== null && this.filledDocumentPattern !== undefined) {
      output.writeFieldBegin('filledDocumentPattern', Thrift.Type.STRUCT, 4);
      this.filledDocumentPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.stage !== null && this.stage !== undefined) {
      output.writeFieldBegin('stage', Thrift.Type.STRUCT, 5);
      this.stage.write(output);
      output.writeFieldEnd();
    }
    if (this.documentDeadlineDate !== null && this.documentDeadlineDate !== undefined) {
      output.writeFieldBegin('documentDeadlineDate', Thrift.Type.I64, 6);
      output.writeI64(this.documentDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 7);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.numberDocument !== null && this.numberDocument !== undefined) {
      output.writeFieldBegin('numberDocument', Thrift.Type.STRING, 8);
      output.writeString(this.numberDocument);
      output.writeFieldEnd();
    }
    if (this.nameDocument !== null && this.nameDocument !== undefined) {
      output.writeFieldBegin('nameDocument', Thrift.Type.STRING, 9);
      output.writeString(this.nameDocument);
      output.writeFieldEnd();
    }
    if (this.chatId !== null && this.chatId !== undefined) {
      output.writeFieldBegin('chatId', Thrift.Type.STRING, 10);
      output.writeString(this.chatId);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 11);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 12);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.hasExternalLink !== null && this.hasExternalLink !== undefined) {
      output.writeFieldBegin('hasExternalLink', Thrift.Type.BOOL, 13);
      output.writeBool(this.hasExternalLink);
      output.writeFieldEnd();
    }
    if (this.reassignedDateTime !== null && this.reassignedDateTime !== undefined) {
      output.writeFieldBegin('reassignedDateTime', Thrift.Type.I64, 14);
      output.writeI64(this.reassignedDateTime);
      output.writeFieldEnd();
    }
    if (this.cardDeadlineDate !== null && this.cardDeadlineDate !== undefined) {
      output.writeFieldBegin('cardDeadlineDate', Thrift.Type.I64, 15);
      output.writeI64(this.cardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.actionMap !== null && this.actionMap !== undefined) {
      output.writeFieldBegin('actionMap', Thrift.Type.MAP, 16);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.actionMap));
      for (let kiter160 in this.actionMap) {
        if (this.actionMap.hasOwnProperty(kiter160)) {
          let viter161 = this.actionMap[kiter160];
          output.writeString(kiter160);
          output.writeI32(viter161);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.ownerType !== null && this.ownerType !== undefined) {
      output.writeFieldBegin('ownerType', Thrift.Type.I32, 17);
      output.writeI32(this.ownerType);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 18);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.systemNumber !== null && this.systemNumber !== undefined) {
      output.writeFieldBegin('systemNumber', Thrift.Type.STRING, 19);
      output.writeString(this.systemNumber);
      output.writeFieldEnd();
    }
    if (this.additionConfirmer !== null && this.additionConfirmer !== undefined) {
      output.writeFieldBegin('additionConfirmer', Thrift.Type.BOOL, 20);
      output.writeBool(this.additionConfirmer);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 21);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.hasDigitalSign !== null && this.hasDigitalSign !== undefined) {
      output.writeFieldBegin('hasDigitalSign', Thrift.Type.BOOL, 22);
      output.writeBool(this.hasDigitalSign);
      output.writeFieldEnd();
    }
    if (this.currentExecutors !== null && this.currentExecutors !== undefined) {
      output.writeFieldBegin('currentExecutors', Thrift.Type.LIST, 23);
      output.writeListBegin(Thrift.Type.STRUCT, this.currentExecutors.length);
      for (let iter162 in this.currentExecutors) {
        if (this.currentExecutors.hasOwnProperty(iter162)) {
          iter162 = this.currentExecutors[iter162];
          iter162.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.otherUsers !== null && this.otherUsers !== undefined) {
      output.writeFieldBegin('otherUsers', Thrift.Type.LIST, 24);
      output.writeListBegin(Thrift.Type.STRUCT, this.otherUsers.length);
      for (let iter163 in this.otherUsers) {
        if (this.otherUsers.hasOwnProperty(iter163)) {
          iter163 = this.otherUsers[iter163];
          iter163.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.scChangeDate !== null && this.scChangeDate !== undefined) {
      output.writeFieldBegin('scChangeDate', Thrift.Type.I64, 25);
      output.writeI64(this.scChangeDate);
      output.writeFieldEnd();
    }
    if (this.registrationDate !== null && this.registrationDate !== undefined) {
      output.writeFieldBegin('registrationDate', Thrift.Type.I64, 26);
      output.writeI64(this.registrationDate);
      output.writeFieldEnd();
    }
    if (this.sender !== null && this.sender !== undefined) {
      output.writeFieldBegin('sender', Thrift.Type.BOOL, 27);
      output.writeBool(this.sender);
      output.writeFieldEnd();
    }
    if (this.recipient !== null && this.recipient !== undefined) {
      output.writeFieldBegin('recipient', Thrift.Type.BOOL, 28);
      output.writeBool(this.recipient);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 29);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.documentParticipantGroup !== null && this.documentParticipantGroup !== undefined) {
      output.writeFieldBegin('documentParticipantGroup', Thrift.Type.LIST, 30);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentParticipantGroup.length);
      for (let iter164 in this.documentParticipantGroup) {
        if (this.documentParticipantGroup.hasOwnProperty(iter164)) {
          iter164 = this.documentParticipantGroup[iter164];
          iter164.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.controlForDocument !== null && this.controlForDocument !== undefined) {
      output.writeFieldBegin('controlForDocument', Thrift.Type.BOOL, 31);
      output.writeBool(this.controlForDocument);
      output.writeFieldEnd();
    }
    if (this.controlForExecutor !== null && this.controlForExecutor !== undefined) {
      output.writeFieldBegin('controlForExecutor', Thrift.Type.BOOL, 32);
      output.writeBool(this.controlForExecutor);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.LIST, 33);
      output.writeListBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter165 in this.tags) {
        if (this.tags.hasOwnProperty(iter165)) {
          iter165 = this.tags[iter165];
          output.writeString(iter165);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 34);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.moveError !== null && this.moveError !== undefined) {
      output.writeFieldBegin('moveError', Thrift.Type.BOOL, 35);
      output.writeBool(this.moveError);
      output.writeFieldEnd();
    }
    if (this.encripted !== null && this.encripted !== undefined) {
      output.writeFieldBegin('encripted', Thrift.Type.BOOL, 36);
      output.writeBool(this.encripted);
      output.writeFieldEnd();
    }
    if (this.icon !== null && this.icon !== undefined) {
      output.writeFieldBegin('icon', Thrift.Type.I32, 37);
      output.writeI32(this.icon);
      output.writeFieldEnd();
    }
    if (this.reassignDeadline !== null && this.reassignDeadline !== undefined) {
      output.writeFieldBegin('reassignDeadline', Thrift.Type.I64, 38);
      output.writeI64(this.reassignDeadline);
      output.writeFieldEnd();
    }
    if (this.countCurrentExecutors !== null && this.countCurrentExecutors !== undefined) {
      output.writeFieldBegin('countCurrentExecutors', Thrift.Type.I32, 39);
      output.writeI32(this.countCurrentExecutors);
      output.writeFieldEnd();
    }
    if (this.countOtherUsers !== null && this.countOtherUsers !== undefined) {
      output.writeFieldBegin('countOtherUsers', Thrift.Type.I32, 40);
      output.writeI32(this.countOtherUsers);
      output.writeFieldEnd();
    }
    if (this.countResponsibleUsers !== null && this.countResponsibleUsers !== undefined) {
      output.writeFieldBegin('countResponsibleUsers', Thrift.Type.I32, 41);
      output.writeI32(this.countResponsibleUsers);
      output.writeFieldEnd();
    }
    if (this.responsibleUsers !== null && this.responsibleUsers !== undefined) {
      output.writeFieldBegin('responsibleUsers', Thrift.Type.LIST, 42);
      output.writeListBegin(Thrift.Type.STRUCT, this.responsibleUsers.length);
      for (let iter166 in this.responsibleUsers) {
        if (this.responsibleUsers.hasOwnProperty(iter166)) {
          iter166 = this.responsibleUsers[iter166];
          iter166.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.countConfirmerUsers !== null && this.countConfirmerUsers !== undefined) {
      output.writeFieldBegin('countConfirmerUsers', Thrift.Type.I32, 43);
      output.writeI32(this.countConfirmerUsers);
      output.writeFieldEnd();
    }
    if (this.externalNumber !== null && this.externalNumber !== undefined) {
      output.writeFieldBegin('externalNumber', Thrift.Type.STRING, 44);
      output.writeString(this.externalNumber);
      output.writeFieldEnd();
    }
    if (this.externalRegDate !== null && this.externalRegDate !== undefined) {
      output.writeFieldBegin('externalRegDate', Thrift.Type.I64, 45);
      output.writeI64(this.externalRegDate);
      output.writeFieldEnd();
    }
    if (this.externalId !== null && this.externalId !== undefined) {
      output.writeFieldBegin('externalId', Thrift.Type.STRING, 46);
      output.writeString(this.externalId);
      output.writeFieldEnd();
    }
    if (this.items !== null && this.items !== undefined) {
      output.writeFieldBegin('items', Thrift.Type.MAP, 47);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.items));
      for (let kiter167 in this.items) {
        if (this.items.hasOwnProperty(kiter167)) {
          let viter168 = this.items[kiter167];
          output.writeString(kiter167);
          output.writeString(viter168);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttachmentPermissions = class {
  constructor(args) {
    this.onlineEdit = null;
    this.onlineComment = null;
    this.changeEditMode = null;
    this.canSign = null;
    this.canDownloadOriginal = null;
    this.canDownloadPdf = null;
    if (args) {
      if (args.onlineEdit !== undefined && args.onlineEdit !== null) {
        this.onlineEdit = args.onlineEdit;
      }
      if (args.onlineComment !== undefined && args.onlineComment !== null) {
        this.onlineComment = args.onlineComment;
      }
      if (args.changeEditMode !== undefined && args.changeEditMode !== null) {
        this.changeEditMode = args.changeEditMode;
      }
      if (args.canSign !== undefined && args.canSign !== null) {
        this.canSign = args.canSign;
      }
      if (args.canDownloadOriginal !== undefined && args.canDownloadOriginal !== null) {
        this.canDownloadOriginal = args.canDownloadOriginal;
      }
      if (args.canDownloadPdf !== undefined && args.canDownloadPdf !== null) {
        this.canDownloadPdf = args.canDownloadPdf;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineComment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.changeEditMode = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.canSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.canDownloadOriginal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.canDownloadPdf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttachmentPermissions');
    if (this.onlineEdit !== null && this.onlineEdit !== undefined) {
      output.writeFieldBegin('onlineEdit', Thrift.Type.BOOL, 1);
      output.writeBool(this.onlineEdit);
      output.writeFieldEnd();
    }
    if (this.onlineComment !== null && this.onlineComment !== undefined) {
      output.writeFieldBegin('onlineComment', Thrift.Type.BOOL, 2);
      output.writeBool(this.onlineComment);
      output.writeFieldEnd();
    }
    if (this.changeEditMode !== null && this.changeEditMode !== undefined) {
      output.writeFieldBegin('changeEditMode', Thrift.Type.BOOL, 3);
      output.writeBool(this.changeEditMode);
      output.writeFieldEnd();
    }
    if (this.canSign !== null && this.canSign !== undefined) {
      output.writeFieldBegin('canSign', Thrift.Type.BOOL, 4);
      output.writeBool(this.canSign);
      output.writeFieldEnd();
    }
    if (this.canDownloadOriginal !== null && this.canDownloadOriginal !== undefined) {
      output.writeFieldBegin('canDownloadOriginal', Thrift.Type.BOOL, 5);
      output.writeBool(this.canDownloadOriginal);
      output.writeFieldEnd();
    }
    if (this.canDownloadPdf !== null && this.canDownloadPdf !== undefined) {
      output.writeFieldBegin('canDownloadPdf', Thrift.Type.BOOL, 6);
      output.writeBool(this.canDownloadPdf);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttachmentVersionInfo = class {
  constructor(args) {
    this.id = null;
    this.status = null;
    this.precalculatedRank = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.precalculatedRank !== undefined && args.precalculatedRank !== null) {
        this.precalculatedRank = args.precalculatedRank;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.precalculatedRank = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttachmentVersionInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 2);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.precalculatedRank !== null && this.precalculatedRank !== undefined) {
      output.writeFieldBegin('precalculatedRank', Thrift.Type.I32, 3);
      output.writeI32(this.precalculatedRank);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Attachment = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.fileName = null;
    this.createDate = null;
    this.attHash = null;
    this.preview = null;
    this.creatorId = null;
    this.creator = null;
    this.size = null;
    this.status = null;
    this.stageId = null;
    this.hasDigitalSign = null;
    this.docExecId = null;
    this.autoReplacement = null;
    this.originalUserId = null;
    this.originalUser = null;
    this.forDraft = null;
    this.waitForPublish = null;
    this.fVersion = null;
    this.iteration = null;
    this.attachmentPermissions = null;
    this.versionCount = null;
    this.fType = null;
    this.accessMode = null;
    this.editMode = null;
    this.externalId = null;
    this.meetingId = null;
    this.attachmentExtStatus = null;
    this.versionInfo = null;
    this.patternAttachmentTemplateId = null;
    this.isHidden = null;
    this.signCertKeys = null;
    this.autoAdd = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.attHash !== undefined && args.attHash !== null) {
        this.attHash = args.attHash;
      }
      if (args.preview !== undefined && args.preview !== null) {
        this.preview = Thrift.copyList(args.preview, [null]);
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.size !== undefined && args.size !== null) {
        this.size = args.size;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.hasDigitalSign !== undefined && args.hasDigitalSign !== null) {
        this.hasDigitalSign = args.hasDigitalSign;
      }
      if (args.docExecId !== undefined && args.docExecId !== null) {
        this.docExecId = args.docExecId;
      }
      if (args.autoReplacement !== undefined && args.autoReplacement !== null) {
        this.autoReplacement = args.autoReplacement;
      }
      if (args.originalUserId !== undefined && args.originalUserId !== null) {
        this.originalUserId = args.originalUserId;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.waitForPublish !== undefined && args.waitForPublish !== null) {
        this.waitForPublish = args.waitForPublish;
      }
      if (args.fVersion !== undefined && args.fVersion !== null) {
        this.fVersion = args.fVersion;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.attachmentPermissions !== undefined && args.attachmentPermissions !== null) {
        this.attachmentPermissions = new AttachmentPermissions(args.attachmentPermissions);
      }
      if (args.versionCount !== undefined && args.versionCount !== null) {
        this.versionCount = args.versionCount;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.accessMode !== undefined && args.accessMode !== null) {
        this.accessMode = args.accessMode;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.externalId !== undefined && args.externalId !== null) {
        this.externalId = args.externalId;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.attachmentExtStatus !== undefined && args.attachmentExtStatus !== null) {
        this.attachmentExtStatus = args.attachmentExtStatus;
      }
      if (args.versionInfo !== undefined && args.versionInfo !== null) {
        this.versionInfo = Thrift.copyList(args.versionInfo, [AttachmentVersionInfo]);
      }
      if (args.patternAttachmentTemplateId !== undefined && args.patternAttachmentTemplateId !== null) {
        this.patternAttachmentTemplateId = args.patternAttachmentTemplateId;
      }
      if (args.isHidden !== undefined && args.isHidden !== null) {
        this.isHidden = args.isHidden;
      }
      if (args.signCertKeys !== undefined && args.signCertKeys !== null) {
        this.signCertKeys = Thrift.copyList(args.signCertKeys, [null]);
      }
      if (args.autoAdd !== undefined && args.autoAdd !== null) {
        this.autoAdd = args.autoAdd;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.attHash = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.preview = [];
          const _rtmp3170 = input.readListBegin();
          const _size169 = _rtmp3170.size || 0;
          for (let _i171 = 0; _i171 < _size169; ++_i171) {
            let elem172 = null;
            elem172 = input.readI32().value;
            this.preview.push(elem172);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.size = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDigitalSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.docExecId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.autoReplacement = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.originalUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.waitForPublish = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I64) {
          this.fVersion = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentPermissions = new AttachmentPermissions();
          this.attachmentPermissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.I32) {
          this.versionCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.accessMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.externalId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.I32) {
          this.attachmentExtStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.LIST) {
          this.versionInfo = [];
          const _rtmp3174 = input.readListBegin();
          const _size173 = _rtmp3174.size || 0;
          for (let _i175 = 0; _i175 < _size173; ++_i175) {
            let elem176 = null;
            elem176 = new AttachmentVersionInfo();
            elem176.read(input);
            this.versionInfo.push(elem176);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.patternAttachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.isHidden = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.SET) {
          this.signCertKeys = [];
          const _rtmp3178 = input.readSetBegin();
          const _size177 = _rtmp3178.size || 0;
          for (let _i179 = 0; _i179 < _size177; ++_i179) {
            let elem180 = null;
            elem180 = input.readString().value;
            this.signCertKeys.push(elem180);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.BOOL) {
          this.autoAdd = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Attachment');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 4);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.attHash !== null && this.attHash !== undefined) {
      output.writeFieldBegin('attHash', Thrift.Type.STRING, 5);
      output.writeString(this.attHash);
      output.writeFieldEnd();
    }
    if (this.preview !== null && this.preview !== undefined) {
      output.writeFieldBegin('preview', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I32, this.preview.length);
      for (let iter181 in this.preview) {
        if (this.preview.hasOwnProperty(iter181)) {
          iter181 = this.preview[iter181];
          output.writeI32(iter181);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 7);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 8);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
      output.writeFieldBegin('size', Thrift.Type.I64, 9);
      output.writeI64(this.size);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 10);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 11);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.hasDigitalSign !== null && this.hasDigitalSign !== undefined) {
      output.writeFieldBegin('hasDigitalSign', Thrift.Type.BOOL, 12);
      output.writeBool(this.hasDigitalSign);
      output.writeFieldEnd();
    }
    if (this.docExecId !== null && this.docExecId !== undefined) {
      output.writeFieldBegin('docExecId', Thrift.Type.STRING, 13);
      output.writeString(this.docExecId);
      output.writeFieldEnd();
    }
    if (this.autoReplacement !== null && this.autoReplacement !== undefined) {
      output.writeFieldBegin('autoReplacement', Thrift.Type.BOOL, 14);
      output.writeBool(this.autoReplacement);
      output.writeFieldEnd();
    }
    if (this.originalUserId !== null && this.originalUserId !== undefined) {
      output.writeFieldBegin('originalUserId', Thrift.Type.STRING, 15);
      output.writeString(this.originalUserId);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 16);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 17);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.waitForPublish !== null && this.waitForPublish !== undefined) {
      output.writeFieldBegin('waitForPublish', Thrift.Type.BOOL, 18);
      output.writeBool(this.waitForPublish);
      output.writeFieldEnd();
    }
    if (this.fVersion !== null && this.fVersion !== undefined) {
      output.writeFieldBegin('fVersion', Thrift.Type.I64, 19);
      output.writeI64(this.fVersion);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 20);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.attachmentPermissions !== null && this.attachmentPermissions !== undefined) {
      output.writeFieldBegin('attachmentPermissions', Thrift.Type.STRUCT, 21);
      this.attachmentPermissions.write(output);
      output.writeFieldEnd();
    }
    if (this.versionCount !== null && this.versionCount !== undefined) {
      output.writeFieldBegin('versionCount', Thrift.Type.I32, 22);
      output.writeI32(this.versionCount);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 23);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.accessMode !== null && this.accessMode !== undefined) {
      output.writeFieldBegin('accessMode', Thrift.Type.I32, 24);
      output.writeI32(this.accessMode);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 25);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.externalId !== null && this.externalId !== undefined) {
      output.writeFieldBegin('externalId', Thrift.Type.STRING, 26);
      output.writeString(this.externalId);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 27);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.attachmentExtStatus !== null && this.attachmentExtStatus !== undefined) {
      output.writeFieldBegin('attachmentExtStatus', Thrift.Type.I32, 28);
      output.writeI32(this.attachmentExtStatus);
      output.writeFieldEnd();
    }
    if (this.versionInfo !== null && this.versionInfo !== undefined) {
      output.writeFieldBegin('versionInfo', Thrift.Type.LIST, 29);
      output.writeListBegin(Thrift.Type.STRUCT, this.versionInfo.length);
      for (let iter182 in this.versionInfo) {
        if (this.versionInfo.hasOwnProperty(iter182)) {
          iter182 = this.versionInfo[iter182];
          iter182.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.patternAttachmentTemplateId !== null && this.patternAttachmentTemplateId !== undefined) {
      output.writeFieldBegin('patternAttachmentTemplateId', Thrift.Type.STRING, 30);
      output.writeString(this.patternAttachmentTemplateId);
      output.writeFieldEnd();
    }
    if (this.isHidden !== null && this.isHidden !== undefined) {
      output.writeFieldBegin('isHidden', Thrift.Type.BOOL, 31);
      output.writeBool(this.isHidden);
      output.writeFieldEnd();
    }
    if (this.signCertKeys !== null && this.signCertKeys !== undefined) {
      output.writeFieldBegin('signCertKeys', Thrift.Type.SET, 32);
      output.writeSetBegin(Thrift.Type.STRING, this.signCertKeys.length);
      for (let iter183 in this.signCertKeys) {
        if (this.signCertKeys.hasOwnProperty(iter183)) {
          iter183 = this.signCertKeys[iter183];
          output.writeString(iter183);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.autoAdd !== null && this.autoAdd !== undefined) {
      output.writeFieldBegin('autoAdd', Thrift.Type.BOOL, 33);
      output.writeBool(this.autoAdd);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelation = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.docId1 = null;
    this.docId2 = null;
    this.createDoc2Date = null;
    this.doc2Name = null;
    this.doc2Number = null;
    this.doc2SystemNumber = null;
    this.doc2Access = null;
    this.relationType = null;
    this.doc2Status = null;
    this.doc2SubStatus = null;
    this.doc2DeadlineDate = null;
    this.doc2CardDeadlineDate = null;
    this.resolution = null;
    this.doc2ActionType = null;
    this.doc2HasConfirmationCard = null;
    this.doc2Icon = null;
    this.doc2PatternName = null;
    this.doc2PatternGroupName = null;
    this.doc2StageName = null;
    this.meetingId = null;
    this.meetingName = null;
    this.hasAccessToMeeting = null;
    this.meetingDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.docId1 !== undefined && args.docId1 !== null) {
        this.docId1 = args.docId1;
      }
      if (args.docId2 !== undefined && args.docId2 !== null) {
        this.docId2 = args.docId2;
      }
      if (args.createDoc2Date !== undefined && args.createDoc2Date !== null) {
        this.createDoc2Date = args.createDoc2Date;
      }
      if (args.doc2Name !== undefined && args.doc2Name !== null) {
        this.doc2Name = args.doc2Name;
      }
      if (args.doc2Number !== undefined && args.doc2Number !== null) {
        this.doc2Number = args.doc2Number;
      }
      if (args.doc2SystemNumber !== undefined && args.doc2SystemNumber !== null) {
        this.doc2SystemNumber = args.doc2SystemNumber;
      }
      if (args.doc2Access !== undefined && args.doc2Access !== null) {
        this.doc2Access = args.doc2Access;
      }
      if (args.relationType !== undefined && args.relationType !== null) {
        this.relationType = args.relationType;
      }
      if (args.doc2Status !== undefined && args.doc2Status !== null) {
        this.doc2Status = args.doc2Status;
      }
      if (args.doc2SubStatus !== undefined && args.doc2SubStatus !== null) {
        this.doc2SubStatus = args.doc2SubStatus;
      }
      if (args.doc2DeadlineDate !== undefined && args.doc2DeadlineDate !== null) {
        this.doc2DeadlineDate = args.doc2DeadlineDate;
      }
      if (args.doc2CardDeadlineDate !== undefined && args.doc2CardDeadlineDate !== null) {
        this.doc2CardDeadlineDate = args.doc2CardDeadlineDate;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.doc2ActionType !== undefined && args.doc2ActionType !== null) {
        this.doc2ActionType = Thrift.copyMap(args.doc2ActionType, [null]);
      }
      if (args.doc2HasConfirmationCard !== undefined && args.doc2HasConfirmationCard !== null) {
        this.doc2HasConfirmationCard = args.doc2HasConfirmationCard;
      }
      if (args.doc2Icon !== undefined && args.doc2Icon !== null) {
        this.doc2Icon = args.doc2Icon;
      }
      if (args.doc2PatternName !== undefined && args.doc2PatternName !== null) {
        this.doc2PatternName = args.doc2PatternName;
      }
      if (args.doc2PatternGroupName !== undefined && args.doc2PatternGroupName !== null) {
        this.doc2PatternGroupName = args.doc2PatternGroupName;
      }
      if (args.doc2StageName !== undefined && args.doc2StageName !== null) {
        this.doc2StageName = args.doc2StageName;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.meetingName !== undefined && args.meetingName !== null) {
        this.meetingName = args.meetingName;
      }
      if (args.hasAccessToMeeting !== undefined && args.hasAccessToMeeting !== null) {
        this.hasAccessToMeeting = args.hasAccessToMeeting;
      }
      if (args.meetingDate !== undefined && args.meetingDate !== null) {
        this.meetingDate = args.meetingDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docId1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.docId2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.createDoc2Date = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.doc2Name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.doc2Number = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.doc2SystemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2Access = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.relationType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.doc2Status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.doc2SubStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.doc2DeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I64) {
          this.doc2CardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.resolution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.MAP) {
          this.doc2ActionType = {};
          const _rtmp3185 = input.readMapBegin();
          const _size184 = _rtmp3185.size || 0;
          for (let _i186 = 0; _i186 < _size184; ++_i186) {
            if (_i186 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key187 = null;
            let val188 = null;
            key187 = input.readString().value;
            val188 = input.readI32().value;
            this.doc2ActionType[key187] = val188;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2HasConfirmationCard = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.doc2Icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.doc2PatternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.doc2PatternGroupName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.doc2StageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.STRING) {
          this.meetingName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.BOOL) {
          this.hasAccessToMeeting = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.I64) {
          this.meetingDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelation');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.docId1 !== null && this.docId1 !== undefined) {
      output.writeFieldBegin('docId1', Thrift.Type.STRING, 3);
      output.writeString(this.docId1);
      output.writeFieldEnd();
    }
    if (this.docId2 !== null && this.docId2 !== undefined) {
      output.writeFieldBegin('docId2', Thrift.Type.STRING, 4);
      output.writeString(this.docId2);
      output.writeFieldEnd();
    }
    if (this.createDoc2Date !== null && this.createDoc2Date !== undefined) {
      output.writeFieldBegin('createDoc2Date', Thrift.Type.I64, 5);
      output.writeI64(this.createDoc2Date);
      output.writeFieldEnd();
    }
    if (this.doc2Name !== null && this.doc2Name !== undefined) {
      output.writeFieldBegin('doc2Name', Thrift.Type.STRING, 6);
      output.writeString(this.doc2Name);
      output.writeFieldEnd();
    }
    if (this.doc2Number !== null && this.doc2Number !== undefined) {
      output.writeFieldBegin('doc2Number', Thrift.Type.STRING, 7);
      output.writeString(this.doc2Number);
      output.writeFieldEnd();
    }
    if (this.doc2SystemNumber !== null && this.doc2SystemNumber !== undefined) {
      output.writeFieldBegin('doc2SystemNumber', Thrift.Type.STRING, 8);
      output.writeString(this.doc2SystemNumber);
      output.writeFieldEnd();
    }
    if (this.doc2Access !== null && this.doc2Access !== undefined) {
      output.writeFieldBegin('doc2Access', Thrift.Type.BOOL, 9);
      output.writeBool(this.doc2Access);
      output.writeFieldEnd();
    }
    if (this.relationType !== null && this.relationType !== undefined) {
      output.writeFieldBegin('relationType', Thrift.Type.I32, 10);
      output.writeI32(this.relationType);
      output.writeFieldEnd();
    }
    if (this.doc2Status !== null && this.doc2Status !== undefined) {
      output.writeFieldBegin('doc2Status', Thrift.Type.I32, 11);
      output.writeI32(this.doc2Status);
      output.writeFieldEnd();
    }
    if (this.doc2SubStatus !== null && this.doc2SubStatus !== undefined) {
      output.writeFieldBegin('doc2SubStatus', Thrift.Type.I32, 12);
      output.writeI32(this.doc2SubStatus);
      output.writeFieldEnd();
    }
    if (this.doc2DeadlineDate !== null && this.doc2DeadlineDate !== undefined) {
      output.writeFieldBegin('doc2DeadlineDate', Thrift.Type.I64, 13);
      output.writeI64(this.doc2DeadlineDate);
      output.writeFieldEnd();
    }
    if (this.doc2CardDeadlineDate !== null && this.doc2CardDeadlineDate !== undefined) {
      output.writeFieldBegin('doc2CardDeadlineDate', Thrift.Type.I64, 14);
      output.writeI64(this.doc2CardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.STRING, 15);
      output.writeString(this.resolution);
      output.writeFieldEnd();
    }
    if (this.doc2ActionType !== null && this.doc2ActionType !== undefined) {
      output.writeFieldBegin('doc2ActionType', Thrift.Type.MAP, 16);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.doc2ActionType));
      for (let kiter189 in this.doc2ActionType) {
        if (this.doc2ActionType.hasOwnProperty(kiter189)) {
          let viter190 = this.doc2ActionType[kiter189];
          output.writeString(kiter189);
          output.writeI32(viter190);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.doc2HasConfirmationCard !== null && this.doc2HasConfirmationCard !== undefined) {
      output.writeFieldBegin('doc2HasConfirmationCard', Thrift.Type.BOOL, 17);
      output.writeBool(this.doc2HasConfirmationCard);
      output.writeFieldEnd();
    }
    if (this.doc2Icon !== null && this.doc2Icon !== undefined) {
      output.writeFieldBegin('doc2Icon', Thrift.Type.I32, 18);
      output.writeI32(this.doc2Icon);
      output.writeFieldEnd();
    }
    if (this.doc2PatternName !== null && this.doc2PatternName !== undefined) {
      output.writeFieldBegin('doc2PatternName', Thrift.Type.STRING, 19);
      output.writeString(this.doc2PatternName);
      output.writeFieldEnd();
    }
    if (this.doc2PatternGroupName !== null && this.doc2PatternGroupName !== undefined) {
      output.writeFieldBegin('doc2PatternGroupName', Thrift.Type.STRING, 20);
      output.writeString(this.doc2PatternGroupName);
      output.writeFieldEnd();
    }
    if (this.doc2StageName !== null && this.doc2StageName !== undefined) {
      output.writeFieldBegin('doc2StageName', Thrift.Type.STRING, 21);
      output.writeString(this.doc2StageName);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 22);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.meetingName !== null && this.meetingName !== undefined) {
      output.writeFieldBegin('meetingName', Thrift.Type.STRING, 23);
      output.writeString(this.meetingName);
      output.writeFieldEnd();
    }
    if (this.hasAccessToMeeting !== null && this.hasAccessToMeeting !== undefined) {
      output.writeFieldBegin('hasAccessToMeeting', Thrift.Type.BOOL, 24);
      output.writeBool(this.hasAccessToMeeting);
      output.writeFieldEnd();
    }
    if (this.meetingDate !== null && this.meetingDate !== undefined) {
      output.writeFieldBegin('meetingDate', Thrift.Type.I64, 26);
      output.writeI64(this.meetingDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ExecutionTree = class {
  constructor(args) {
    this.card = null;
    this.attachments = null;
    this.comments = null;
    this.childTree = null;
    this.parentTree = null;
    this.docRelations = null;
    this.period = null;
    this.periodicEndDate = null;
    if (args) {
      if (args.card !== undefined && args.card !== null) {
        this.card = new DocumentExecution(args.card);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [Attachment]);
      }
      if (args.comments !== undefined && args.comments !== null) {
        this.comments = Thrift.copyList(args.comments, [DocumentComment]);
      }
      if (args.childTree !== undefined && args.childTree !== null) {
        this.childTree = Thrift.copyList(args.childTree, [null]);
      }
      if (args.parentTree !== undefined && args.parentTree !== null) {
        this.parentTree = new ExecutionTree(args.parentTree);
      }
      if (args.docRelations !== undefined && args.docRelations !== null) {
        this.docRelations = Thrift.copyList(args.docRelations, [DocumentRelation]);
      }
      if (args.period !== undefined && args.period !== null) {
        this.period = args.period;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.card = new DocumentExecution();
          this.card.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3192 = input.readListBegin();
          const _size191 = _rtmp3192.size || 0;
          for (let _i193 = 0; _i193 < _size191; ++_i193) {
            let elem194 = null;
            elem194 = new Attachment();
            elem194.read(input);
            this.attachments.push(elem194);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.comments = [];
          const _rtmp3196 = input.readListBegin();
          const _size195 = _rtmp3196.size || 0;
          for (let _i197 = 0; _i197 < _size195; ++_i197) {
            let elem198 = null;
            elem198 = new DocumentComment();
            elem198.read(input);
            this.comments.push(elem198);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.childTree = [];
          const _rtmp3200 = input.readListBegin();
          const _size199 = _rtmp3200.size || 0;
          for (let _i201 = 0; _i201 < _size199; ++_i201) {
            let elem202 = null;
            elem202 = new ExecutionTree();
            elem202.read(input);
            this.childTree.push(elem202);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.parentTree = new ExecutionTree();
          this.parentTree.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.docRelations = [];
          const _rtmp3204 = input.readListBegin();
          const _size203 = _rtmp3204.size || 0;
          for (let _i205 = 0; _i205 < _size203; ++_i205) {
            let elem206 = null;
            elem206 = new DocumentRelation();
            elem206.read(input);
            this.docRelations.push(elem206);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.period = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ExecutionTree');
    if (this.card !== null && this.card !== undefined) {
      output.writeFieldBegin('card', Thrift.Type.STRUCT, 1);
      this.card.write(output);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter207 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter207)) {
          iter207 = this.attachments[iter207];
          iter207.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.comments !== null && this.comments !== undefined) {
      output.writeFieldBegin('comments', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.comments.length);
      for (let iter208 in this.comments) {
        if (this.comments.hasOwnProperty(iter208)) {
          iter208 = this.comments[iter208];
          iter208.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.childTree !== null && this.childTree !== undefined) {
      output.writeFieldBegin('childTree', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.childTree.length);
      for (let iter209 in this.childTree) {
        if (this.childTree.hasOwnProperty(iter209)) {
          iter209 = this.childTree[iter209];
          iter209.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.parentTree !== null && this.parentTree !== undefined) {
      output.writeFieldBegin('parentTree', Thrift.Type.STRUCT, 5);
      this.parentTree.write(output);
      output.writeFieldEnd();
    }
    if (this.docRelations !== null && this.docRelations !== undefined) {
      output.writeFieldBegin('docRelations', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelations.length);
      for (let iter210 in this.docRelations) {
        if (this.docRelations.hasOwnProperty(iter210)) {
          iter210 = this.docRelations[iter210];
          iter210.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.period !== null && this.period !== undefined) {
      output.writeFieldBegin('period', Thrift.Type.STRING, 7);
      output.writeString(this.period);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 8);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PassedStage = class {
  constructor(args) {
    this.passedStage = null;
    this.iteration = null;
    this.startDate = null;
    this.factDate = null;
    this.deadLineDate = null;
    if (args) {
      if (args.passedStage !== undefined && args.passedStage !== null) {
        this.passedStage = new DocumentPatternStage(args.passedStage);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.startDate !== undefined && args.startDate !== null) {
        this.startDate = args.startDate;
      }
      if (args.factDate !== undefined && args.factDate !== null) {
        this.factDate = args.factDate;
      }
      if (args.deadLineDate !== undefined && args.deadLineDate !== null) {
        this.deadLineDate = args.deadLineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.passedStage = new DocumentPatternStage();
          this.passedStage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.startDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.factDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadLineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PassedStage');
    if (this.passedStage !== null && this.passedStage !== undefined) {
      output.writeFieldBegin('passedStage', Thrift.Type.STRUCT, 1);
      this.passedStage.write(output);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 2);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.startDate !== null && this.startDate !== undefined) {
      output.writeFieldBegin('startDate', Thrift.Type.I64, 3);
      output.writeI64(this.startDate);
      output.writeFieldEnd();
    }
    if (this.factDate !== null && this.factDate !== undefined) {
      output.writeFieldBegin('factDate', Thrift.Type.I64, 4);
      output.writeI64(this.factDate);
      output.writeFieldEnd();
    }
    if (this.deadLineDate !== null && this.deadLineDate !== undefined) {
      output.writeFieldBegin('deadLineDate', Thrift.Type.I64, 5);
      output.writeI64(this.deadLineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttCreateInfo = class {
  constructor(args) {
    this.attachmentId = null;
    this.attachmentTemplateId = null;
    this.fileName = null;
    this.forDraft = null;
    this.editMode = null;
    this.meetingId = null;
    this.attachmentExtStatus = null;
    if (args) {
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentTemplateId !== undefined && args.attachmentTemplateId !== null) {
        this.attachmentTemplateId = args.attachmentTemplateId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.attachmentExtStatus !== undefined && args.attachmentExtStatus !== null) {
        this.attachmentExtStatus = args.attachmentExtStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.attachmentExtStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttCreateInfo');
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 1);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentTemplateId !== null && this.attachmentTemplateId !== undefined) {
      output.writeFieldBegin('attachmentTemplateId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentTemplateId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 4);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 5);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 6);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.attachmentExtStatus !== null && this.attachmentExtStatus !== undefined) {
      output.writeFieldBegin('attachmentExtStatus', Thrift.Type.I32, 7);
      output.writeI32(this.attachmentExtStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentReassign = class {
  constructor(args) {
    this.id = null;
    this.dateStart = null;
    this.dateEnd = null;
    this.userOrGroup = null;
    this.deadLineTime = null;
    this.reassignType = null;
    this.comment = null;
    this.periodical = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicEndDate = null;
    this.cardActivityPeriod = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.dateStart !== undefined && args.dateStart !== null) {
        this.dateStart = args.dateStart;
      }
      if (args.dateEnd !== undefined && args.dateEnd !== null) {
        this.dateEnd = args.dateEnd;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.deadLineTime !== undefined && args.deadLineTime !== null) {
        this.deadLineTime = args.deadLineTime;
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.periodical !== undefined && args.periodical !== null) {
        this.periodical = args.periodical;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.cardActivityPeriod !== undefined && args.cardActivityPeriod !== null) {
        this.cardActivityPeriod = args.cardActivityPeriod;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.dateStart = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.dateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadLineTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.periodical = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.cardActivityPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentReassign');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.dateStart !== null && this.dateStart !== undefined) {
      output.writeFieldBegin('dateStart', Thrift.Type.I64, 2);
      output.writeI64(this.dateStart);
      output.writeFieldEnd();
    }
    if (this.dateEnd !== null && this.dateEnd !== undefined) {
      output.writeFieldBegin('dateEnd', Thrift.Type.I64, 3);
      output.writeI64(this.dateEnd);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 4);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.deadLineTime !== null && this.deadLineTime !== undefined) {
      output.writeFieldBegin('deadLineTime', Thrift.Type.I64, 5);
      output.writeI64(this.deadLineTime);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 6);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 7);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.periodical !== null && this.periodical !== undefined) {
      output.writeFieldBegin('periodical', Thrift.Type.BOOL, 8);
      output.writeBool(this.periodical);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 9);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 10);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 11);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.cardActivityPeriod !== null && this.cardActivityPeriod !== undefined) {
      output.writeFieldBegin('cardActivityPeriod', Thrift.Type.STRING, 12);
      output.writeString(this.cardActivityPeriod);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolderShowPlace = class {
  constructor(args) {
    this.id = null;
    this.stageId = null;
    this.seqNum = null;
    this.accessRule = null;
    this.contentHolder = null;
    this.allowEdit = null;
    this.linkId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.accessRule !== undefined && args.accessRule !== null) {
        this.accessRule = new AccessRule(args.accessRule);
      }
      if (args.contentHolder !== undefined && args.contentHolder !== null) {
        this.contentHolder = new ContentHolder(args.contentHolder);
      }
      if (args.allowEdit !== undefined && args.allowEdit !== null) {
        this.allowEdit = args.allowEdit;
      }
      if (args.linkId !== undefined && args.linkId !== null) {
        this.linkId = args.linkId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessRule = new AccessRule();
          this.accessRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentHolder = new ContentHolder();
          this.contentHolder.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.allowEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.linkId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolderShowPlace');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 2);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 3);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.accessRule !== null && this.accessRule !== undefined) {
      output.writeFieldBegin('accessRule', Thrift.Type.STRUCT, 4);
      this.accessRule.write(output);
      output.writeFieldEnd();
    }
    if (this.contentHolder !== null && this.contentHolder !== undefined) {
      output.writeFieldBegin('contentHolder', Thrift.Type.STRUCT, 5);
      this.contentHolder.write(output);
      output.writeFieldEnd();
    }
    if (this.allowEdit !== null && this.allowEdit !== undefined) {
      output.writeFieldBegin('allowEdit', Thrift.Type.BOOL, 6);
      output.writeBool(this.allowEdit);
      output.writeFieldEnd();
    }
    if (this.linkId !== null && this.linkId !== undefined) {
      output.writeFieldBegin('linkId', Thrift.Type.STRING, 7);
      output.writeString(this.linkId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolder = class {
  constructor(args) {
    this.id = null;
    this.patternId = null;
    this.oName = null;
    this.isSystem = null;
    this.contentHolderLink = null;
    this.visibleOnShort = null;
    this.visibleOnFull = null;
    this.showInInfo = null;
    this.order = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.isSystem !== undefined && args.isSystem !== null) {
        this.isSystem = args.isSystem;
      }
      if (args.contentHolderLink !== undefined && args.contentHolderLink !== null) {
        this.contentHolderLink = Thrift.copyList(args.contentHolderLink, [null]);
      }
      if (args.visibleOnShort !== undefined && args.visibleOnShort !== null) {
        this.visibleOnShort = args.visibleOnShort;
      }
      if (args.visibleOnFull !== undefined && args.visibleOnFull !== null) {
        this.visibleOnFull = args.visibleOnFull;
      }
      if (args.showInInfo !== undefined && args.showInInfo !== null) {
        this.showInInfo = args.showInInfo;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.isSystem = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.contentHolderLink = [];
          const _rtmp3212 = input.readListBegin();
          const _size211 = _rtmp3212.size || 0;
          for (let _i213 = 0; _i213 < _size211; ++_i213) {
            let elem214 = null;
            elem214 = new ContentHolderLink();
            elem214.read(input);
            this.contentHolderLink.push(elem214);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnShort = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnFull = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.showInInfo = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolder');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 3);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.isSystem !== null && this.isSystem !== undefined) {
      output.writeFieldBegin('isSystem', Thrift.Type.BOOL, 4);
      output.writeBool(this.isSystem);
      output.writeFieldEnd();
    }
    if (this.contentHolderLink !== null && this.contentHolderLink !== undefined) {
      output.writeFieldBegin('contentHolderLink', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentHolderLink.length);
      for (let iter215 in this.contentHolderLink) {
        if (this.contentHolderLink.hasOwnProperty(iter215)) {
          iter215 = this.contentHolderLink[iter215];
          iter215.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.visibleOnShort !== null && this.visibleOnShort !== undefined) {
      output.writeFieldBegin('visibleOnShort', Thrift.Type.BOOL, 6);
      output.writeBool(this.visibleOnShort);
      output.writeFieldEnd();
    }
    if (this.visibleOnFull !== null && this.visibleOnFull !== undefined) {
      output.writeFieldBegin('visibleOnFull', Thrift.Type.BOOL, 7);
      output.writeBool(this.visibleOnFull);
      output.writeFieldEnd();
    }
    if (this.showInInfo !== null && this.showInInfo !== undefined) {
      output.writeFieldBegin('showInInfo', Thrift.Type.BOOL, 8);
      output.writeBool(this.showInInfo);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 9);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolderLink = class {
  constructor(args) {
    this.id = null;
    this.contentItem = null;
    this.requared = null;
    this.readOnly = null;
    this.order = null;
    this.showPlace = null;
    this.visible = null;
    this.visibleScript = null;
    this.readonlyScript = null;
    this.onChangeScript = null;
    this.allowForCurUser = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.contentItem !== undefined && args.contentItem !== null) {
        this.contentItem = new ContentItem(args.contentItem);
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.showPlace !== undefined && args.showPlace !== null) {
        this.showPlace = args.showPlace;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.visibleScript !== undefined && args.visibleScript !== null) {
        this.visibleScript = args.visibleScript;
      }
      if (args.readonlyScript !== undefined && args.readonlyScript !== null) {
        this.readonlyScript = args.readonlyScript;
      }
      if (args.onChangeScript !== undefined && args.onChangeScript !== null) {
        this.onChangeScript = args.onChangeScript;
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentItem = new ContentItem();
          this.contentItem.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.showPlace = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.visibleScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.readonlyScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.onChangeScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolderLink');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.contentItem !== null && this.contentItem !== undefined) {
      output.writeFieldBegin('contentItem', Thrift.Type.STRUCT, 2);
      this.contentItem.write(output);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 3);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 4);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 5);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.showPlace !== null && this.showPlace !== undefined) {
      output.writeFieldBegin('showPlace', Thrift.Type.I32, 6);
      output.writeI32(this.showPlace);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 7);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.visibleScript !== null && this.visibleScript !== undefined) {
      output.writeFieldBegin('visibleScript', Thrift.Type.STRING, 8);
      output.writeString(this.visibleScript);
      output.writeFieldEnd();
    }
    if (this.readonlyScript !== null && this.readonlyScript !== undefined) {
      output.writeFieldBegin('readonlyScript', Thrift.Type.STRING, 9);
      output.writeString(this.readonlyScript);
      output.writeFieldEnd();
    }
    if (this.onChangeScript !== null && this.onChangeScript !== undefined) {
      output.writeFieldBegin('onChangeScript', Thrift.Type.STRING, 10);
      output.writeString(this.onChangeScript);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 11);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentTab = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.seqNum = null;
    this.contentItems = null;
    this.enableEdit = null;
    this.visibleOnShort = null;
    this.visibleOnFull = null;
    this.allowForCurUser = null;
    this.visible = null;
    this.editOnCreate = null;
    this.visibleOnCreate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
      if (args.enableEdit !== undefined && args.enableEdit !== null) {
        this.enableEdit = Thrift.copyMap(args.enableEdit, [AccessRule]);
      }
      if (args.visibleOnShort !== undefined && args.visibleOnShort !== null) {
        this.visibleOnShort = args.visibleOnShort;
      }
      if (args.visibleOnFull !== undefined && args.visibleOnFull !== null) {
        this.visibleOnFull = args.visibleOnFull;
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = Thrift.copyMap(args.visible, [null]);
      }
      if (args.editOnCreate !== undefined && args.editOnCreate !== null) {
        this.editOnCreate = args.editOnCreate;
      }
      if (args.visibleOnCreate !== undefined && args.visibleOnCreate !== null) {
        this.visibleOnCreate = args.visibleOnCreate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3217 = input.readListBegin();
          const _size216 = _rtmp3217.size || 0;
          for (let _i218 = 0; _i218 < _size216; ++_i218) {
            let elem219 = null;
            elem219 = new ContentItem();
            elem219.read(input);
            this.contentItems.push(elem219);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.MAP) {
          this.enableEdit = {};
          const _rtmp3221 = input.readMapBegin();
          const _size220 = _rtmp3221.size || 0;
          for (let _i222 = 0; _i222 < _size220; ++_i222) {
            if (_i222 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key223 = null;
            let val224 = null;
            key223 = input.readString().value;
            val224 = new AccessRule();
            val224.read(input);
            this.enableEdit[key223] = val224;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnShort = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnFull = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.MAP) {
          this.visible = {};
          const _rtmp3226 = input.readMapBegin();
          const _size225 = _rtmp3226.size || 0;
          for (let _i227 = 0; _i227 < _size225; ++_i227) {
            if (_i227 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key228 = null;
            let val229 = null;
            key228 = input.readString().value;
            val229 = input.readBool().value;
            this.visible[key228] = val229;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.editOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentTab');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 3);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter230 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter230)) {
          iter230 = this.contentItems[iter230];
          iter230.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.enableEdit !== null && this.enableEdit !== undefined) {
      output.writeFieldBegin('enableEdit', Thrift.Type.MAP, 5);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.enableEdit));
      for (let kiter231 in this.enableEdit) {
        if (this.enableEdit.hasOwnProperty(kiter231)) {
          let viter232 = this.enableEdit[kiter231];
          output.writeString(kiter231);
          viter232.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.visibleOnShort !== null && this.visibleOnShort !== undefined) {
      output.writeFieldBegin('visibleOnShort', Thrift.Type.BOOL, 6);
      output.writeBool(this.visibleOnShort);
      output.writeFieldEnd();
    }
    if (this.visibleOnFull !== null && this.visibleOnFull !== undefined) {
      output.writeFieldBegin('visibleOnFull', Thrift.Type.BOOL, 7);
      output.writeBool(this.visibleOnFull);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 8);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.MAP, 9);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.visible));
      for (let kiter233 in this.visible) {
        if (this.visible.hasOwnProperty(kiter233)) {
          let viter234 = this.visible[kiter233];
          output.writeString(kiter233);
          output.writeBool(viter234);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.editOnCreate !== null && this.editOnCreate !== undefined) {
      output.writeFieldBegin('editOnCreate', Thrift.Type.BOOL, 10);
      output.writeBool(this.editOnCreate);
      output.writeFieldEnd();
    }
    if (this.visibleOnCreate !== null && this.visibleOnCreate !== undefined) {
      output.writeFieldBegin('visibleOnCreate', Thrift.Type.BOOL, 11);
      output.writeBool(this.visibleOnCreate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryData = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.documentId = null;
    this.level = null;
    this.key = null;
    this.parameters = null;
    this.client = null;
    this.originalUser = null;
    this.docNumber = null;
    this.docSysNumber = null;
    this.attachmentId = null;
    this.attachmentFileName = null;
    this.ip1 = null;
    this.ip2 = null;
    this.patternId = null;
    this.hasDetailData = null;
    this.nomenclatureNumberId = null;
    this.additionalParams = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.level !== undefined && args.level !== null) {
        this.level = args.level;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.parameters !== undefined && args.parameters !== null) {
        this.parameters = Thrift.copyList(args.parameters, [null]);
      }
      if (args.client !== undefined && args.client !== null) {
        this.client = new UserOrGroup(args.client);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.docNumber !== undefined && args.docNumber !== null) {
        this.docNumber = args.docNumber;
      }
      if (args.docSysNumber !== undefined && args.docSysNumber !== null) {
        this.docSysNumber = args.docSysNumber;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentFileName !== undefined && args.attachmentFileName !== null) {
        this.attachmentFileName = args.attachmentFileName;
      }
      if (args.ip1 !== undefined && args.ip1 !== null) {
        this.ip1 = args.ip1;
      }
      if (args.ip2 !== undefined && args.ip2 !== null) {
        this.ip2 = args.ip2;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.hasDetailData !== undefined && args.hasDetailData !== null) {
        this.hasDetailData = args.hasDetailData;
      }
      if (args.nomenclatureNumberId !== undefined && args.nomenclatureNumberId !== null) {
        this.nomenclatureNumberId = args.nomenclatureNumberId;
      }
      if (args.additionalParams !== undefined && args.additionalParams !== null) {
        this.additionalParams = Thrift.copyMap(args.additionalParams, [Thrift.copyList, null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.level = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.parameters = [];
          const _rtmp3236 = input.readListBegin();
          const _size235 = _rtmp3236.size || 0;
          for (let _i237 = 0; _i237 < _size235; ++_i237) {
            let elem238 = null;
            elem238 = input.readString().value;
            this.parameters.push(elem238);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.client = new UserOrGroup();
          this.client.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.docNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.docSysNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentFileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.ip1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.ip2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDetailData = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureNumberId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.MAP) {
          this.additionalParams = {};
          const _rtmp3240 = input.readMapBegin();
          const _size239 = _rtmp3240.size || 0;
          for (let _i241 = 0; _i241 < _size239; ++_i241) {
            if (_i241 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key242 = null;
            let val243 = null;
            key242 = input.readString().value;
            val243 = [];
            const _rtmp3245 = input.readListBegin();
            const _size244 = _rtmp3245.size || 0;
            for (let _i246 = 0; _i246 < _size244; ++_i246) {
              let elem247 = null;
              elem247 = input.readString().value;
              val243.push(elem247);
            }
            input.readListEnd();
            this.additionalParams[key242] = val243;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryData');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.level !== null && this.level !== undefined) {
      output.writeFieldBegin('level', Thrift.Type.I32, 4);
      output.writeI32(this.level);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 5);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.parameters !== null && this.parameters !== undefined) {
      output.writeFieldBegin('parameters', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.parameters.length);
      for (let iter248 in this.parameters) {
        if (this.parameters.hasOwnProperty(iter248)) {
          iter248 = this.parameters[iter248];
          output.writeString(iter248);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.client !== null && this.client !== undefined) {
      output.writeFieldBegin('client', Thrift.Type.STRUCT, 7);
      this.client.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 8);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.docNumber !== null && this.docNumber !== undefined) {
      output.writeFieldBegin('docNumber', Thrift.Type.STRING, 9);
      output.writeString(this.docNumber);
      output.writeFieldEnd();
    }
    if (this.docSysNumber !== null && this.docSysNumber !== undefined) {
      output.writeFieldBegin('docSysNumber', Thrift.Type.STRING, 10);
      output.writeString(this.docSysNumber);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 11);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentFileName !== null && this.attachmentFileName !== undefined) {
      output.writeFieldBegin('attachmentFileName', Thrift.Type.STRING, 12);
      output.writeString(this.attachmentFileName);
      output.writeFieldEnd();
    }
    if (this.ip1 !== null && this.ip1 !== undefined) {
      output.writeFieldBegin('ip1', Thrift.Type.STRING, 13);
      output.writeString(this.ip1);
      output.writeFieldEnd();
    }
    if (this.ip2 !== null && this.ip2 !== undefined) {
      output.writeFieldBegin('ip2', Thrift.Type.STRING, 14);
      output.writeString(this.ip2);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 15);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.hasDetailData !== null && this.hasDetailData !== undefined) {
      output.writeFieldBegin('hasDetailData', Thrift.Type.BOOL, 16);
      output.writeBool(this.hasDetailData);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumberId !== null && this.nomenclatureNumberId !== undefined) {
      output.writeFieldBegin('nomenclatureNumberId', Thrift.Type.STRING, 17);
      output.writeString(this.nomenclatureNumberId);
      output.writeFieldEnd();
    }
    if (this.additionalParams !== null && this.additionalParams !== undefined) {
      output.writeFieldBegin('additionalParams', Thrift.Type.MAP, 18);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.additionalParams));
      for (let kiter249 in this.additionalParams) {
        if (this.additionalParams.hasOwnProperty(kiter249)) {
          let viter250 = this.additionalParams[kiter249];
          output.writeString(kiter249);
          output.writeListBegin(Thrift.Type.STRING, viter250.length);
          for (let iter251 in viter250) {
            if (viter250.hasOwnProperty(iter251)) {
              iter251 = viter250[iter251];
              output.writeString(iter251);
            }
          }
          output.writeListEnd();
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryPage = class {
  constructor(args) {
    this.historyList = null;
    this.totalCount = null;
    if (args) {
      if (args.historyList !== undefined && args.historyList !== null) {
        this.historyList = Thrift.copyList(args.historyList, [HistoryData]);
      }
      if (args.totalCount !== undefined && args.totalCount !== null) {
        this.totalCount = args.totalCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.historyList = [];
          const _rtmp3253 = input.readListBegin();
          const _size252 = _rtmp3253.size || 0;
          for (let _i254 = 0; _i254 < _size252; ++_i254) {
            let elem255 = null;
            elem255 = new HistoryData();
            elem255.read(input);
            this.historyList.push(elem255);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.totalCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryPage');
    if (this.historyList !== null && this.historyList !== undefined) {
      output.writeFieldBegin('historyList', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.historyList.length);
      for (let iter256 in this.historyList) {
        if (this.historyList.hasOwnProperty(iter256)) {
          iter256 = this.historyList[iter256];
          iter256.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.totalCount !== null && this.totalCount !== undefined) {
      output.writeFieldBegin('totalCount', Thrift.Type.I64, 2);
      output.writeI64(this.totalCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DeadlineHistory = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.creator = null;
    this.document = null;
    this.documentExecution = null;
    this.oldDeadlineDate = null;
    this.theNewDeadlineDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.documentExecution !== undefined && args.documentExecution !== null) {
        this.documentExecution = new DocumentExecution(args.documentExecution);
      }
      if (args.oldDeadlineDate !== undefined && args.oldDeadlineDate !== null) {
        this.oldDeadlineDate = args.oldDeadlineDate;
      }
      if (args.theNewDeadlineDate !== undefined && args.theNewDeadlineDate !== null) {
        this.theNewDeadlineDate = args.theNewDeadlineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentExecution = new DocumentExecution();
          this.documentExecution.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.oldDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.theNewDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DeadlineHistory');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 3);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 4);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.documentExecution !== null && this.documentExecution !== undefined) {
      output.writeFieldBegin('documentExecution', Thrift.Type.STRUCT, 5);
      this.documentExecution.write(output);
      output.writeFieldEnd();
    }
    if (this.oldDeadlineDate !== null && this.oldDeadlineDate !== undefined) {
      output.writeFieldBegin('oldDeadlineDate', Thrift.Type.I64, 6);
      output.writeI64(this.oldDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.theNewDeadlineDate !== null && this.theNewDeadlineDate !== undefined) {
      output.writeFieldBegin('theNewDeadlineDate', Thrift.Type.I64, 7);
      output.writeI64(this.theNewDeadlineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExtShare = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.shareType = null;
    this.userId = null;
    this.guestId = null;
    this.secretCode = null;
    this.ruleSet = null;
    this.validTillDate = null;
    this.creatorId = null;
    this.createDate = null;
    this.extId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.shareType !== undefined && args.shareType !== null) {
        this.shareType = args.shareType;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.guestId !== undefined && args.guestId !== null) {
        this.guestId = args.guestId;
      }
      if (args.secretCode !== undefined && args.secretCode !== null) {
        this.secretCode = args.secretCode;
      }
      if (args.ruleSet !== undefined && args.ruleSet !== null) {
        this.ruleSet = Thrift.copyList(args.ruleSet, [null]);
      }
      if (args.validTillDate !== undefined && args.validTillDate !== null) {
        this.validTillDate = args.validTillDate;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.extId !== undefined && args.extId !== null) {
        this.extId = args.extId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.shareType = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.guestId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.secretCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.ruleSet = [];
          const _rtmp3258 = input.readSetBegin();
          const _size257 = _rtmp3258.size || 0;
          for (let _i259 = 0; _i259 < _size257; ++_i259) {
            let elem260 = null;
            elem260 = input.readI32().value;
            this.ruleSet.push(elem260);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.validTillDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.extId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExtShare');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.shareType !== null && this.shareType !== undefined) {
      output.writeFieldBegin('shareType', Thrift.Type.STRING, 3);
      output.writeString(this.shareType);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 4);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.guestId !== null && this.guestId !== undefined) {
      output.writeFieldBegin('guestId', Thrift.Type.STRING, 5);
      output.writeString(this.guestId);
      output.writeFieldEnd();
    }
    if (this.secretCode !== null && this.secretCode !== undefined) {
      output.writeFieldBegin('secretCode', Thrift.Type.STRING, 6);
      output.writeString(this.secretCode);
      output.writeFieldEnd();
    }
    if (this.ruleSet !== null && this.ruleSet !== undefined) {
      output.writeFieldBegin('ruleSet', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.I32, this.ruleSet.length);
      for (let iter261 in this.ruleSet) {
        if (this.ruleSet.hasOwnProperty(iter261)) {
          iter261 = this.ruleSet[iter261];
          output.writeI32(iter261);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validTillDate !== null && this.validTillDate !== undefined) {
      output.writeFieldBegin('validTillDate', Thrift.Type.I64, 8);
      output.writeI64(this.validTillDate);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 9);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 10);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.extId !== null && this.extId !== undefined) {
      output.writeFieldBegin('extId', Thrift.Type.STRING, 11);
      output.writeString(this.extId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternVariable = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.defValue = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.defValue !== undefined && args.defValue !== null) {
        this.defValue = args.defValue;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.defValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternVariable');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.defValue !== null && this.defValue !== undefined) {
      output.writeFieldBegin('defValue', Thrift.Type.STRING, 3);
      output.writeString(this.defValue);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternProcessRoleExec = class {
  constructor(args) {
    this.userOrGroup = null;
    this.childUser = null;
    this.comment = null;
    this.commentDescription = null;
    this.deadlineDate = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.childUser !== undefined && args.childUser !== null) {
        this.childUser = new UserOrGroup(args.childUser);
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.commentDescription !== undefined && args.commentDescription !== null) {
        this.commentDescription = args.commentDescription;
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.childUser = new UserOrGroup();
          this.childUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.commentDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternProcessRoleExec');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 1);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.childUser !== null && this.childUser !== undefined) {
      output.writeFieldBegin('childUser', Thrift.Type.STRUCT, 2);
      this.childUser.write(output);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.commentDescription !== null && this.commentDescription !== undefined) {
      output.writeFieldBegin('commentDescription', Thrift.Type.STRING, 4);
      output.writeString(this.commentDescription);
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 5);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternProcessRole = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.oName = null;
    this.fixed = null;
    this.single = null;
    this.roleExecList = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.single !== undefined && args.single !== null) {
        this.single = args.single;
      }
      if (args.roleExecList !== undefined && args.roleExecList !== null) {
        this.roleExecList = Thrift.copyList(args.roleExecList, [PatternProcessRoleExec]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.single = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.roleExecList = [];
          const _rtmp3263 = input.readListBegin();
          const _size262 = _rtmp3263.size || 0;
          for (let _i264 = 0; _i264 < _size262; ++_i264) {
            let elem265 = null;
            elem265 = new PatternProcessRoleExec();
            elem265.read(input);
            this.roleExecList.push(elem265);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternProcessRole');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 3);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 4);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.single !== null && this.single !== undefined) {
      output.writeFieldBegin('single', Thrift.Type.BOOL, 5);
      output.writeBool(this.single);
      output.writeFieldEnd();
    }
    if (this.roleExecList !== null && this.roleExecList !== undefined) {
      output.writeFieldBegin('roleExecList', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.roleExecList.length);
      for (let iter266 in this.roleExecList) {
        if (this.roleExecList.hasOwnProperty(iter266)) {
          iter266 = this.roleExecList[iter266];
          iter266.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationInfo = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.name = null;
    this.systemNumber = null;
    this.numberDocument = null;
    this.registrationDate = null;
    this.doc2Access = null;
    this.status = null;
    this.subStatus = null;
    this.deadlineDate = null;
    this.cardDeadlineDate = null;
    this.icon = null;
    this.patternName = null;
    this.stageName = null;
    this.actionMap = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.systemNumber !== undefined && args.systemNumber !== null) {
        this.systemNumber = args.systemNumber;
      }
      if (args.numberDocument !== undefined && args.numberDocument !== null) {
        this.numberDocument = args.numberDocument;
      }
      if (args.registrationDate !== undefined && args.registrationDate !== null) {
        this.registrationDate = args.registrationDate;
      }
      if (args.doc2Access !== undefined && args.doc2Access !== null) {
        this.doc2Access = args.doc2Access;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.cardDeadlineDate !== undefined && args.cardDeadlineDate !== null) {
        this.cardDeadlineDate = args.cardDeadlineDate;
      }
      if (args.icon !== undefined && args.icon !== null) {
        this.icon = args.icon;
      }
      if (args.patternName !== undefined && args.patternName !== null) {
        this.patternName = args.patternName;
      }
      if (args.stageName !== undefined && args.stageName !== null) {
        this.stageName = args.stageName;
      }
      if (args.actionMap !== undefined && args.actionMap !== null) {
        this.actionMap = Thrift.copyMap(args.actionMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.systemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.numberDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.registrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2Access = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.cardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.patternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.stageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.MAP) {
          this.actionMap = {};
          const _rtmp3268 = input.readMapBegin();
          const _size267 = _rtmp3268.size || 0;
          for (let _i269 = 0; _i269 < _size267; ++_i269) {
            if (_i269 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key270 = null;
            let val271 = null;
            key270 = input.readString().value;
            val271 = input.readI32().value;
            this.actionMap[key270] = val271;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.systemNumber !== null && this.systemNumber !== undefined) {
      output.writeFieldBegin('systemNumber', Thrift.Type.STRING, 4);
      output.writeString(this.systemNumber);
      output.writeFieldEnd();
    }
    if (this.numberDocument !== null && this.numberDocument !== undefined) {
      output.writeFieldBegin('numberDocument', Thrift.Type.STRING, 5);
      output.writeString(this.numberDocument);
      output.writeFieldEnd();
    }
    if (this.registrationDate !== null && this.registrationDate !== undefined) {
      output.writeFieldBegin('registrationDate', Thrift.Type.I64, 6);
      output.writeI64(this.registrationDate);
      output.writeFieldEnd();
    }
    if (this.doc2Access !== null && this.doc2Access !== undefined) {
      output.writeFieldBegin('doc2Access', Thrift.Type.BOOL, 7);
      output.writeBool(this.doc2Access);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 8);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 9);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 10);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.cardDeadlineDate !== null && this.cardDeadlineDate !== undefined) {
      output.writeFieldBegin('cardDeadlineDate', Thrift.Type.I64, 11);
      output.writeI64(this.cardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.icon !== null && this.icon !== undefined) {
      output.writeFieldBegin('icon', Thrift.Type.I32, 12);
      output.writeI32(this.icon);
      output.writeFieldEnd();
    }
    if (this.patternName !== null && this.patternName !== undefined) {
      output.writeFieldBegin('patternName', Thrift.Type.STRING, 13);
      output.writeString(this.patternName);
      output.writeFieldEnd();
    }
    if (this.stageName !== null && this.stageName !== undefined) {
      output.writeFieldBegin('stageName', Thrift.Type.STRING, 14);
      output.writeString(this.stageName);
      output.writeFieldEnd();
    }
    if (this.actionMap !== null && this.actionMap !== undefined) {
      output.writeFieldBegin('actionMap', Thrift.Type.MAP, 15);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.actionMap));
      for (let kiter272 in this.actionMap) {
        if (this.actionMap.hasOwnProperty(kiter272)) {
          let viter273 = this.actionMap[kiter272];
          output.writeString(kiter272);
          output.writeI32(viter273);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationLink = class {
  constructor(args) {
    this.fromId = null;
    this.toId = null;
    this.linkType = null;
    this.isAuto = null;
    if (args) {
      if (args.fromId !== undefined && args.fromId !== null) {
        this.fromId = args.fromId;
      }
      if (args.toId !== undefined && args.toId !== null) {
        this.toId = args.toId;
      }
      if (args.linkType !== undefined && args.linkType !== null) {
        this.linkType = args.linkType;
      }
      if (args.isAuto !== undefined && args.isAuto !== null) {
        this.isAuto = args.isAuto;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.fromId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.toId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.linkType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.isAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationLink');
    if (this.fromId !== null && this.fromId !== undefined) {
      output.writeFieldBegin('fromId', Thrift.Type.STRING, 1);
      output.writeString(this.fromId);
      output.writeFieldEnd();
    }
    if (this.toId !== null && this.toId !== undefined) {
      output.writeFieldBegin('toId', Thrift.Type.STRING, 2);
      output.writeString(this.toId);
      output.writeFieldEnd();
    }
    if (this.linkType !== null && this.linkType !== undefined) {
      output.writeFieldBegin('linkType', Thrift.Type.I32, 3);
      output.writeI32(this.linkType);
      output.writeFieldEnd();
    }
    if (this.isAuto !== null && this.isAuto !== undefined) {
      output.writeFieldBegin('isAuto', Thrift.Type.BOOL, 4);
      output.writeBool(this.isAuto);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationModel = class {
  constructor(args) {
    this.docId = null;
    this.docRelInfoList = null;
    this.docRelLinkList = null;
    if (args) {
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.docRelInfoList !== undefined && args.docRelInfoList !== null) {
        this.docRelInfoList = Thrift.copyList(args.docRelInfoList, [DocumentRelationInfo]);
      }
      if (args.docRelLinkList !== undefined && args.docRelLinkList !== null) {
        this.docRelLinkList = Thrift.copyList(args.docRelLinkList, [DocumentRelationLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.docRelInfoList = [];
          const _rtmp3275 = input.readListBegin();
          const _size274 = _rtmp3275.size || 0;
          for (let _i276 = 0; _i276 < _size274; ++_i276) {
            let elem277 = null;
            elem277 = new DocumentRelationInfo();
            elem277.read(input);
            this.docRelInfoList.push(elem277);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.docRelLinkList = [];
          const _rtmp3279 = input.readListBegin();
          const _size278 = _rtmp3279.size || 0;
          for (let _i280 = 0; _i280 < _size278; ++_i280) {
            let elem281 = null;
            elem281 = new DocumentRelationLink();
            elem281.read(input);
            this.docRelLinkList.push(elem281);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationModel');
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 1);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.docRelInfoList !== null && this.docRelInfoList !== undefined) {
      output.writeFieldBegin('docRelInfoList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelInfoList.length);
      for (let iter282 in this.docRelInfoList) {
        if (this.docRelInfoList.hasOwnProperty(iter282)) {
          iter282 = this.docRelInfoList[iter282];
          iter282.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docRelLinkList !== null && this.docRelLinkList !== undefined) {
      output.writeFieldBegin('docRelLinkList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelLinkList.length);
      for (let iter283 in this.docRelLinkList) {
        if (this.docRelLinkList.hasOwnProperty(iter283)) {
          iter283 = this.docRelLinkList[iter283];
          iter283.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


DigitalSign = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.attachmentId = null;
    this.methodName = null;
    this.stageId = null;
    this.iteration = null;
    this.signDetails = null;
    this.signProviderType = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.methodName !== undefined && args.methodName !== null) {
        this.methodName = args.methodName;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.signDetails !== undefined && args.signDetails !== null) {
        this.signDetails = Thrift.copyList(args.signDetails, [null]);
      }
      if (args.signProviderType !== undefined && args.signProviderType !== null) {
        this.signProviderType = args.signProviderType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.methodName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.signDetails = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new DigitalSignDetails();
            elem3.read(input);
            this.signDetails.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.signProviderType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DigitalSign');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 3);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.methodName !== null && this.methodName !== undefined) {
      output.writeFieldBegin('methodName', Thrift.Type.STRING, 4);
      output.writeString(this.methodName);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 5);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 6);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.signDetails !== null && this.signDetails !== undefined) {
      output.writeFieldBegin('signDetails', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.signDetails.length);
      for (let iter4 in this.signDetails) {
        if (this.signDetails.hasOwnProperty(iter4)) {
          iter4 = this.signDetails[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.signProviderType !== null && this.signProviderType !== undefined) {
      output.writeFieldBegin('signProviderType', Thrift.Type.I32, 8);
      output.writeI32(this.signProviderType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DigitalSignDetails = class {
  constructor(args) {
    this.id = null;
    this.user = null;
    this.originalUser = null;
    this.certificateInfo = null;
    this.signStatus = null;
    this.signInSystem = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.certificateInfo !== undefined && args.certificateInfo !== null) {
        this.certificateInfo = new CertificateInfo(args.certificateInfo);
      }
      if (args.signStatus !== undefined && args.signStatus !== null) {
        this.signStatus = args.signStatus;
      }
      if (args.signInSystem !== undefined && args.signInSystem !== null) {
        this.signInSystem = args.signInSystem;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.certificateInfo = new CertificateInfo();
          this.certificateInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.signStatus = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signInSystem = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DigitalSignDetails');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 2);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 3);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.certificateInfo !== null && this.certificateInfo !== undefined) {
      output.writeFieldBegin('certificateInfo', Thrift.Type.STRUCT, 4);
      this.certificateInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.signStatus !== null && this.signStatus !== undefined) {
      output.writeFieldBegin('signStatus', Thrift.Type.STRING, 5);
      output.writeString(this.signStatus);
      output.writeFieldEnd();
    }
    if (this.signInSystem !== null && this.signInSystem !== undefined) {
      output.writeFieldBegin('signInSystem', Thrift.Type.STRING, 6);
      output.writeString(this.signInSystem);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SignInfo = class {
  constructor(args) {
    this.digitalSignId = null;
    this.signDetails = null;
    this.documentId = null;
    this.methodName = null;
    this.attachmentName = null;
    this.attachmentPdfName = null;
    this.attachmentPdfFileSize = null;
    this.attachmentP7bName = null;
    this.documentUrl = null;
    this.originalAttachmentDownloadUrl = null;
    this.pdfAttachmentDownloadUrl = null;
    this.p7bAttachmentDownloadUrl = null;
    if (args) {
      if (args.digitalSignId !== undefined && args.digitalSignId !== null) {
        this.digitalSignId = args.digitalSignId;
      }
      if (args.signDetails !== undefined && args.signDetails !== null) {
        this.signDetails = Thrift.copyList(args.signDetails, [DigitalSignDetails]);
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.methodName !== undefined && args.methodName !== null) {
        this.methodName = args.methodName;
      }
      if (args.attachmentName !== undefined && args.attachmentName !== null) {
        this.attachmentName = args.attachmentName;
      }
      if (args.attachmentPdfName !== undefined && args.attachmentPdfName !== null) {
        this.attachmentPdfName = args.attachmentPdfName;
      }
      if (args.attachmentPdfFileSize !== undefined && args.attachmentPdfFileSize !== null) {
        this.attachmentPdfFileSize = args.attachmentPdfFileSize;
      }
      if (args.attachmentP7bName !== undefined && args.attachmentP7bName !== null) {
        this.attachmentP7bName = args.attachmentP7bName;
      }
      if (args.documentUrl !== undefined && args.documentUrl !== null) {
        this.documentUrl = args.documentUrl;
      }
      if (args.originalAttachmentDownloadUrl !== undefined && args.originalAttachmentDownloadUrl !== null) {
        this.originalAttachmentDownloadUrl = args.originalAttachmentDownloadUrl;
      }
      if (args.pdfAttachmentDownloadUrl !== undefined && args.pdfAttachmentDownloadUrl !== null) {
        this.pdfAttachmentDownloadUrl = args.pdfAttachmentDownloadUrl;
      }
      if (args.p7bAttachmentDownloadUrl !== undefined && args.p7bAttachmentDownloadUrl !== null) {
        this.p7bAttachmentDownloadUrl = args.p7bAttachmentDownloadUrl;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.digitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.signDetails = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new DigitalSignDetails();
            elem8.read(input);
            this.signDetails.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.methodName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentPdfName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.attachmentPdfFileSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentP7bName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.documentUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.originalAttachmentDownloadUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.pdfAttachmentDownloadUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.p7bAttachmentDownloadUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SignInfo');
    if (this.digitalSignId !== null && this.digitalSignId !== undefined) {
      output.writeFieldBegin('digitalSignId', Thrift.Type.STRING, 1);
      output.writeString(this.digitalSignId);
      output.writeFieldEnd();
    }
    if (this.signDetails !== null && this.signDetails !== undefined) {
      output.writeFieldBegin('signDetails', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.signDetails.length);
      for (let iter9 in this.signDetails) {
        if (this.signDetails.hasOwnProperty(iter9)) {
          iter9 = this.signDetails[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.methodName !== null && this.methodName !== undefined) {
      output.writeFieldBegin('methodName', Thrift.Type.STRING, 4);
      output.writeString(this.methodName);
      output.writeFieldEnd();
    }
    if (this.attachmentName !== null && this.attachmentName !== undefined) {
      output.writeFieldBegin('attachmentName', Thrift.Type.STRING, 5);
      output.writeString(this.attachmentName);
      output.writeFieldEnd();
    }
    if (this.attachmentPdfName !== null && this.attachmentPdfName !== undefined) {
      output.writeFieldBegin('attachmentPdfName', Thrift.Type.STRING, 6);
      output.writeString(this.attachmentPdfName);
      output.writeFieldEnd();
    }
    if (this.attachmentPdfFileSize !== null && this.attachmentPdfFileSize !== undefined) {
      output.writeFieldBegin('attachmentPdfFileSize', Thrift.Type.I64, 7);
      output.writeI64(this.attachmentPdfFileSize);
      output.writeFieldEnd();
    }
    if (this.attachmentP7bName !== null && this.attachmentP7bName !== undefined) {
      output.writeFieldBegin('attachmentP7bName', Thrift.Type.STRING, 8);
      output.writeString(this.attachmentP7bName);
      output.writeFieldEnd();
    }
    if (this.documentUrl !== null && this.documentUrl !== undefined) {
      output.writeFieldBegin('documentUrl', Thrift.Type.STRING, 9);
      output.writeString(this.documentUrl);
      output.writeFieldEnd();
    }
    if (this.originalAttachmentDownloadUrl !== null && this.originalAttachmentDownloadUrl !== undefined) {
      output.writeFieldBegin('originalAttachmentDownloadUrl', Thrift.Type.STRING, 10);
      output.writeString(this.originalAttachmentDownloadUrl);
      output.writeFieldEnd();
    }
    if (this.pdfAttachmentDownloadUrl !== null && this.pdfAttachmentDownloadUrl !== undefined) {
      output.writeFieldBegin('pdfAttachmentDownloadUrl', Thrift.Type.STRING, 11);
      output.writeString(this.pdfAttachmentDownloadUrl);
      output.writeFieldEnd();
    }
    if (this.p7bAttachmentDownloadUrl !== null && this.p7bAttachmentDownloadUrl !== undefined) {
      output.writeFieldBegin('p7bAttachmentDownloadUrl', Thrift.Type.STRING, 12);
      output.writeString(this.p7bAttachmentDownloadUrl);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PrivateKeyInfo = class {
  constructor(args) {
    this.id = null;
    this.name = null;
    this.publicKeyInfo = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.publicKeyInfo !== undefined && args.publicKeyInfo !== null) {
        this.publicKeyInfo = new CertificateInfo(args.publicKeyInfo);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.publicKeyInfo = new CertificateInfo();
          this.publicKeyInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PrivateKeyInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 2);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.publicKeyInfo !== null && this.publicKeyInfo !== undefined) {
      output.writeFieldBegin('publicKeyInfo', Thrift.Type.STRUCT, 3);
      this.publicKeyInfo.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


FreezePatternValidation = class {
  constructor(args) {
    this.fillPattern = null;
    this.exList = null;
    if (args) {
      if (args.fillPattern !== undefined && args.fillPattern !== null) {
        this.fillPattern = new FreezeDocumentPattern(args.fillPattern);
      }
      if (args.exList !== undefined && args.exList !== null) {
        this.exList = Thrift.copyList(args.exList, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.fillPattern = new FreezeDocumentPattern();
          this.fillPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.exList = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new PreconditionException();
            elem3.read(input);
            this.exList.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FreezePatternValidation');
    if (this.fillPattern !== null && this.fillPattern !== undefined) {
      output.writeFieldBegin('fillPattern', Thrift.Type.STRUCT, 1);
      this.fillPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.exList !== null && this.exList !== undefined) {
      output.writeFieldBegin('exList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.exList.length);
      for (let iter4 in this.exList) {
        if (this.exList.hasOwnProperty(iter4)) {
          iter4 = this.exList[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


FilterField = class {
  constructor(args) {
    this.id = null;
    this.field = null;
    this.displayName = null;
    this.enableSorting = null;
    this.visible = null;
    this.width = null;
    this.color = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.field !== undefined && args.field !== null) {
        this.field = args.field;
      }
      if (args.displayName !== undefined && args.displayName !== null) {
        this.displayName = args.displayName;
      }
      if (args.enableSorting !== undefined && args.enableSorting !== null) {
        this.enableSorting = args.enableSorting;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.width !== undefined && args.width !== null) {
        this.width = args.width;
      }
      if (args.color !== undefined && args.color !== null) {
        this.color = args.color;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.field = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.displayName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.enableSorting = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.width = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.color = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterField');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.field !== null && this.field !== undefined) {
      output.writeFieldBegin('field', Thrift.Type.STRING, 2);
      output.writeString(this.field);
      output.writeFieldEnd();
    }
    if (this.displayName !== null && this.displayName !== undefined) {
      output.writeFieldBegin('displayName', Thrift.Type.STRING, 3);
      output.writeString(this.displayName);
      output.writeFieldEnd();
    }
    if (this.enableSorting !== null && this.enableSorting !== undefined) {
      output.writeFieldBegin('enableSorting', Thrift.Type.BOOL, 4);
      output.writeBool(this.enableSorting);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 5);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.width !== null && this.width !== undefined) {
      output.writeFieldBegin('width', Thrift.Type.STRING, 6);
      output.writeString(this.width);
      output.writeFieldEnd();
    }
    if (this.color !== null && this.color !== undefined) {
      output.writeFieldBegin('color', Thrift.Type.STRING, 7);
      output.writeString(this.color);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CustomFilterItem = class {
  constructor(args) {
    this.id = null;
    this.field = null;
    this.fType = null;
    this.condition = null;
    this.value = null;
    this.useObject = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.field !== undefined && args.field !== null) {
        this.field = args.field;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.condition !== undefined && args.condition !== null) {
        this.condition = args.condition;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.useObject !== undefined && args.useObject !== null) {
        this.useObject = args.useObject;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.field = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.condition = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.useObject = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CustomFilterItem');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.field !== null && this.field !== undefined) {
      output.writeFieldBegin('field', Thrift.Type.STRING, 2);
      output.writeString(this.field);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 3);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.condition !== null && this.condition !== undefined) {
      output.writeFieldBegin('condition', Thrift.Type.I32, 4);
      output.writeI32(this.condition);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 5);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.useObject !== null && this.useObject !== undefined) {
      output.writeFieldBegin('useObject', Thrift.Type.BOOL, 6);
      output.writeBool(this.useObject);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocFilter = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.value = null;
    this.key = null;
    this.filters = null;
    this.fields = null;
    this.positionMobile = null;
    this.forMobile = null;
    this.positionRegistry = null;
    this.forRegistry = null;
    this.positionDocument = null;
    this.forDocument = null;
    this.fixed = null;
    this.visible = null;
    this.sortingFieldInRegistry = null;
    this.sortingDirection = null;
    this.fDescription = null;
    this.regId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.filters !== undefined && args.filters !== null) {
        this.filters = Thrift.copyList(args.filters, [CustomFilterItem]);
      }
      if (args.fields !== undefined && args.fields !== null) {
        this.fields = Thrift.copyMap(args.fields, [FilterField]);
      }
      if (args.positionMobile !== undefined && args.positionMobile !== null) {
        this.positionMobile = args.positionMobile;
      }
      if (args.forMobile !== undefined && args.forMobile !== null) {
        this.forMobile = args.forMobile;
      }
      if (args.positionRegistry !== undefined && args.positionRegistry !== null) {
        this.positionRegistry = args.positionRegistry;
      }
      if (args.forRegistry !== undefined && args.forRegistry !== null) {
        this.forRegistry = args.forRegistry;
      }
      if (args.positionDocument !== undefined && args.positionDocument !== null) {
        this.positionDocument = args.positionDocument;
      }
      if (args.forDocument !== undefined && args.forDocument !== null) {
        this.forDocument = args.forDocument;
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.sortingFieldInRegistry !== undefined && args.sortingFieldInRegistry !== null) {
        this.sortingFieldInRegistry = args.sortingFieldInRegistry;
      }
      if (args.sortingDirection !== undefined && args.sortingDirection !== null) {
        this.sortingDirection = args.sortingDirection;
      }
      if (args.fDescription !== undefined && args.fDescription !== null) {
        this.fDescription = args.fDescription;
      }
      if (args.regId !== undefined && args.regId !== null) {
        this.regId = args.regId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.filters = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new CustomFilterItem();
            elem3.read(input);
            this.filters.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.MAP) {
          this.fields = {};
          const _rtmp35 = input.readMapBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            if (_i6 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key7 = null;
            let val8 = null;
            key7 = input.readI32().value;
            val8 = new FilterField();
            val8.read(input);
            this.fields[key7] = val8;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.positionMobile = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forMobile = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.positionRegistry = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.forRegistry = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.positionDocument = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.forDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.sortingFieldInRegistry = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRING) {
          this.sortingDirection = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.fDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.regId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocFilter');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 4);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.filters !== null && this.filters !== undefined) {
      output.writeFieldBegin('filters', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.filters.length);
      for (let iter9 in this.filters) {
        if (this.filters.hasOwnProperty(iter9)) {
          iter9 = this.filters[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.fields !== null && this.fields !== undefined) {
      output.writeFieldBegin('fields', Thrift.Type.MAP, 6);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.fields));
      for (let kiter10 in this.fields) {
        if (this.fields.hasOwnProperty(kiter10)) {
          let viter11 = this.fields[kiter10];
          output.writeI32(kiter10);
          viter11.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.positionMobile !== null && this.positionMobile !== undefined) {
      output.writeFieldBegin('positionMobile', Thrift.Type.I32, 7);
      output.writeI32(this.positionMobile);
      output.writeFieldEnd();
    }
    if (this.forMobile !== null && this.forMobile !== undefined) {
      output.writeFieldBegin('forMobile', Thrift.Type.BOOL, 8);
      output.writeBool(this.forMobile);
      output.writeFieldEnd();
    }
    if (this.positionRegistry !== null && this.positionRegistry !== undefined) {
      output.writeFieldBegin('positionRegistry', Thrift.Type.I32, 9);
      output.writeI32(this.positionRegistry);
      output.writeFieldEnd();
    }
    if (this.forRegistry !== null && this.forRegistry !== undefined) {
      output.writeFieldBegin('forRegistry', Thrift.Type.BOOL, 10);
      output.writeBool(this.forRegistry);
      output.writeFieldEnd();
    }
    if (this.positionDocument !== null && this.positionDocument !== undefined) {
      output.writeFieldBegin('positionDocument', Thrift.Type.I32, 11);
      output.writeI32(this.positionDocument);
      output.writeFieldEnd();
    }
    if (this.forDocument !== null && this.forDocument !== undefined) {
      output.writeFieldBegin('forDocument', Thrift.Type.BOOL, 12);
      output.writeBool(this.forDocument);
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 13);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 14);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.sortingFieldInRegistry !== null && this.sortingFieldInRegistry !== undefined) {
      output.writeFieldBegin('sortingFieldInRegistry', Thrift.Type.STRING, 15);
      output.writeString(this.sortingFieldInRegistry);
      output.writeFieldEnd();
    }
    if (this.sortingDirection !== null && this.sortingDirection !== undefined) {
      output.writeFieldBegin('sortingDirection', Thrift.Type.STRING, 16);
      output.writeString(this.sortingDirection);
      output.writeFieldEnd();
    }
    if (this.fDescription !== null && this.fDescription !== undefined) {
      output.writeFieldBegin('fDescription', Thrift.Type.STRING, 17);
      output.writeString(this.fDescription);
      output.writeFieldEnd();
    }
    if (this.regId !== null && this.regId !== undefined) {
      output.writeFieldBegin('regId', Thrift.Type.STRING, 18);
      output.writeString(this.regId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserPreferencesFilter = class {
  constructor(args) {
    this.filterId = null;
    this.columnSettings = null;
    this.visible = null;
    this.sortingField = null;
    this.sortingDirection = null;
    if (args) {
      if (args.filterId !== undefined && args.filterId !== null) {
        this.filterId = args.filterId;
      }
      if (args.columnSettings !== undefined && args.columnSettings !== null) {
        this.columnSettings = Thrift.copyList(args.columnSettings, [null]);
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.sortingField !== undefined && args.sortingField !== null) {
        this.sortingField = args.sortingField;
      }
      if (args.sortingDirection !== undefined && args.sortingDirection !== null) {
        this.sortingDirection = args.sortingDirection;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.filterId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.columnSettings = [];
          const _rtmp313 = input.readListBegin();
          const _size12 = _rtmp313.size || 0;
          for (let _i14 = 0; _i14 < _size12; ++_i14) {
            let elem15 = null;
            elem15 = new UserPreferencesFilterColumn();
            elem15.read(input);
            this.columnSettings.push(elem15);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.sortingField = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.sortingDirection = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserPreferencesFilter');
    if (this.filterId !== null && this.filterId !== undefined) {
      output.writeFieldBegin('filterId', Thrift.Type.STRING, 1);
      output.writeString(this.filterId);
      output.writeFieldEnd();
    }
    if (this.columnSettings !== null && this.columnSettings !== undefined) {
      output.writeFieldBegin('columnSettings', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.columnSettings.length);
      for (let iter16 in this.columnSettings) {
        if (this.columnSettings.hasOwnProperty(iter16)) {
          iter16 = this.columnSettings[iter16];
          iter16.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 3);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.sortingField !== null && this.sortingField !== undefined) {
      output.writeFieldBegin('sortingField', Thrift.Type.STRING, 4);
      output.writeString(this.sortingField);
      output.writeFieldEnd();
    }
    if (this.sortingDirection !== null && this.sortingDirection !== undefined) {
      output.writeFieldBegin('sortingDirection', Thrift.Type.STRING, 5);
      output.writeString(this.sortingDirection);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserPreferencesFilterColumn = class {
  constructor(args) {
    this.columnId = null;
    this.width = null;
    this.visible = null;
    this.order = null;
    if (args) {
      if (args.columnId !== undefined && args.columnId !== null) {
        this.columnId = args.columnId;
      }
      if (args.width !== undefined && args.width !== null) {
        this.width = args.width;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.columnId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.width = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserPreferencesFilterColumn');
    if (this.columnId !== null && this.columnId !== undefined) {
      output.writeFieldBegin('columnId', Thrift.Type.STRING, 1);
      output.writeString(this.columnId);
      output.writeFieldEnd();
    }
    if (this.width !== null && this.width !== undefined) {
      output.writeFieldBegin('width', Thrift.Type.STRING, 2);
      output.writeString(this.width);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 3);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 4);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


HistoryKey = {
  'COMMENT_ADDED' : 0,
  'COMMENT_UPDATED' : 1,
  'COMMENT_DELETED' : 2,
  'DOCUMENT_CREATED' : 3,
  'DOCUMENT_ASSIGNED' : 4,
  'DOCUMENT_ASSIGNED_FOR_TECHNICAL_USER' : 5,
  'DOCUMENT_REASSIGNED' : 6,
  'DOCUMENT_REASSIGNED_WITH_CONTROL' : 7,
  'DOCUMENT_REASSIGNED_PERIODICAL' : 8,
  'PERIODICAL_STAGE_NEXT_RUN_AT' : 9,
  'PERIODICAL_STAGE_DISABLE_BY_END' : 10,
  'PERIODICAL_STAGE_DISABLE_NOT_ENOUGH_TIME' : 11,
  'PERIODICAL_CARD_NEXT_RUN_AT' : 12,
  'PERIODICAL_CARD_DISABLE_BY_END' : 13,
  'DOCUMENT_SHARED' : 14,
  'DOCUMENT_MOVED_TO_NEXT_STAGE' : 15,
  'DOCUMENT_DECISION_APPROVED' : 16,
  'DOCUMENT_ARCHIVED' : 17,
  'DOCUMENT_CLOSED' : 18,
  'DOCUMENT_NUMBER_GENERATED' : 19,
  'DOCUMENT_DELETED' : 20,
  'DOCUMENT_UPDATED' : 21,
  'DOCUMENT_REVOKE' : 22,
  'DOCUMENT_REVOKE_FROM_GROUP' : 23,
  'DOCUMENT_NOT_FOUND' : 24,
  'DOCUMENT_RELATIONS_CREATED' : 25,
  'DOCUMENT_RELATIONS_REMOVED' : 26,
  'DOCUMENT_SUB_STATUS_CHANGED' : 27,
  'ADD_RESPONSIBLE_TO_DOCUMENT' : 28,
  'REMOVE_RESPONSIBLE_FROM_DOCUMENT' : 29,
  'ATTACHMENT_CREATED' : 30,
  'ATTACHMENT_CREATED_FROM_TEMPLATE' : 31,
  'ATTACHMENT_CREATED_FROM_ATTACHMENT' : 32,
  'ATTACHMENT_DRAFT_CREATED' : 33,
  'ATTACHMENT_DRAFT_UPDATED' : 34,
  'ATTACHMENT_DRAFT_WAIT_PUBLISH' : 35,
  'ATTACHMENT_FINISH_DRAFT' : 36,
  'ATTACHMENT_SAVE_ERROR' : 37,
  'ATTACHMENT_REMOVED' : 38,
  'ATTACHMENT_CONVERT_ERROR' : 39,
  'RESOLUTION_CHANGED' : 40,
  'DOCUMENT_RESOLUTION_CHANGED_BY_TECHNICAL_USER' : 41,
  'MAKE_DECISION_RESOLUTION' : 42,
  'EXTERNAL_MODULE_CHANGED' : 43,
  'EXTERNAL_MODULE_NOT_AVAILABLE' : 44,
  'INVALID_DOCUMENT_PATTERN' : 45,
  'INVALID_TRANSITION_CONDITION' : 46,
  'NEXT_STAGE_NOT_FOUND' : 47,
  'ERROR_MOVING_DOCUMENT_TO_NEXT_STAGE' : 48,
  'ERROR_PERIODICAL_STAGE' : 49,
  'ERROR_TO_ARCHIVE' : 50,
  'ERROR_INTERNAL_STAGE' : 51,
  'SYNCHRONIZATION_ERROR' : 52,
  'CHAT_SYNCHRONIZATION_ERROR' : 53,
  'SIGNATURE_ERROR' : 54,
  'DOCUMENT_MOVED_TO_ANY_STAGE' : 55,
  'REMOVED_ALL_OLD_VERSION_ATTACHMENTS' : 56,
  'CHANGE_EDIT_MODE_FOR_ATTACHMENT' : 57,
  'DOCUMENT_DEADLINE_DATE_INCREASE' : 58,
  'EXECUTION_CARD_DEADLINE_DATE_INCREASE' : 59,
  'EXECUTION_CARD_REVOKE_DECISION' : 60,
  'EXECUTION_CARD_MARK_AS_REMOVED' : 61,
  'LOGIN_AS_OTHER_USER' : 62,
  'CREATE_CLIENT_DELEGATE' : 63,
  'MODIFY_CLIENT_DELEGATE' : 64,
  'REMOVE_CLIENT_DELEGATE' : 65,
  'MAIL_PATTERN_NOT_FOUND' : 66,
  'MAIL_PATTERN_NOT_VALID' : 67,
  'MAIL_DOCUMENT_NOT_FOUND' : 68,
  'MAIL_DOCUMENT_NOT_CREATE' : 69,
  'MAIL_LIMIT_FILE_SIZE' : 70,
  'MAIL_OTHER_ERROR' : 71,
  'REQUEST_RESET_PASSWORD' : 72,
  'EMPLOYEES_IMPORT_ERROR' : 73,
  'DEPARTMENT_IMPORT_ERROR' : 74,
  'REMOVE_USER_PUBLIC_KEY' : 75,
  'REMOVE_USER_PRIVATE_KEY' : 76,
  'CREATE_OR_UPDATE_FILE_STORAGE' : 77,
  'REMOVE_FILE_STORAGES' : 78,
  'REGISTER_EXTERNAL_MODULE' : 79,
  'UNREGISTER_EXTERNAL_MODULE' : 80,
  'REFRESH_EXTERNAL_MODULE' : 81,
  'REMOVE_EXTERNAL_MODULE' : 82,
  'CREATE_OR_UPDATE_SECURITY_CLASSIFICATION' : 83,
  'REMOVE_SECURITY_CLASSIFICATION' : 84,
  'REMOVE_SECURITY_CLASSIFICATION_FROM_DOC' : 85,
  'REMOVE_SECURITY_CLASSIFICATIONS_FROM_USER' : 86,
  'REMOVE_SECURITY_CLASSIFICATIONS_FROM_GROUP' : 87,
  'ADD_SECURITY_CLASSIFICATIONS_TO_USER' : 88,
  'ADD_SECURITY_CLASSIFICATIONS_TO_GROUP' : 89,
  'ADD_SECURITY_CLASSIFICATIONS_TO_DOC' : 90,
  'CREATE_OR_UPDATE_REPORT' : 91,
  'REMOVE_REPORT_TEMPLATE' : 92,
  'ADD_REPORT_TO_PATTERN' : 93,
  'REMOVE_REPORT_FROM_PATTERN' : 94,
  'CREATE_OR_UPDATE_CUSTOM_FIELD' : 95,
  'REMOVE_CUSTOM_FIELD' : 96,
  'CREATE_OR_UPDATE_CUSTOM_DOC_FILTER' : 97,
  'REMOVE_CUSTOM_DOC_FILTER' : 98,
  'EXPORT_CUSTOM_DOC_FILTERS' : 99,
  'IMPORT_CUSTOM_DOC_FILTERS_WITH_CLEANSING' : 100,
  'IMPORT_CUSTOM_DOC_FILTERS_WITHOUT_CLEANSING' : 101,
  'CHANGE_ENCRYPT_KEY' : 102,
  'REMOVE_ENCRYPT_KEY' : 103,
  'USER_DECRYPT_DOCUMENT' : 104,
  'USER_REQUEST_ACCESS_DOCUMENT' : 105,
  'CLOSE_SESSION' : 106,
  'UPDATE_FILLED_DOCUMENT_PATTERN_STAGE' : 107,
  'UPDATE_FILLED_DOCUMENT_PATTERN_STAGE_LINK' : 108,
  'REVOKE_CHILD_CARDS' : 109,
  'REMOVE_CHILD_CARDS' : 110,
  'CONFIRM_USER_PUBLIC_KEY' : 111,
  'SET_USER_PUBLIC_KEY' : 112,
  'LOAD_USER_PRIVATE_KEY' : 113,
  'EMPLOYEES_IMPORT_INFO' : 114,
  'CLIENT_HAS_NO_EMAIL_TO_SEND' : 115,
  'USER_LOGIN' : 116,
  'USER_LOGOUT' : 117,
  'UPDATE_HB' : 118,
  'HB_CREATE_OR_UPDATE' : 119,
  'HB_DELETE' : 120,
  'HB_ROW_CREATE_OR_UPDATE' : 121,
  'HB_ROW_DELETE' : 122,
  'HB_ADMIN_USERS' : 123,
  'HB_ADMIN_GROUPS' : 124,
  'CREATE_OR_UPDATE_PATTERN_ATTACHMENT' : 125,
  'REMOVE_PATTERN_ATTACHMENT' : 126,
  'COPY_GROUPS' : 127,
  'COPY_ROLES' : 128,
  'COPY_SC' : 129,
  'COPY_MEETINGS' : 130,
  'COPY_DOCUMENTS' : 131,
  'COPY_ACCOUNTS' : 132,
  'COPY_PERSONAL_ACCESS_REQUEST_TO' : 133,
  'COPY_PERSONAL_ACCESS_REQUEST_FROM' : 134,
  'COPY_PERSONAL_ACCESS_REQUEST' : 135,
  'COPY_PERSONAL_ACCESS_DONE' : 136,
  'STAGE_CHANGE_USER' : 137,
  'SKIP_DELETED_USER' : 138,
  'SKIP_DELETED_GROUP' : 139,
  'LINK_CHANGE_USER' : 140,
  'FILLED_CHANGE_USER' : 141,
  'PATTERN_USERGROUP_CHANGE_USER' : 142,
  'CREATE_OR_UPDATE_DOCUMENT_PATTERN' : 143,
  'DELETE_DOCUMENT_PATTERN' : 144,
  'CREATE_OR_UPDATE_STAGE_AND_LINKS' : 145,
  'CHANGE_PROCESS_ROLES' : 146,
  'CHANGE_PATTERN_USER_GROUP' : 147,
  'CHANGE_PROCESS_VARIABLES' : 148,
  'CHANGE_CONTENT_ITEMS' : 149,
  'ADD_EXECUTORS_TO_STAGE' : 150,
  'REMOVE_USERS_EXECUTORS_FROM_STAGE' : 151,
  'REMOVE_GROUPS_EXECUTORS_FROM_STAGE' : 152,
  'CHANGE_PATTERN_CONTENT_TAB' : 153,
  'REMOVE_PATTERN_CONTENT_TAB' : 154,
  'DOCUMENT_SHARED_TO_USERS' : 155,
  'DOCUMENT_SHARED_TO_GROUPS' : 156,
  'DOCUMENT_ALREADY_SHARED_TO_USER' : 157,
  'DOCUMENT_ALREADY_SHARED_TO_GROUP' : 158,
  'REGISTRY_REMOVE' : 159,
  'REGISTRY_ACCOUNT_ADD' : 160,
  'REGISTRY_ACCOUNT_REMOVE' : 161,
  'REGISTRY_USERS_ADD' : 162,
  'REGISTRY_USERS_REMOVE' : 163,
  'REGISTRY_GROUPS_ADD' : 164,
  'REGISTRY_GROUPS_REMOVE' : 165,
  'REMOVE_USERS_FROM_GROUP' : 166,
  'ADD_USER_GROUP_TO_STAGE' : 167,
  'ADD_USERS_TO_GROUP' : 168,
  'DOCUMENT_REGISTRATION_INFO_CHANGE' : 169,
  'SKIP_DOC_NUMBER' : 170,
  'PATTERN_ATTACHMENT_SAVE_ERROR' : 171,
  'CONFIRM_MEETING' : 172,
  'ADD_ADDITIONAL_CONFIRMER' : 173,
  'REMOVE_ALL_NOTIFICATION_CONFIG' : 174,
  'CHANGE_NOTIFICATION_CONFIG' : 175,
  'ERROR_GENERATE_REPORT' : 176,
  'ERROR_GET_EXTERNAL_HANDBOOK' : 177,
  'USER_NOT_FOUND_IN_BPM' : 178,
  'CHANGE_MOVE_LINK_SCRIPT' : 179,
  'COUNT_SCRIPTS_RULES_DONE' : 180,
  'CANT_CREATE_CHILD_DOC' : 181,
  'CANT_CREATE_CHILD_DOC_BY_PROCESS_ROLE' : 182,
  'UPDATE_USER_INFO' : 183,
  'USER_DONT_EXIST_IN_PROLE' : 184,
  'GROUP_DONT_EXIST_IN_PROLE' : 185,
  'INCORRECT_SCRIPT' : 186,
  'REMIND_EXECUTOR' : 187,
  'EXT_EXCLUDE_DOCUMENT_ERROR' : 188,
  'CHANGE_DOCUMENT_TYPE' : 189,
  'UPDATE_USER_ACCOUNT' : 190,
  'UPDATE_USER_PREFERENCES' : 191,
  'UPDATE_USER_FAVORITES' : 192,
  'UPDATE_USER_ROLE' : 193,
  'UPDATE_USER_PASSWORD' : 194,
  'UPDATE_USER_GROUP' : 195,
  'UPDATE_USER_DELEGATE' : 196,
  'UPDATE_USER_SC' : 197,
  'ERROR_GENERATING_DOCUMENT_NUMBER' : 198,
  'CHANGE_CONTENT_HOLDERS' : 199,
  'DOCUMENT_NUMBER_REQUIRED' : 200,
  'DOWNLOAD_PDF_UNSECURED' : 201,
  'DOCUMENT_ASSIGNED_TO_GROUP' : 202,
  'DOCUMENT_SHARED_FROM_LINK' : 203,
  'CHILD_UPDATE_USER_INFO' : 204
};
ChangeLogObjectType = {
  'PATTERN' : 0,
  'PATTERN_USER' : 1,
  'STAGE' : 2,
  'LINK' : 3,
  'CONTENT' : 4,
  'CONTENT_HOLDER' : 5,
  'CONTENT_HOLDER_LINK' : 6,
  'CONTENT_TAB' : 7,
  'PROCESS_ROLE' : 8,
  'PROCESS_VARIABLE' : 9,
  'PATTERN_ATTACHMENT' : 10,
  'PATTERN_REPORT' : 11,
  'CLIENT' : 12
};
ChangeLogActionType = {
  'ADD' : 0,
  'CHANGE' : 1,
  'REMOVE' : 2
};
ChangeLogDetail = class {
  constructor(args) {
    this.key = null;
    this.oldValue = null;
    this.newValue = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.oldValue !== undefined && args.oldValue !== null) {
        this.oldValue = args.oldValue;
      }
      if (args.newValue !== undefined && args.newValue !== null) {
        this.newValue = args.newValue;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oldValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.newValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChangeLogDetail');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.oldValue !== null && this.oldValue !== undefined) {
      output.writeFieldBegin('oldValue', Thrift.Type.STRING, 2);
      output.writeString(this.oldValue);
      output.writeFieldEnd();
    }
    if (this.newValue !== null && this.newValue !== undefined) {
      output.writeFieldBegin('newValue', Thrift.Type.STRING, 3);
      output.writeString(this.newValue);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ChangeLog = class {
  constructor(args) {
    this.identifier = null;
    this.logName = null;
    this.objType = null;
    this.actionType = null;
    this.logDetails = null;
    if (args) {
      if (args.identifier !== undefined && args.identifier !== null) {
        this.identifier = args.identifier;
      }
      if (args.logName !== undefined && args.logName !== null) {
        this.logName = args.logName;
      }
      if (args.objType !== undefined && args.objType !== null) {
        this.objType = args.objType;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.logDetails !== undefined && args.logDetails !== null) {
        this.logDetails = Thrift.copyList(args.logDetails, [ChangeLogDetail]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.identifier = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.logName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.objType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.logDetails = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ChangeLogDetail();
            elem3.read(input);
            this.logDetails.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ChangeLog');
    if (this.identifier !== null && this.identifier !== undefined) {
      output.writeFieldBegin('identifier', Thrift.Type.STRING, 1);
      output.writeString(this.identifier);
      output.writeFieldEnd();
    }
    if (this.logName !== null && this.logName !== undefined) {
      output.writeFieldBegin('logName', Thrift.Type.STRING, 2);
      output.writeString(this.logName);
      output.writeFieldEnd();
    }
    if (this.objType !== null && this.objType !== undefined) {
      output.writeFieldBegin('objType', Thrift.Type.I32, 3);
      output.writeI32(this.objType);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 4);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.logDetails !== null && this.logDetails !== undefined) {
      output.writeFieldBegin('logDetails', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.logDetails.length);
      for (let iter4 in this.logDetails) {
        if (this.logDetails.hasOwnProperty(iter4)) {
          iter4 = this.logDetails[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


NotificationTransportDestinationType = {
  'NONE' : 0,
  'MOBILE' : 1,
  'WEB' : 2
};
AttributeParamType = {
  'DOCUMENT' : 0,
  'DOC_PAT_STAGE' : 1,
  'DOCUMENT_EXECUTION' : 2,
  'MEETING' : 3,
  'MEETING_PARTICIPANT' : 4,
  'ATTACHMENT' : 5,
  'CLIENT' : 6,
  'STRING' : 7,
  'LONG' : 8,
  'NEWS' : 9,
  'CERTIFICATE' : 10
};
NotificationStatus = {
  'CREATED' : 0,
  'IN_WORK' : 1,
  'SUCCESS' : 2,
  'FAIL' : 3,
  'IN_BLACKLIST' : 4,
  'IGNORE' : 5
};
RecipientTypeEnum = {
  'MEETING_AUTHOR' : 0,
  'MEETING_PARTICIPANT' : 1,
  'MEETING_SECRETARY' : 2,
  'DOCUMENT_AUTHOR' : 3,
  'DOCUMENT_PARTICIPANT' : 4,
  'DOCUMENT_RESPONSIBLE' : 5,
  'DOCUMENT_ASSIGNMENT' : 6,
  'PASSWORD_RECIPIENT' : 7,
  'USER_DELEGATE' : 8,
  'USER_IN_WHITE_LIST' : 9,
  'UNSOLVED' : 10,
  'USER_BY_MAIN_ACCOUNT' : 11,
  'CERTIFICATE_RECIPIENT' : 12
};
NotificationTransportType = class {
  constructor(args) {
    this.key = null;
    this.caption = null;
    this.destination = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.caption !== undefined && args.caption !== null) {
        this.caption = args.caption;
      }
      if (args.destination !== undefined && args.destination !== null) {
        this.destination = Thrift.copyList(args.destination, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.caption = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.destination = [];
          const _rtmp31 = input.readSetBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readI32().value;
            this.destination.push(elem3);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationTransportType');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.caption !== null && this.caption !== undefined) {
      output.writeFieldBegin('caption', Thrift.Type.STRING, 2);
      output.writeString(this.caption);
      output.writeFieldEnd();
    }
    if (this.destination !== null && this.destination !== undefined) {
      output.writeFieldBegin('destination', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.I32, this.destination.length);
      for (let iter4 in this.destination) {
        if (this.destination.hasOwnProperty(iter4)) {
          iter4 = this.destination[iter4];
          output.writeI32(iter4);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationAttribute = class {
  constructor(args) {
    this.id = null;
    this.notificationId = null;
    this.key = null;
    this.value = null;
    this.type = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.notificationId !== undefined && args.notificationId !== null) {
        this.notificationId = args.notificationId;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.notificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationAttribute');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.notificationId !== null && this.notificationId !== undefined) {
      output.writeFieldBegin('notificationId', Thrift.Type.STRING, 2);
      output.writeString(this.notificationId);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 3);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 4);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 5);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationRecipient = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.recipient = null;
    this.originalClient = null;
    this.processedDate = null;
    this.status = null;
    this.readed = null;
    this.type = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.recipient !== undefined && args.recipient !== null) {
        this.recipient = new UserOrGroup(args.recipient);
      }
      if (args.originalClient !== undefined && args.originalClient !== null) {
        this.originalClient = new UserOrGroup(args.originalClient);
      }
      if (args.processedDate !== undefined && args.processedDate !== null) {
        this.processedDate = args.processedDate;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.readed !== undefined && args.readed !== null) {
        this.readed = args.readed;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.recipient = new UserOrGroup();
          this.recipient.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalClient = new UserOrGroup();
          this.originalClient.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.processedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.readed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationRecipient');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.recipient !== null && this.recipient !== undefined) {
      output.writeFieldBegin('recipient', Thrift.Type.STRUCT, 3);
      this.recipient.write(output);
      output.writeFieldEnd();
    }
    if (this.originalClient !== null && this.originalClient !== undefined) {
      output.writeFieldBegin('originalClient', Thrift.Type.STRUCT, 5);
      this.originalClient.write(output);
      output.writeFieldEnd();
    }
    if (this.processedDate !== null && this.processedDate !== undefined) {
      output.writeFieldBegin('processedDate', Thrift.Type.I64, 6);
      output.writeI64(this.processedDate);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 7);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.readed !== null && this.readed !== undefined) {
      output.writeFieldBegin('readed', Thrift.Type.BOOL, 8);
      output.writeBool(this.readed);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 9);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationQueue = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.type = null;
    this.attributes = null;
    this.recipients = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.attributes !== undefined && args.attributes !== null) {
        this.attributes = Thrift.copyList(args.attributes, [NotificationAttribute]);
      }
      if (args.recipients !== undefined && args.recipients !== null) {
        this.recipients = Thrift.copyList(args.recipients, [NotificationRecipient]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.attributes = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new NotificationAttribute();
            elem8.read(input);
            this.attributes.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.recipients = [];
          const _rtmp310 = input.readListBegin();
          const _size9 = _rtmp310.size || 0;
          for (let _i11 = 0; _i11 < _size9; ++_i11) {
            let elem12 = null;
            elem12 = new NotificationRecipient();
            elem12.read(input);
            this.recipients.push(elem12);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationQueue');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.attributes !== null && this.attributes !== undefined) {
      output.writeFieldBegin('attributes', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.attributes.length);
      for (let iter13 in this.attributes) {
        if (this.attributes.hasOwnProperty(iter13)) {
          iter13 = this.attributes[iter13];
          iter13.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.recipients !== null && this.recipients !== undefined) {
      output.writeFieldBegin('recipients', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.recipients.length);
      for (let iter14 in this.recipients) {
        if (this.recipients.hasOwnProperty(iter14)) {
          iter14 = this.recipients[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationConfig = class {
  constructor(args) {
    this.key = null;
    this.caption = null;
    this.allowedForUser = null;
    this.selectedForUser = null;
    this.selectedForDelegate = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.caption !== undefined && args.caption !== null) {
        this.caption = args.caption;
      }
      if (args.allowedForUser !== undefined && args.allowedForUser !== null) {
        this.allowedForUser = Thrift.copyMap(args.allowedForUser, [null]);
      }
      if (args.selectedForUser !== undefined && args.selectedForUser !== null) {
        this.selectedForUser = Thrift.copyMap(args.selectedForUser, [null]);
      }
      if (args.selectedForDelegate !== undefined && args.selectedForDelegate !== null) {
        this.selectedForDelegate = Thrift.copyMap(args.selectedForDelegate, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.caption = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.allowedForUser = {};
          const _rtmp316 = input.readMapBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            if (_i17 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key18 = null;
            let val19 = null;
            key18 = input.readString().value;
            val19 = input.readBool().value;
            this.allowedForUser[key18] = val19;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.selectedForUser = {};
          const _rtmp321 = input.readMapBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            if (_i22 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key23 = null;
            let val24 = null;
            key23 = input.readString().value;
            val24 = input.readBool().value;
            this.selectedForUser[key23] = val24;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.MAP) {
          this.selectedForDelegate = {};
          const _rtmp326 = input.readMapBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            if (_i27 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key28 = null;
            let val29 = null;
            key28 = input.readString().value;
            val29 = input.readBool().value;
            this.selectedForDelegate[key28] = val29;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationConfig');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.caption !== null && this.caption !== undefined) {
      output.writeFieldBegin('caption', Thrift.Type.STRING, 2);
      output.writeString(this.caption);
      output.writeFieldEnd();
    }
    if (this.allowedForUser !== null && this.allowedForUser !== undefined) {
      output.writeFieldBegin('allowedForUser', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.allowedForUser));
      for (let kiter30 in this.allowedForUser) {
        if (this.allowedForUser.hasOwnProperty(kiter30)) {
          let viter31 = this.allowedForUser[kiter30];
          output.writeString(kiter30);
          output.writeBool(viter31);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.selectedForUser !== null && this.selectedForUser !== undefined) {
      output.writeFieldBegin('selectedForUser', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.selectedForUser));
      for (let kiter32 in this.selectedForUser) {
        if (this.selectedForUser.hasOwnProperty(kiter32)) {
          let viter33 = this.selectedForUser[kiter32];
          output.writeString(kiter32);
          output.writeBool(viter33);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.selectedForDelegate !== null && this.selectedForDelegate !== undefined) {
      output.writeFieldBegin('selectedForDelegate', Thrift.Type.MAP, 5);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.selectedForDelegate));
      for (let kiter34 in this.selectedForDelegate) {
        if (this.selectedForDelegate.hasOwnProperty(kiter34)) {
          let viter35 = this.selectedForDelegate[kiter34];
          output.writeString(kiter34);
          output.writeBool(viter35);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ReportTemplateLink = class {
  constructor(args) {
    this.id = null;
    this.reportId = null;
    this.patternId = null;
    this.userOrGroup = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.reportId !== undefined && args.reportId !== null) {
        this.reportId = args.reportId;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.reportId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportTemplateLink');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.reportId !== null && this.reportId !== undefined) {
      output.writeFieldBegin('reportId', Thrift.Type.STRING, 2);
      output.writeString(this.reportId);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 3);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 4);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportFilledParam = class {
  constructor(args) {
    this.id = null;
    this.paramType = null;
    this.value = null;
    this.key = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.paramType !== undefined && args.paramType !== null) {
        this.paramType = args.paramType;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.paramType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportFilledParam');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.paramType !== null && this.paramType !== undefined) {
      output.writeFieldBegin('paramType', Thrift.Type.I32, 2);
      output.writeI32(this.paramType);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 4);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ScriptDictionaryType = {
  'DRL' : 0
};
ScriptDictionary = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.oDescription = null;
    this.script = null;
    this.valid = null;
    this.type = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = new CompositeId(args.id);
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.oDescription !== undefined && args.oDescription !== null) {
        this.oDescription = args.oDescription;
      }
      if (args.script !== undefined && args.script !== null) {
        this.script = args.script;
      }
      if (args.valid !== undefined && args.valid !== null) {
        this.valid = args.valid;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.id = new CompositeId();
          this.id.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.script = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.valid = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionary');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRUCT, 1);
      this.id.write(output);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.oDescription !== null && this.oDescription !== undefined) {
      output.writeFieldBegin('oDescription', Thrift.Type.STRING, 3);
      output.writeString(this.oDescription);
      output.writeFieldEnd();
    }
    if (this.script !== null && this.script !== undefined) {
      output.writeFieldBegin('script', Thrift.Type.STRING, 4);
      output.writeString(this.script);
      output.writeFieldEnd();
    }
    if (this.valid !== null && this.valid !== undefined) {
      output.writeFieldBegin('valid', Thrift.Type.BOOL, 5);
      output.writeBool(this.valid);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 6);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ChiefLevel = {
  'DIRECT_CHIEF' : 0,
  'TOP_CHIEF' : 1,
  'ALL_HIERARCHY' : 2
};
RoleScHelper = class {
  constructor(args) {
    this.id = null;
    this.himself = null;
    this.usersOrGrous = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.himself !== undefined && args.himself !== null) {
        this.himself = args.himself;
      }
      if (args.usersOrGrous !== undefined && args.usersOrGrous !== null) {
        this.usersOrGrous = Thrift.copyList(args.usersOrGrous, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.himself = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGrous = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new UserOrGroup();
            elem3.read(input);
            this.usersOrGrous.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('RoleScHelper');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.himself !== null && this.himself !== undefined) {
      output.writeFieldBegin('himself', Thrift.Type.BOOL, 2);
      output.writeBool(this.himself);
      output.writeFieldEnd();
    }
    if (this.usersOrGrous !== null && this.usersOrGrous !== undefined) {
      output.writeFieldBegin('usersOrGrous', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGrous.length);
      for (let iter4 in this.usersOrGrous) {
        if (this.usersOrGrous.hasOwnProperty(iter4)) {
          iter4 = this.usersOrGrous[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserKeyData = class {
  constructor(args) {
    this.id = null;
    this.user = null;
    this.admin = null;
    this.createDate = null;
    this.confirmDate = null;
    this.keyState = null;
    this.certificateInfo = null;
    this.deleteDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.admin !== undefined && args.admin !== null) {
        this.admin = new UserOrGroup(args.admin);
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.confirmDate !== undefined && args.confirmDate !== null) {
        this.confirmDate = args.confirmDate;
      }
      if (args.keyState !== undefined && args.keyState !== null) {
        this.keyState = args.keyState;
      }
      if (args.certificateInfo !== undefined && args.certificateInfo !== null) {
        this.certificateInfo = new CertificateInfo(args.certificateInfo);
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.admin = new UserOrGroup();
          this.admin.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.confirmDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.keyState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.certificateInfo = new CertificateInfo();
          this.certificateInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserKeyData');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 2);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.admin !== null && this.admin !== undefined) {
      output.writeFieldBegin('admin', Thrift.Type.STRUCT, 3);
      this.admin.write(output);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 4);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.confirmDate !== null && this.confirmDate !== undefined) {
      output.writeFieldBegin('confirmDate', Thrift.Type.I64, 5);
      output.writeI64(this.confirmDate);
      output.writeFieldEnd();
    }
    if (this.keyState !== null && this.keyState !== undefined) {
      output.writeFieldBegin('keyState', Thrift.Type.I32, 6);
      output.writeI32(this.keyState);
      output.writeFieldEnd();
    }
    if (this.certificateInfo !== null && this.certificateInfo !== undefined) {
      output.writeFieldBegin('certificateInfo', Thrift.Type.STRUCT, 7);
      this.certificateInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ClientDelegateDetails = class {
  constructor(args) {
    this.id = null;
    this.dateStart = null;
    this.dateEnd = null;
    this.account = null;
    this.docPatternGroup = null;
    this.docPattern = null;
    this.actionTypes = null;
    this.documentDateFrom = null;
    this.documentDateTo = null;
    this.notNotifyOriginalUserByEmail = null;
    this.clientDelegateInfoId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.dateStart !== undefined && args.dateStart !== null) {
        this.dateStart = args.dateStart;
      }
      if (args.dateEnd !== undefined && args.dateEnd !== null) {
        this.dateEnd = args.dateEnd;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.docPatternGroup !== undefined && args.docPatternGroup !== null) {
        this.docPatternGroup = new DocumentPatternGroup(args.docPatternGroup);
      }
      if (args.docPattern !== undefined && args.docPattern !== null) {
        this.docPattern = new DocumentPattern(args.docPattern);
      }
      if (args.actionTypes !== undefined && args.actionTypes !== null) {
        this.actionTypes = Thrift.copyList(args.actionTypes, [null]);
      }
      if (args.documentDateFrom !== undefined && args.documentDateFrom !== null) {
        this.documentDateFrom = args.documentDateFrom;
      }
      if (args.documentDateTo !== undefined && args.documentDateTo !== null) {
        this.documentDateTo = args.documentDateTo;
      }
      if (args.notNotifyOriginalUserByEmail !== undefined && args.notNotifyOriginalUserByEmail !== null) {
        this.notNotifyOriginalUserByEmail = args.notNotifyOriginalUserByEmail;
      }
      if (args.clientDelegateInfoId !== undefined && args.clientDelegateInfoId !== null) {
        this.clientDelegateInfoId = args.clientDelegateInfoId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.dateStart = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.dateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.docPatternGroup = new DocumentPatternGroup();
          this.docPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.docPattern = new DocumentPattern();
          this.docPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.actionTypes = [];
          const _rtmp36 = input.readSetBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = input.readI32().value;
            this.actionTypes.push(elem8);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.documentDateFrom = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.documentDateTo = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.notNotifyOriginalUserByEmail = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.clientDelegateInfoId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ClientDelegateDetails');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.dateStart !== null && this.dateStart !== undefined) {
      output.writeFieldBegin('dateStart', Thrift.Type.I64, 2);
      output.writeI64(this.dateStart);
      output.writeFieldEnd();
    }
    if (this.dateEnd !== null && this.dateEnd !== undefined) {
      output.writeFieldBegin('dateEnd', Thrift.Type.I64, 3);
      output.writeI64(this.dateEnd);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 4);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.docPatternGroup !== null && this.docPatternGroup !== undefined) {
      output.writeFieldBegin('docPatternGroup', Thrift.Type.STRUCT, 5);
      this.docPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.docPattern !== null && this.docPattern !== undefined) {
      output.writeFieldBegin('docPattern', Thrift.Type.STRUCT, 6);
      this.docPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.actionTypes !== null && this.actionTypes !== undefined) {
      output.writeFieldBegin('actionTypes', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.I32, this.actionTypes.length);
      for (let iter9 in this.actionTypes) {
        if (this.actionTypes.hasOwnProperty(iter9)) {
          iter9 = this.actionTypes[iter9];
          output.writeI32(iter9);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.documentDateFrom !== null && this.documentDateFrom !== undefined) {
      output.writeFieldBegin('documentDateFrom', Thrift.Type.I64, 8);
      output.writeI64(this.documentDateFrom);
      output.writeFieldEnd();
    }
    if (this.documentDateTo !== null && this.documentDateTo !== undefined) {
      output.writeFieldBegin('documentDateTo', Thrift.Type.I64, 9);
      output.writeI64(this.documentDateTo);
      output.writeFieldEnd();
    }
    if (this.notNotifyOriginalUserByEmail !== null && this.notNotifyOriginalUserByEmail !== undefined) {
      output.writeFieldBegin('notNotifyOriginalUserByEmail', Thrift.Type.BOOL, 10);
      output.writeBool(this.notNotifyOriginalUserByEmail);
      output.writeFieldEnd();
    }
    if (this.clientDelegateInfoId !== null && this.clientDelegateInfoId !== undefined) {
      output.writeFieldBegin('clientDelegateInfoId', Thrift.Type.STRING, 11);
      output.writeString(this.clientDelegateInfoId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ClientDelegateInfo = class {
  constructor(args) {
    this.id = null;
    this.fromUserId = null;
    this.toUserId = null;
    this.actualDelegatesCount = null;
    this.futureDelegatesCount = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.fromUserId !== undefined && args.fromUserId !== null) {
        this.fromUserId = new UserOrGroup(args.fromUserId);
      }
      if (args.toUserId !== undefined && args.toUserId !== null) {
        this.toUserId = new UserOrGroup(args.toUserId);
      }
      if (args.actualDelegatesCount !== undefined && args.actualDelegatesCount !== null) {
        this.actualDelegatesCount = args.actualDelegatesCount;
      }
      if (args.futureDelegatesCount !== undefined && args.futureDelegatesCount !== null) {
        this.futureDelegatesCount = args.futureDelegatesCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.fromUserId = new UserOrGroup();
          this.fromUserId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.toUserId = new UserOrGroup();
          this.toUserId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.actualDelegatesCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.futureDelegatesCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ClientDelegateInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.fromUserId !== null && this.fromUserId !== undefined) {
      output.writeFieldBegin('fromUserId', Thrift.Type.STRUCT, 2);
      this.fromUserId.write(output);
      output.writeFieldEnd();
    }
    if (this.toUserId !== null && this.toUserId !== undefined) {
      output.writeFieldBegin('toUserId', Thrift.Type.STRUCT, 3);
      this.toUserId.write(output);
      output.writeFieldEnd();
    }
    if (this.actualDelegatesCount !== null && this.actualDelegatesCount !== undefined) {
      output.writeFieldBegin('actualDelegatesCount', Thrift.Type.I32, 4);
      output.writeI32(this.actualDelegatesCount);
      output.writeFieldEnd();
    }
    if (this.futureDelegatesCount !== null && this.futureDelegatesCount !== undefined) {
      output.writeFieldBegin('futureDelegatesCount', Thrift.Type.I32, 5);
      output.writeI32(this.futureDelegatesCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserPreferences = class {
  constructor(args) {
    this.userId = null;
    this.attachDocs = null;
    this.attachRegistry = null;
    if (args) {
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.attachDocs !== undefined && args.attachDocs !== null) {
        this.attachDocs = args.attachDocs;
      }
      if (args.attachRegistry !== undefined && args.attachRegistry !== null) {
        this.attachRegistry = args.attachRegistry;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.attachDocs = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.attachRegistry = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserPreferences');
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 1);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.attachDocs !== null && this.attachDocs !== undefined) {
      output.writeFieldBegin('attachDocs', Thrift.Type.BOOL, 2);
      output.writeBool(this.attachDocs);
      output.writeFieldEnd();
    }
    if (this.attachRegistry !== null && this.attachRegistry !== undefined) {
      output.writeFieldBegin('attachRegistry', Thrift.Type.BOOL, 3);
      output.writeBool(this.attachRegistry);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


CURRENT_VERSION = '1.0.385';
AUTH_SERVICE_PATH_JSON = 'auth-json';
USER_SERVICE_PATH_JSON = 'user-management-json';
DOCUMENT_SERVICE_PATH_JSON = 'document-management-json';
DOCUMENT_PATTERN_SERVICE_PATH_JSON = 'document-pattern-management-json';
FILLED_DOCUMENT_PATTERN_SERVICE_PATH_JSON = 'filled-document-pattern-management-json';
NOTIFICATION_SERVICE_PATH_JSON = 'notification-json';
CALENDAR_SERVICE_PATH_JSON = 'calendar-json';
DEVICES_SERVICE_PATH_JSON = 'devices-json';
ADMIN_SERVICE_PATH_JSON = 'admin-json';
REPORT_SERVICE_PATH_JSON = 'report-json';
HANDBOOK_SERVICE_PATH_JSON = 'handbook-json';
DEPARTMENT_SERVICE_PATH_JSON = 'department-json';
DSIGN_SERVICE_PATH_JSON = 'dsign-json';
SECURITY_CLASSIFICATION_SERVICE_PATH_JSON = 'securityClassification-json';
FILTER_SERVICE_PATH_JSON = 'filter-json';
HISTORY_SERVICE_PATH_JSON = 'history-json';
AGGREGATION_DATA_SERVICE_PATH_JSON = 'aggregationData-json';
ACCOUNT_SERVICE_PATH_JSON = 'account-json';
ACCOUNT_GROUP_SERVICE_PATH_JSON = 'accountGroup-json';
SCRIPT_DICTIONARY_SERVICE_PATH_JSON = 'scriptDictionary-json';
AUTH_SERVICE_PATH_BIN = 'auth-bin';
USER_SERVICE_PATH_BIN = 'user-management-bin';
DOCUMENT_SERVICE_PATH_BIN = 'document-management-bin';
DOCUMENT_PATTERN_SERVICE_PATH_BIN = 'document-pattern-management-bin';
FILLED_DOCUMENT_PATTERN_SERVICE_PATH_BIN = 'filled-document-pattern-management-bin';
NOTIFICATION_SERVICE_PATH_BIN = 'notification-bin';
CALENDAR_SERVICE_PATH_BIN = 'calendar-bin';
DEVICES_SERVICE_PATH_BIN = 'devices-bin';
ADMIN_SERVICE_PATH_BIN = 'admin-bin';
REPORT_SERVICE_PATH_BIN = 'report-bin';
HANDBOOK_SERVICE_PATH_BIN = 'handbook-bin';
DEPARTMENT_SERVICE_PATH_BIN = 'department-bin';
DSIGN_SERVICE_PATH_BIN = 'dsign-bin';
SECURITY_CLASSIFICATION_SERVICE_PATH_BIN = 'securityClassification-bin';
FILTER_SERVICE_PATH_BIN = 'filter-bin';
HISTORY_SERVICE_PATH_BIN = 'history-bin';
AGGREGATION_DATA_SERVICE_PATH_BIN = 'aggregationData-bin';
ACCOUNT_SERVICE_PATH_BIN = 'account-bin';
ACCOUNT_GROUP_SERVICE_PATH_BIN = 'accountGroup-bin';
SCRIPT_DICTIONARY_SERVICE_PATH_BIN = 'scriptDictionary-bin';
AUTH_SERVICE_PATH_PURE_JSON = 'auth-pure-json';
USER_SERVICE_PATH_PURE_JSON = 'user-management-pure-json';
DOCUMENT_SERVICE_PATH_PURE_JSON = 'document-management-pure-json';
DOCUMENT_PATTERN_SERVICE_PATH_PURE_JSON = 'document-pattern-management-pure-json';
FILLED_DOCUMENT_PATTERN_SERVICE_PATH_PURE_JSON = 'filled-document-pattern-management-pure-json';
NOTIFICATION_SERVICE_PATH_PURE_JSON = 'notification-pure-json';
CALENDAR_SERVICE_PATH_PURE_JSON = 'calendar-pure-json';
DEVICES_SERVICE_PATH_PURE_JSON = 'devices-pure-json';
ADMIN_SERVICE_PATH_PURE_JSON = 'admin-pure-json';
REPORT_SERVICE_PATH_PURE_JSON = 'report-pure-json';
HANDBOOK_SERVICE_PATH_PURE_JSON = 'handbook-pure-json';
DEPARTMENT_SERVICE_PATH_PURE_JSON = 'department-pure-json';
DSIGN_SERVICE_PATH_PURE_JSON = 'dsign-pure-json';
SECURITY_CLASSIFICATION_SERVICE_PATH_PURE_JSON = 'securityClassification-pure-json';
FILTER_SERVICE_PATH_PURE_JSON = 'filter-pure-json';
HISTORY_SERVICE_PATH_PURE_JSON = 'history-pure-json';
AGGREGATION_DATA_SERVICE_PATH_PURE_JSON = 'aggregationData-pure-json';
ACCOUNT_SERVICE_PATH_PURE_JSON = 'account-pure-json';
ACCOUNT_GROUP_SERVICE_PATH_PURE_JSON = 'accountGroup-pure-json';
SCRIPT_DICTIONARY_SERVICE_PATH_PURE_JSON = 'scriptDictionary-pure-json';
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


AccountDefineConf = {
  'GROUP_ALL' : 0,
  'DECISION_DICT' : 1,
  'A4_TEMPLATE_DICT' : 2
};
ReportType = {
  'XML' : 0,
  'PDF' : 1,
  'XLSX' : 2,
  'DOCX' : 3
};
ReportTemplateType = {
  'COMMON' : 0,
  'PATTERN' : 1
};
FileStorageType = {
  'PRIMARY' : 0,
  'ARCHIVE' : 1
};
NotificationType = {
  'MEETING_CREATE' : 0,
  'MEETING_UPDATE' : 1,
  'MEETING_CANCEL' : 2,
  'MEETING_SUGGESTION_OTHER_TIME' : 3,
  'MEETING_INVITATION_SECRETARY' : 4,
  'MEETING_MOVE_TO_PRE_VOTE' : 5,
  'MEETING_MOVE_TO_PREPARE' : 6,
  'MEETING_MOVE_TO_VOTE' : 7,
  'DOCUMENT_MOVE_TO_NEXT_STAGE' : 8,
  'DOCUMENT_PERIODICAL_REMINDER' : 9,
  'DOCUMENT_REASSIGN' : 10,
  'DOCUMENT_REASSIGN_WITH_CONTROL' : 11,
  'REASSIGN_DOCUMENT_EXECUTION_CARD_CLOSED' : 12,
  'REASSIGN_DOCUMENT_EXECUTION_CARD_REVOKED' : 13,
  'DOCUMENT_EXECUTION_CARD_CLOSED' : 14,
  'DOCUMENT_ON_CONTROL_RETURNED' : 15,
  'DOCUMENT_EXPIRED' : 16,
  'DOCUMENT_DEADLINE_ONCOMING' : 17,
  'DOCUMENT_DEADLINE_OVERDUE' : 18,
  'DOCUMENT_EXECUTION_DELETED' : 19,
  'RESET_PASSWORD' : 20,
  'SET_PASSWORD_FOR_NEW_USER' : 21,
  'DOCUMENT_REGISTERED' : 22,
  'DOCUMENT_EXECUTION_CARD_AUTO_CLOSED' : 23,
  'DOCUMENT_DECISION' : 24,
  'DOCUMENT_FAMILIARIZATION' : 25,
  'DOCUMENT_ADDITIONAL_DECISION' : 26,
  'DOCUMENT_ADD_ADDITIONAL_CONFIRMER' : 27,
  'DOCUMENT_ATTACHMENT_LOADED' : 28,
  'RECOVERY_PASSWORD' : 29,
  'DOCUMENT_EXECUTOR_REMINDER' : 30,
  'EVENT_CREATE' : 31,
  'EVENT_UPDATE' : 32,
  'EVENT_CANCEL' : 33,
  'REGISTRATION_LDAP_USER' : 34,
  'NEWS_CREATE' : 35,
  'COMING_USER_CERTIFICATE_DEADLINE' : 36,
  'USER_CERTIFICATE_DEADLINE' : 37,
  'USER_CERTIFICATE_DELETED' : 38,
  'CERTIFICATE_APPROVED' : 39,
  'CERTIFICATE_DECLINED' : 40,
  'DOCUMENT_REASSIGN_DEADLINE_ONCOMING' : 41,
  'AUTHOR_ANSWER_COMMENT' : 42
};
KeyState = {
  'LOADED' : 0,
  'CONFIRM' : 1,
  'PROHIBITED' : 2,
  'NO_FILE' : 3,
  'DELETED' : 4
};
SearchType = {
  'S_LIKE' : 0,
  'S_LIKE_SEMANTIC' : 1,
  'S_ALL' : 2,
  'S_ALL_SEMANTIC' : 3,
  'S_ANY' : 4,
  'S_ANY_SEMANTIC' : 5
};
ExecutorActionType = {
  'ADD' : 0,
  'DELETE' : 1
};
Account = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.accountName = null;
    this.main = null;
    this.confidential = null;
    this.encrypted = null;
    this.accountCof = null;
    this.storages = null;
    this.accountGroupId = null;
    this.orderNum = null;
    this.extType = null;
    this.authServiceId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.accountName !== undefined && args.accountName !== null) {
        this.accountName = args.accountName;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
      if (args.confidential !== undefined && args.confidential !== null) {
        this.confidential = args.confidential;
      }
      if (args.encrypted !== undefined && args.encrypted !== null) {
        this.encrypted = args.encrypted;
      }
      if (args.accountCof !== undefined && args.accountCof !== null) {
        this.accountCof = Thrift.copyMap(args.accountCof, [null]);
      }
      if (args.storages !== undefined && args.storages !== null) {
        this.storages = Thrift.copyList(args.storages, [null]);
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
      if (args.orderNum !== undefined && args.orderNum !== null) {
        this.orderNum = args.orderNum;
      }
      if (args.extType !== undefined && args.extType !== null) {
        this.extType = args.extType;
      }
      if (args.authServiceId !== undefined && args.authServiceId !== null) {
        this.authServiceId = args.authServiceId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.confidential = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.encrypted = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.MAP) {
          this.accountCof = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readI32().value;
            val4 = input.readString().value;
            this.accountCof[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.storages = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new FileStorage();
            elem8.read(input);
            this.storages.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.orderNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.extType = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.authServiceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Account');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.accountName !== null && this.accountName !== undefined) {
      output.writeFieldBegin('accountName', Thrift.Type.STRING, 3);
      output.writeString(this.accountName);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 4);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    if (this.confidential !== null && this.confidential !== undefined) {
      output.writeFieldBegin('confidential', Thrift.Type.BOOL, 5);
      output.writeBool(this.confidential);
      output.writeFieldEnd();
    }
    if (this.encrypted !== null && this.encrypted !== undefined) {
      output.writeFieldBegin('encrypted', Thrift.Type.BOOL, 6);
      output.writeBool(this.encrypted);
      output.writeFieldEnd();
    }
    if (this.accountCof !== null && this.accountCof !== undefined) {
      output.writeFieldBegin('accountCof', Thrift.Type.MAP, 7);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRING, Thrift.objectLength(this.accountCof));
      for (let kiter9 in this.accountCof) {
        if (this.accountCof.hasOwnProperty(kiter9)) {
          let viter10 = this.accountCof[kiter9];
          output.writeI32(kiter9);
          output.writeString(viter10);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.storages !== null && this.storages !== undefined) {
      output.writeFieldBegin('storages', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.storages.length);
      for (let iter11 in this.storages) {
        if (this.storages.hasOwnProperty(iter11)) {
          iter11 = this.storages[iter11];
          iter11.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 9);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    if (this.orderNum !== null && this.orderNum !== undefined) {
      output.writeFieldBegin('orderNum', Thrift.Type.I32, 10);
      output.writeI32(this.orderNum);
      output.writeFieldEnd();
    }
    if (this.extType !== null && this.extType !== undefined) {
      output.writeFieldBegin('extType', Thrift.Type.STRING, 11);
      output.writeString(this.extType);
      output.writeFieldEnd();
    }
    if (this.authServiceId !== null && this.authServiceId !== undefined) {
      output.writeFieldBegin('authServiceId', Thrift.Type.STRING, 12);
      output.writeString(this.authServiceId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.accounts = null;
    this.blocked = null;
    this.visibleAllAccounts = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.accounts !== undefined && args.accounts !== null) {
        this.accounts = Thrift.copyList(args.accounts, [Account]);
      }
      if (args.blocked !== undefined && args.blocked !== null) {
        this.blocked = args.blocked;
      }
      if (args.visibleAllAccounts !== undefined && args.visibleAllAccounts !== null) {
        this.visibleAllAccounts = args.visibleAllAccounts;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.accounts = [];
          const _rtmp313 = input.readListBegin();
          const _size12 = _rtmp313.size || 0;
          for (let _i14 = 0; _i14 < _size12; ++_i14) {
            let elem15 = null;
            elem15 = new Account();
            elem15.read(input);
            this.accounts.push(elem15);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.blocked = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleAllAccounts = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.accounts !== null && this.accounts !== undefined) {
      output.writeFieldBegin('accounts', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.accounts.length);
      for (let iter16 in this.accounts) {
        if (this.accounts.hasOwnProperty(iter16)) {
          iter16 = this.accounts[iter16];
          iter16.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.blocked !== null && this.blocked !== undefined) {
      output.writeFieldBegin('blocked', Thrift.Type.BOOL, 4);
      output.writeBool(this.blocked);
      output.writeFieldEnd();
    }
    if (this.visibleAllAccounts !== null && this.visibleAllAccounts !== undefined) {
      output.writeFieldBegin('visibleAllAccounts', Thrift.Type.BOOL, 5);
      output.writeBool(this.visibleAllAccounts);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportParams = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.value = null;
    this.type = null;
    this.requared = null;
    this.oName = null;
    this.handbookId = null;
    this.handbookLookupCol = null;
    this.handbookSelectColumn = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.handbookId !== undefined && args.handbookId !== null) {
        this.handbookId = args.handbookId;
      }
      if (args.handbookLookupCol !== undefined && args.handbookLookupCol !== null) {
        this.handbookLookupCol = args.handbookLookupCol;
      }
      if (args.handbookSelectColumn !== undefined && args.handbookSelectColumn !== null) {
        this.handbookSelectColumn = args.handbookSelectColumn;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.handbookId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.handbookLookupCol = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.handbookSelectColumn = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportParams');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 5);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 6);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.handbookId !== null && this.handbookId !== undefined) {
      output.writeFieldBegin('handbookId', Thrift.Type.STRING, 7);
      output.writeString(this.handbookId);
      output.writeFieldEnd();
    }
    if (this.handbookLookupCol !== null && this.handbookLookupCol !== undefined) {
      output.writeFieldBegin('handbookLookupCol', Thrift.Type.STRING, 8);
      output.writeString(this.handbookLookupCol);
      output.writeFieldEnd();
    }
    if (this.handbookSelectColumn !== null && this.handbookSelectColumn !== undefined) {
      output.writeFieldBegin('handbookSelectColumn', Thrift.Type.STRING, 9);
      output.writeString(this.handbookSelectColumn);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportTemplate = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.reportName = null;
    this.fastPrint = null;
    this.reportCount = null;
    this.adParams = null;
    this.group = null;
    this.reportType = null;
    this.accountIds = null;
    this.reportTypes = null;
    this.addWatermark = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.reportName !== undefined && args.reportName !== null) {
        this.reportName = args.reportName;
      }
      if (args.fastPrint !== undefined && args.fastPrint !== null) {
        this.fastPrint = args.fastPrint;
      }
      if (args.reportCount !== undefined && args.reportCount !== null) {
        this.reportCount = args.reportCount;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [ReportParams]);
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = args.group;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
      if (args.reportTypes !== undefined && args.reportTypes !== null) {
        this.reportTypes = Thrift.copyList(args.reportTypes, [null]);
      }
      if (args.addWatermark !== undefined && args.addWatermark !== null) {
        this.addWatermark = args.addWatermark;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reportName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.fastPrint = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.reportCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = new ReportParams();
            elem20.read(input);
            this.adParams.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.group = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.SET) {
          this.accountIds = [];
          const _rtmp322 = input.readSetBegin();
          const _size21 = _rtmp322.size || 0;
          for (let _i23 = 0; _i23 < _size21; ++_i23) {
            let elem24 = null;
            elem24 = input.readString().value;
            this.accountIds.push(elem24);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.SET) {
          this.reportTypes = [];
          const _rtmp326 = input.readSetBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = input.readI32().value;
            this.reportTypes.push(elem28);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.addWatermark = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportTemplate');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.reportName !== null && this.reportName !== undefined) {
      output.writeFieldBegin('reportName', Thrift.Type.STRING, 3);
      output.writeString(this.reportName);
      output.writeFieldEnd();
    }
    if (this.fastPrint !== null && this.fastPrint !== undefined) {
      output.writeFieldBegin('fastPrint', Thrift.Type.BOOL, 4);
      output.writeBool(this.fastPrint);
      output.writeFieldEnd();
    }
    if (this.reportCount !== null && this.reportCount !== undefined) {
      output.writeFieldBegin('reportCount', Thrift.Type.I64, 5);
      output.writeI64(this.reportCount);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter29 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter29)) {
          iter29 = this.adParams[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRING, 7);
      output.writeString(this.group);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 8);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.SET, 9);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter30 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter30)) {
          iter30 = this.accountIds[iter30];
          output.writeString(iter30);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.reportTypes !== null && this.reportTypes !== undefined) {
      output.writeFieldBegin('reportTypes', Thrift.Type.SET, 10);
      output.writeSetBegin(Thrift.Type.I32, this.reportTypes.length);
      for (let iter31 in this.reportTypes) {
        if (this.reportTypes.hasOwnProperty(iter31)) {
          iter31 = this.reportTypes[iter31];
          output.writeI32(iter31);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.addWatermark !== null && this.addWatermark !== undefined) {
      output.writeFieldBegin('addWatermark', Thrift.Type.BOOL, 11);
      output.writeBool(this.addWatermark);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassification = class {
  constructor(args) {
    this.id = null;
    this.gname = null;
    this.scDescription = null;
    this.group = null;
    this.share = null;
    this.scMask = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.gname !== undefined && args.gname !== null) {
        this.gname = args.gname;
      }
      if (args.scDescription !== undefined && args.scDescription !== null) {
        this.scDescription = args.scDescription;
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = args.group;
      }
      if (args.share !== undefined && args.share !== null) {
        this.share = args.share;
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.gname = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.scDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.group = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.share = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassification');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.gname !== null && this.gname !== undefined) {
      output.writeFieldBegin('gname', Thrift.Type.STRING, 2);
      output.writeString(this.gname);
      output.writeFieldEnd();
    }
    if (this.scDescription !== null && this.scDescription !== undefined) {
      output.writeFieldBegin('scDescription', Thrift.Type.STRING, 3);
      output.writeString(this.scDescription);
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRING, 4);
      output.writeString(this.group);
      output.writeFieldEnd();
    }
    if (this.share !== null && this.share !== undefined) {
      output.writeFieldBegin('share', Thrift.Type.BOOL, 5);
      output.writeBool(this.share);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 6);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
News = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.theNewsName = null;
    this.theNewsDescription = null;
    this.accountIds = null;
    this.previewUrl = null;
    this.urls = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.theNewsName !== undefined && args.theNewsName !== null) {
        this.theNewsName = args.theNewsName;
      }
      if (args.theNewsDescription !== undefined && args.theNewsDescription !== null) {
        this.theNewsDescription = args.theNewsDescription;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
      if (args.previewUrl !== undefined && args.previewUrl !== null) {
        this.previewUrl = args.previewUrl;
      }
      if (args.urls !== undefined && args.urls !== null) {
        this.urls = Thrift.copyList(args.urls, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.theNewsName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.theNewsDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.accountIds = [];
          const _rtmp333 = input.readSetBegin();
          const _size32 = _rtmp333.size || 0;
          for (let _i34 = 0; _i34 < _size32; ++_i34) {
            let elem35 = null;
            elem35 = input.readString().value;
            this.accountIds.push(elem35);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.previewUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.urls = [];
          const _rtmp337 = input.readListBegin();
          const _size36 = _rtmp337.size || 0;
          for (let _i38 = 0; _i38 < _size36; ++_i38) {
            let elem39 = null;
            elem39 = input.readString().value;
            this.urls.push(elem39);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('News');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.theNewsName !== null && this.theNewsName !== undefined) {
      output.writeFieldBegin('theNewsName', Thrift.Type.STRING, 3);
      output.writeString(this.theNewsName);
      output.writeFieldEnd();
    }
    if (this.theNewsDescription !== null && this.theNewsDescription !== undefined) {
      output.writeFieldBegin('theNewsDescription', Thrift.Type.STRING, 4);
      output.writeString(this.theNewsDescription);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter40 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter40)) {
          iter40 = this.accountIds[iter40];
          output.writeString(iter40);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.previewUrl !== null && this.previewUrl !== undefined) {
      output.writeFieldBegin('previewUrl', Thrift.Type.STRING, 6);
      output.writeString(this.previewUrl);
      output.writeFieldEnd();
    }
    if (this.urls !== null && this.urls !== undefined) {
      output.writeFieldBegin('urls', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.urls.length);
      for (let iter41 in this.urls) {
        if (this.urls.hasOwnProperty(iter41)) {
          iter41 = this.urls[iter41];
          output.writeString(iter41);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FileStorage = class {
  constructor(args) {
    this.id = null;
    this.uri = null;
    this.createDate = null;
    this.type = null;
    this.priority = null;
    this.readOnly = null;
    this.descriptionFileStorage = null;
    this.capacity = null;
    this.freeSpace = null;
    this.allowEdit = null;
    this.accountList = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.uri !== undefined && args.uri !== null) {
        this.uri = args.uri;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.priority !== undefined && args.priority !== null) {
        this.priority = args.priority;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.descriptionFileStorage !== undefined && args.descriptionFileStorage !== null) {
        this.descriptionFileStorage = args.descriptionFileStorage;
      }
      if (args.capacity !== undefined && args.capacity !== null) {
        this.capacity = args.capacity;
      }
      if (args.freeSpace !== undefined && args.freeSpace !== null) {
        this.freeSpace = args.freeSpace;
      }
      if (args.allowEdit !== undefined && args.allowEdit !== null) {
        this.allowEdit = args.allowEdit;
      }
      if (args.accountList !== undefined && args.accountList !== null) {
        this.accountList = Thrift.copyList(args.accountList, [Account]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.uri = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.priority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionFileStorage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.capacity = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.freeSpace = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.allowEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.LIST) {
          this.accountList = [];
          const _rtmp343 = input.readListBegin();
          const _size42 = _rtmp343.size || 0;
          for (let _i44 = 0; _i44 < _size42; ++_i44) {
            let elem45 = null;
            elem45 = new Account();
            elem45.read(input);
            this.accountList.push(elem45);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FileStorage');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.uri !== null && this.uri !== undefined) {
      output.writeFieldBegin('uri', Thrift.Type.STRING, 2);
      output.writeString(this.uri);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 3);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.priority !== null && this.priority !== undefined) {
      output.writeFieldBegin('priority', Thrift.Type.I32, 5);
      output.writeI32(this.priority);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 6);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.descriptionFileStorage !== null && this.descriptionFileStorage !== undefined) {
      output.writeFieldBegin('descriptionFileStorage', Thrift.Type.STRING, 7);
      output.writeString(this.descriptionFileStorage);
      output.writeFieldEnd();
    }
    if (this.capacity !== null && this.capacity !== undefined) {
      output.writeFieldBegin('capacity', Thrift.Type.I64, 8);
      output.writeI64(this.capacity);
      output.writeFieldEnd();
    }
    if (this.freeSpace !== null && this.freeSpace !== undefined) {
      output.writeFieldBegin('freeSpace', Thrift.Type.I64, 9);
      output.writeI64(this.freeSpace);
      output.writeFieldEnd();
    }
    if (this.allowEdit !== null && this.allowEdit !== undefined) {
      output.writeFieldBegin('allowEdit', Thrift.Type.BOOL, 11);
      output.writeBool(this.allowEdit);
      output.writeFieldEnd();
    }
    if (this.accountList !== null && this.accountList !== undefined) {
      output.writeFieldBegin('accountList', Thrift.Type.LIST, 12);
      output.writeListBegin(Thrift.Type.STRUCT, this.accountList.length);
      for (let iter46 in this.accountList) {
        if (this.accountList.hasOwnProperty(iter46)) {
          iter46 = this.accountList[iter46];
          iter46.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CertificateInfo = class {
  constructor(args) {
    this.serialNumber = null;
    this.legalNumber = null;
    this.individualNumber = null;
    this.issuerDN = null;
    this.subjectDN = null;
    this.signDate = null;
    this.beforeDate = null;
    this.afterDate = null;
    this.signature = null;
    this.email = null;
    this.organization = null;
    this.fullName = null;
    if (args) {
      if (args.serialNumber !== undefined && args.serialNumber !== null) {
        this.serialNumber = args.serialNumber;
      }
      if (args.legalNumber !== undefined && args.legalNumber !== null) {
        this.legalNumber = args.legalNumber;
      }
      if (args.individualNumber !== undefined && args.individualNumber !== null) {
        this.individualNumber = args.individualNumber;
      }
      if (args.issuerDN !== undefined && args.issuerDN !== null) {
        this.issuerDN = args.issuerDN;
      }
      if (args.subjectDN !== undefined && args.subjectDN !== null) {
        this.subjectDN = args.subjectDN;
      }
      if (args.signDate !== undefined && args.signDate !== null) {
        this.signDate = args.signDate;
      }
      if (args.beforeDate !== undefined && args.beforeDate !== null) {
        this.beforeDate = args.beforeDate;
      }
      if (args.afterDate !== undefined && args.afterDate !== null) {
        this.afterDate = args.afterDate;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.email !== undefined && args.email !== null) {
        this.email = args.email;
      }
      if (args.organization !== undefined && args.organization !== null) {
        this.organization = args.organization;
      }
      if (args.fullName !== undefined && args.fullName !== null) {
        this.fullName = args.fullName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.serialNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.legalNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.individualNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.issuerDN = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.subjectDN = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.signDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.beforeDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.afterDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.email = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.organization = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.fullName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CertificateInfo');
    if (this.serialNumber !== null && this.serialNumber !== undefined) {
      output.writeFieldBegin('serialNumber', Thrift.Type.STRING, 1);
      output.writeString(this.serialNumber);
      output.writeFieldEnd();
    }
    if (this.legalNumber !== null && this.legalNumber !== undefined) {
      output.writeFieldBegin('legalNumber', Thrift.Type.STRING, 2);
      output.writeString(this.legalNumber);
      output.writeFieldEnd();
    }
    if (this.individualNumber !== null && this.individualNumber !== undefined) {
      output.writeFieldBegin('individualNumber', Thrift.Type.STRING, 3);
      output.writeString(this.individualNumber);
      output.writeFieldEnd();
    }
    if (this.issuerDN !== null && this.issuerDN !== undefined) {
      output.writeFieldBegin('issuerDN', Thrift.Type.STRING, 4);
      output.writeString(this.issuerDN);
      output.writeFieldEnd();
    }
    if (this.subjectDN !== null && this.subjectDN !== undefined) {
      output.writeFieldBegin('subjectDN', Thrift.Type.STRING, 5);
      output.writeString(this.subjectDN);
      output.writeFieldEnd();
    }
    if (this.signDate !== null && this.signDate !== undefined) {
      output.writeFieldBegin('signDate', Thrift.Type.I64, 6);
      output.writeI64(this.signDate);
      output.writeFieldEnd();
    }
    if (this.beforeDate !== null && this.beforeDate !== undefined) {
      output.writeFieldBegin('beforeDate', Thrift.Type.I64, 7);
      output.writeI64(this.beforeDate);
      output.writeFieldEnd();
    }
    if (this.afterDate !== null && this.afterDate !== undefined) {
      output.writeFieldBegin('afterDate', Thrift.Type.I64, 8);
      output.writeI64(this.afterDate);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 9);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.email !== null && this.email !== undefined) {
      output.writeFieldBegin('email', Thrift.Type.STRING, 10);
      output.writeString(this.email);
      output.writeFieldEnd();
    }
    if (this.organization !== null && this.organization !== undefined) {
      output.writeFieldBegin('organization', Thrift.Type.STRING, 11);
      output.writeString(this.organization);
      output.writeFieldEnd();
    }
    if (this.fullName !== null && this.fullName !== undefined) {
      output.writeFieldBegin('fullName', Thrift.Type.STRING, 12);
      output.writeString(this.fullName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

NotificationService_getAllNotifications_args = class {
  constructor(args) {
    this.token = null;
    this.unreadOnly = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.unreadOnly !== undefined && args.unreadOnly !== null) {
        this.unreadOnly = args.unreadOnly;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.unreadOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getAllNotifications_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.unreadOnly !== null && this.unreadOnly !== undefined) {
      output.writeFieldBegin('unreadOnly', Thrift.Type.BOOL, 2);
      output.writeBool(this.unreadOnly);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_getAllNotifications_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationQueue]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp337 = input.readListBegin();
          const _size36 = _rtmp337.size || 0;
          for (let _i38 = 0; _i38 < _size36; ++_i38) {
            let elem39 = null;
            elem39 = new NotificationQueue();
            elem39.read(input);
            this.success.push(elem39);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getAllNotifications_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter40 in this.success) {
        if (this.success.hasOwnProperty(iter40)) {
          iter40 = this.success[iter40];
          iter40.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_markNotificationAsRead_args = class {
  constructor(args) {
    this.token = null;
    this.notificationId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.notificationId !== undefined && args.notificationId !== null) {
        this.notificationId = args.notificationId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.notificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_markNotificationAsRead_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.notificationId !== null && this.notificationId !== undefined) {
      output.writeFieldBegin('notificationId', Thrift.Type.STRING, 2);
      output.writeString(this.notificationId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_markNotificationAsRead_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_markNotificationAsRead_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_getAllNotificationTransportTypes_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getAllNotificationTransportTypes_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_getAllNotificationTransportTypes_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationTransportType]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp342 = input.readListBegin();
          const _size41 = _rtmp342.size || 0;
          for (let _i43 = 0; _i43 < _size41; ++_i43) {
            let elem44 = null;
            elem44 = new NotificationTransportType();
            elem44.read(input);
            this.success.push(elem44);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getAllNotificationTransportTypes_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter45 in this.success) {
        if (this.success.hasOwnProperty(iter45)) {
          iter45 = this.success[iter45];
          iter45.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_getNotificationConfig_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getNotificationConfig_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_getNotificationConfig_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationConfig]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp347 = input.readListBegin();
          const _size46 = _rtmp347.size || 0;
          for (let _i48 = 0; _i48 < _size46; ++_i48) {
            let elem49 = null;
            elem49 = new NotificationConfig();
            elem49.read(input);
            this.success.push(elem49);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_getNotificationConfig_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter50 in this.success) {
        if (this.success.hasOwnProperty(iter50)) {
          iter50 = this.success[iter50];
          iter50.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_updateNotificationConfig_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.notificationConfigs = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.notificationConfigs !== undefined && args.notificationConfigs !== null) {
        this.notificationConfigs = Thrift.copyList(args.notificationConfigs, [NotificationConfig]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.notificationConfigs = [];
          const _rtmp352 = input.readListBegin();
          const _size51 = _rtmp352.size || 0;
          for (let _i53 = 0; _i53 < _size51; ++_i53) {
            let elem54 = null;
            elem54 = new NotificationConfig();
            elem54.read(input);
            this.notificationConfigs.push(elem54);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_updateNotificationConfig_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.notificationConfigs !== null && this.notificationConfigs !== undefined) {
      output.writeFieldBegin('notificationConfigs', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.notificationConfigs.length);
      for (let iter55 in this.notificationConfigs) {
        if (this.notificationConfigs.hasOwnProperty(iter55)) {
          iter55 = this.notificationConfigs[iter55];
          iter55.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationService_updateNotificationConfig_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [NotificationConfig]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp357 = input.readListBegin();
          const _size56 = _rtmp357.size || 0;
          for (let _i58 = 0; _i58 < _size56; ++_i58) {
            let elem59 = null;
            elem59 = new NotificationConfig();
            elem59.read(input);
            this.success.push(elem59);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NotificationService_updateNotificationConfig_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter60 in this.success) {
        if (this.success.hasOwnProperty(iter60)) {
          iter60 = this.success[iter60];
          iter60.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NotificationServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllNotifications (token, unreadOnly, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNotifications(token, unreadOnly, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNotifications (token, unreadOnly, filter, callback) {
    const params = {
      token: token,
      unreadOnly: unreadOnly,
      filter: filter
    };
    const args = new NotificationService_getAllNotifications_args(params);
    try {
      this.output.writeMessageBegin('getAllNotifications', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNotifications();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNotifications () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new NotificationService_getAllNotifications_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNotifications failed: unknown result';
  }

  markNotificationAsRead (token, notificationId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markNotificationAsRead(token, notificationId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markNotificationAsRead (token, notificationId, callback) {
    const params = {
      token: token,
      notificationId: notificationId
    };
    const args = new NotificationService_markNotificationAsRead_args(params);
    try {
      this.output.writeMessageBegin('markNotificationAsRead', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markNotificationAsRead();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markNotificationAsRead () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new NotificationService_markNotificationAsRead_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markNotificationAsRead failed: unknown result';
  }

  getAllNotificationTransportTypes (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNotificationTransportTypes(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNotificationTransportTypes (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new NotificationService_getAllNotificationTransportTypes_args(params);
    try {
      this.output.writeMessageBegin('getAllNotificationTransportTypes', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNotificationTransportTypes();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNotificationTransportTypes () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new NotificationService_getAllNotificationTransportTypes_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNotificationTransportTypes failed: unknown result';
  }

  getNotificationConfig (token, userId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNotificationConfig(token, userId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNotificationConfig (token, userId, filter, callback) {
    const params = {
      token: token,
      userId: userId,
      filter: filter
    };
    const args = new NotificationService_getNotificationConfig_args(params);
    try {
      this.output.writeMessageBegin('getNotificationConfig', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNotificationConfig();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNotificationConfig () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new NotificationService_getNotificationConfig_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNotificationConfig failed: unknown result';
  }

  updateNotificationConfig (token, userId, notificationConfigs) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateNotificationConfig(token, userId, notificationConfigs, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateNotificationConfig (token, userId, notificationConfigs, callback) {
    const params = {
      token: token,
      userId: userId,
      notificationConfigs: notificationConfigs
    };
    const args = new NotificationService_updateNotificationConfig_args(params);
    try {
      this.output.writeMessageBegin('updateNotificationConfig', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateNotificationConfig();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateNotificationConfig () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new NotificationService_updateNotificationConfig_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateNotificationConfig failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

ReportService_getAllReportGroups_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getAllReportGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString().value;
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getAllReportTemplates_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportTemplates_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getAllReportTemplates_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ReportTemplate]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new ReportTemplate();
            elem8.read(input);
            this.success.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportTemplates_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter9 in this.success) {
        if (this.success.hasOwnProperty(iter9)) {
          iter9 = this.success[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getCountAllReportTemplates_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getCountAllReportTemplates_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getCountAllReportTemplates_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getCountAllReportTemplates_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getAllReportTemplateLinks_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportTemplateLinks_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_getAllReportTemplateLinks_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ReportTemplateLink]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new ReportTemplateLink();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_getAllReportTemplateLinks_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_createOrUpdateReport_args = class {
  constructor(args) {
    this.token = null;
    this.reportTemplate = null;
    this.xmlFile = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportTemplate !== undefined && args.reportTemplate !== null) {
        this.reportTemplate = new ReportTemplate(args.reportTemplate);
      }
      if (args.xmlFile !== undefined && args.xmlFile !== null) {
        this.xmlFile = args.xmlFile;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.reportTemplate = new ReportTemplate();
          this.reportTemplate.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.xmlFile = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_createOrUpdateReport_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportTemplate !== null && this.reportTemplate !== undefined) {
      output.writeFieldBegin('reportTemplate', Thrift.Type.STRUCT, 2);
      this.reportTemplate.write(output);
      output.writeFieldEnd();
    }
    if (this.xmlFile !== null && this.xmlFile !== undefined) {
      output.writeFieldBegin('xmlFile', Thrift.Type.STRING, 3);
      output.writeBinary(this.xmlFile);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_createOrUpdateReport_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ReportTemplate(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ReportTemplate();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_createOrUpdateReport_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_downloadReportTemplate_args = class {
  constructor(args) {
    this.token = null;
    this.templateId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_downloadReportTemplate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 2);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_downloadReportTemplate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_downloadReportTemplate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_removeReportTemplate_args = class {
  constructor(args) {
    this.token = null;
    this.templateId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_removeReportTemplate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 2);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_removeReportTemplate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_removeReportTemplate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_configReportUsages_args = class {
  constructor(args) {
    this.token = null;
    this.templateId = null;
    this.toAddDocPatternIds = null;
    this.toRemoveDocPatternIds = null;
    this.toAddUserGroups = null;
    this.toRemoveUserGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
      if (args.toAddDocPatternIds !== undefined && args.toAddDocPatternIds !== null) {
        this.toAddDocPatternIds = Thrift.copyList(args.toAddDocPatternIds, [null]);
      }
      if (args.toRemoveDocPatternIds !== undefined && args.toRemoveDocPatternIds !== null) {
        this.toRemoveDocPatternIds = Thrift.copyList(args.toRemoveDocPatternIds, [null]);
      }
      if (args.toAddUserGroups !== undefined && args.toAddUserGroups !== null) {
        this.toAddUserGroups = Thrift.copyList(args.toAddUserGroups, [UserOrGroup]);
      }
      if (args.toRemoveUserGroups !== undefined && args.toRemoveUserGroups !== null) {
        this.toRemoveUserGroups = Thrift.copyList(args.toRemoveUserGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toAddDocPatternIds = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = input.readString().value;
            this.toAddDocPatternIds.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toRemoveDocPatternIds = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = input.readString().value;
            this.toRemoveDocPatternIds.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.toAddUserGroups = [];
          const _rtmp324 = input.readListBegin();
          const _size23 = _rtmp324.size || 0;
          for (let _i25 = 0; _i25 < _size23; ++_i25) {
            let elem26 = null;
            elem26 = new UserOrGroup();
            elem26.read(input);
            this.toAddUserGroups.push(elem26);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.toRemoveUserGroups = [];
          const _rtmp328 = input.readListBegin();
          const _size27 = _rtmp328.size || 0;
          for (let _i29 = 0; _i29 < _size27; ++_i29) {
            let elem30 = null;
            elem30 = new UserOrGroup();
            elem30.read(input);
            this.toRemoveUserGroups.push(elem30);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_configReportUsages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 2);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    if (this.toAddDocPatternIds !== null && this.toAddDocPatternIds !== undefined) {
      output.writeFieldBegin('toAddDocPatternIds', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toAddDocPatternIds.length);
      for (let iter31 in this.toAddDocPatternIds) {
        if (this.toAddDocPatternIds.hasOwnProperty(iter31)) {
          iter31 = this.toAddDocPatternIds[iter31];
          output.writeString(iter31);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemoveDocPatternIds !== null && this.toRemoveDocPatternIds !== undefined) {
      output.writeFieldBegin('toRemoveDocPatternIds', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.toRemoveDocPatternIds.length);
      for (let iter32 in this.toRemoveDocPatternIds) {
        if (this.toRemoveDocPatternIds.hasOwnProperty(iter32)) {
          iter32 = this.toRemoveDocPatternIds[iter32];
          output.writeString(iter32);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toAddUserGroups !== null && this.toAddUserGroups !== undefined) {
      output.writeFieldBegin('toAddUserGroups', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAddUserGroups.length);
      for (let iter33 in this.toAddUserGroups) {
        if (this.toAddUserGroups.hasOwnProperty(iter33)) {
          iter33 = this.toAddUserGroups[iter33];
          iter33.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemoveUserGroups !== null && this.toRemoveUserGroups !== undefined) {
      output.writeFieldBegin('toRemoveUserGroups', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.toRemoveUserGroups.length);
      for (let iter34 in this.toRemoveUserGroups) {
        if (this.toRemoveUserGroups.hasOwnProperty(iter34)) {
          iter34 = this.toRemoveUserGroups[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_configReportUsages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_configReportUsages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateDigitalDocument_args = class {
  constructor(args) {
    this.token = null;
    this.reportType = null;
    this.digitalViewId = null;
    this.docId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.digitalViewId !== undefined && args.digitalViewId !== null) {
        this.digitalViewId = args.digitalViewId;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.digitalViewId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateDigitalDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 2);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.digitalViewId !== null && this.digitalViewId !== undefined) {
      output.writeFieldBegin('digitalViewId', Thrift.Type.STRING, 3);
      output.writeString(this.digitalViewId);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 4);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateDigitalDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateDigitalDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReport_args = class {
  constructor(args) {
    this.token = null;
    this.reportType = null;
    this.templateId = null;
    this.adParams = null;
    this.docId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [ReportFilledParam]);
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new ReportFilledParam();
            elem38.read(input);
            this.adParams.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReport_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 2);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 3);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter39 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter39)) {
          iter39 = this.adParams[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 5);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReport_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReport_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReportByFilter_args = class {
  constructor(args) {
    this.token = null;
    this.reportType = null;
    this.templateId = null;
    this.filter = null;
    this.forAllUsers = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.forAllUsers !== undefined && args.forAllUsers !== null) {
        this.forAllUsers = args.forAllUsers;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.forAllUsers = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReportByFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 2);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 3);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.forAllUsers !== null && this.forAllUsers !== undefined) {
      output.writeFieldBegin('forAllUsers', Thrift.Type.BOOL, 5);
      output.writeBool(this.forAllUsers);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReportByFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReportByFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_attachReportToDoc_args = class {
  constructor(args) {
    this.token = null;
    this.reportType = null;
    this.templateId = null;
    this.adParams = null;
    this.docId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [ReportFilledParam]);
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = new ReportFilledParam();
            elem43.read(input);
            this.adParams.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_attachReportToDoc_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 2);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 3);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter44 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter44)) {
          iter44 = this.adParams[iter44];
          iter44.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 5);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_attachReportToDoc_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_attachReportToDoc_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReportURL_args = class {
  constructor(args) {
    this.token = null;
    this.reportType = null;
    this.templateId = null;
    this.adParams = null;
    this.docId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.templateId !== undefined && args.templateId !== null) {
        this.templateId = args.templateId;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [ReportFilledParam]);
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.templateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp346 = input.readListBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = new ReportFilledParam();
            elem48.read(input);
            this.adParams.push(elem48);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReportURL_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 2);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.templateId !== null && this.templateId !== undefined) {
      output.writeFieldBegin('templateId', Thrift.Type.STRING, 3);
      output.writeString(this.templateId);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter49 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter49)) {
          iter49 = this.adParams[iter49];
          iter49.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 5);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_generateReportURL_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_generateReportURL_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_exportDocumentsToExlx_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    this.leftFilterId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.leftFilterId !== undefined && args.leftFilterId !== null) {
        this.leftFilterId = args.leftFilterId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.leftFilterId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_exportDocumentsToExlx_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.leftFilterId !== null && this.leftFilterId !== undefined) {
      output.writeFieldBegin('leftFilterId', Thrift.Type.STRING, 4);
      output.writeString(this.leftFilterId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportService_exportDocumentsToExlx_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportService_exportDocumentsToExlx_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllReportGroups (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllReportGroups(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllReportGroups (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ReportService_getAllReportGroups_args(params);
    try {
      this.output.writeMessageBegin('getAllReportGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllReportGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllReportGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_getAllReportGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllReportGroups failed: unknown result';
  }

  getAllReportTemplates (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllReportTemplates(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllReportTemplates (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new ReportService_getAllReportTemplates_args(params);
    try {
      this.output.writeMessageBegin('getAllReportTemplates', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllReportTemplates();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllReportTemplates () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_getAllReportTemplates_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllReportTemplates failed: unknown result';
  }

  getCountAllReportTemplates (token, docPatternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllReportTemplates(token, docPatternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllReportTemplates (token, docPatternId, filter, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId,
      filter: filter
    };
    const args = new ReportService_getCountAllReportTemplates_args(params);
    try {
      this.output.writeMessageBegin('getCountAllReportTemplates', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllReportTemplates();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllReportTemplates () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_getCountAllReportTemplates_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllReportTemplates failed: unknown result';
  }

  getAllReportTemplateLinks (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllReportTemplateLinks(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllReportTemplateLinks (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ReportService_getAllReportTemplateLinks_args(params);
    try {
      this.output.writeMessageBegin('getAllReportTemplateLinks', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllReportTemplateLinks();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllReportTemplateLinks () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_getAllReportTemplateLinks_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllReportTemplateLinks failed: unknown result';
  }

  createOrUpdateReport (token, reportTemplate, xmlFile) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateReport(token, reportTemplate, xmlFile, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateReport (token, reportTemplate, xmlFile, callback) {
    const params = {
      token: token,
      reportTemplate: reportTemplate,
      xmlFile: xmlFile
    };
    const args = new ReportService_createOrUpdateReport_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateReport', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateReport();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateReport () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_createOrUpdateReport_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateReport failed: unknown result';
  }

  downloadReportTemplate (token, templateId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_downloadReportTemplate(token, templateId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_downloadReportTemplate (token, templateId, callback) {
    const params = {
      token: token,
      templateId: templateId
    };
    const args = new ReportService_downloadReportTemplate_args(params);
    try {
      this.output.writeMessageBegin('downloadReportTemplate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_downloadReportTemplate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_downloadReportTemplate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_downloadReportTemplate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'downloadReportTemplate failed: unknown result';
  }

  removeReportTemplate (token, templateId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeReportTemplate(token, templateId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeReportTemplate (token, templateId, callback) {
    const params = {
      token: token,
      templateId: templateId
    };
    const args = new ReportService_removeReportTemplate_args(params);
    try {
      this.output.writeMessageBegin('removeReportTemplate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeReportTemplate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeReportTemplate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_removeReportTemplate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeReportTemplate failed: unknown result';
  }

  configReportUsages (token, templateId, toAddDocPatternIds, toRemoveDocPatternIds, toAddUserGroups, toRemoveUserGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_configReportUsages(token, templateId, toAddDocPatternIds, toRemoveDocPatternIds, toAddUserGroups, toRemoveUserGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_configReportUsages (token, templateId, toAddDocPatternIds, toRemoveDocPatternIds, toAddUserGroups, toRemoveUserGroups, callback) {
    const params = {
      token: token,
      templateId: templateId,
      toAddDocPatternIds: toAddDocPatternIds,
      toRemoveDocPatternIds: toRemoveDocPatternIds,
      toAddUserGroups: toAddUserGroups,
      toRemoveUserGroups: toRemoveUserGroups
    };
    const args = new ReportService_configReportUsages_args(params);
    try {
      this.output.writeMessageBegin('configReportUsages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_configReportUsages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_configReportUsages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_configReportUsages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'configReportUsages failed: unknown result';
  }

  generateDigitalDocument (token, reportType, digitalViewId, docId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateDigitalDocument(token, reportType, digitalViewId, docId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateDigitalDocument (token, reportType, digitalViewId, docId, callback) {
    const params = {
      token: token,
      reportType: reportType,
      digitalViewId: digitalViewId,
      docId: docId
    };
    const args = new ReportService_generateDigitalDocument_args(params);
    try {
      this.output.writeMessageBegin('generateDigitalDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateDigitalDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateDigitalDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_generateDigitalDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateDigitalDocument failed: unknown result';
  }

  generateReport (token, reportType, templateId, adParams, docId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateReport(token, reportType, templateId, adParams, docId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateReport (token, reportType, templateId, adParams, docId, accessPolicy, callback) {
    const params = {
      token: token,
      reportType: reportType,
      templateId: templateId,
      adParams: adParams,
      docId: docId,
      accessPolicy: accessPolicy
    };
    const args = new ReportService_generateReport_args(params);
    try {
      this.output.writeMessageBegin('generateReport', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateReport();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateReport () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_generateReport_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateReport failed: unknown result';
  }

  generateReportByFilter (token, reportType, templateId, filter, forAllUsers) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateReportByFilter(token, reportType, templateId, filter, forAllUsers, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateReportByFilter (token, reportType, templateId, filter, forAllUsers, callback) {
    const params = {
      token: token,
      reportType: reportType,
      templateId: templateId,
      filter: filter,
      forAllUsers: forAllUsers
    };
    const args = new ReportService_generateReportByFilter_args(params);
    try {
      this.output.writeMessageBegin('generateReportByFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateReportByFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateReportByFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_generateReportByFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateReportByFilter failed: unknown result';
  }

  attachReportToDoc (token, reportType, templateId, adParams, docId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_attachReportToDoc(token, reportType, templateId, adParams, docId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_attachReportToDoc (token, reportType, templateId, adParams, docId, accessPolicy, callback) {
    const params = {
      token: token,
      reportType: reportType,
      templateId: templateId,
      adParams: adParams,
      docId: docId,
      accessPolicy: accessPolicy
    };
    const args = new ReportService_attachReportToDoc_args(params);
    try {
      this.output.writeMessageBegin('attachReportToDoc', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_attachReportToDoc();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_attachReportToDoc () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_attachReportToDoc_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'attachReportToDoc failed: unknown result';
  }

  generateReportURL (token, reportType, templateId, adParams, docId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateReportURL(token, reportType, templateId, adParams, docId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateReportURL (token, reportType, templateId, adParams, docId, accessPolicy, callback) {
    const params = {
      token: token,
      reportType: reportType,
      templateId: templateId,
      adParams: adParams,
      docId: docId,
      accessPolicy: accessPolicy
    };
    const args = new ReportService_generateReportURL_args(params);
    try {
      this.output.writeMessageBegin('generateReportURL', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateReportURL();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateReportURL () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_generateReportURL_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateReportURL failed: unknown result';
  }

  exportDocumentsToExlx (token, accessPolicy, filter, leftFilterId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportDocumentsToExlx(token, accessPolicy, filter, leftFilterId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportDocumentsToExlx (token, accessPolicy, filter, leftFilterId, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter,
      leftFilterId: leftFilterId
    };
    const args = new ReportService_exportDocumentsToExlx_args(params);
    try {
      this.output.writeMessageBegin('exportDocumentsToExlx', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportDocumentsToExlx();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportDocumentsToExlx () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ReportService_exportDocumentsToExlx_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportDocumentsToExlx failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

ScriptDictionaryService_getAllScriptDictionaries_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_getAllScriptDictionaries_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_getAllScriptDictionaries_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ScriptDictionary]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new ScriptDictionary();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_getAllScriptDictionaries_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_getScriptDictionaryById_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    this.withContext = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = new CompositeId(args.id);
      }
      if (args.withContext !== undefined && args.withContext !== null) {
        this.withContext = args.withContext;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.id = new CompositeId();
          this.id.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.withContext = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_getScriptDictionaryById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRUCT, 2);
      this.id.write(output);
      output.writeFieldEnd();
    }
    if (this.withContext !== null && this.withContext !== undefined) {
      output.writeFieldBegin('withContext', Thrift.Type.BOOL, 3);
      output.writeBool(this.withContext);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_getScriptDictionaryById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ScriptDictionary(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ScriptDictionary();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_getScriptDictionaryById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_createOrUpdateScriptDictionary_args = class {
  constructor(args) {
    this.token = null;
    this.scriptDictionary = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.scriptDictionary !== undefined && args.scriptDictionary !== null) {
        this.scriptDictionary = new ScriptDictionary(args.scriptDictionary);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.scriptDictionary = new ScriptDictionary();
          this.scriptDictionary.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_createOrUpdateScriptDictionary_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.scriptDictionary !== null && this.scriptDictionary !== undefined) {
      output.writeFieldBegin('scriptDictionary', Thrift.Type.STRUCT, 2);
      this.scriptDictionary.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_createOrUpdateScriptDictionary_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ScriptDictionary(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ScriptDictionary();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_createOrUpdateScriptDictionary_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_validation_args = class {
  constructor(args) {
    this.token = null;
    this.scriptDictionary = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.scriptDictionary !== undefined && args.scriptDictionary !== null) {
        this.scriptDictionary = new ScriptDictionary(args.scriptDictionary);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.scriptDictionary = new ScriptDictionary();
          this.scriptDictionary.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_validation_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.scriptDictionary !== null && this.scriptDictionary !== undefined) {
      output.writeFieldBegin('scriptDictionary', Thrift.Type.STRUCT, 2);
      this.scriptDictionary.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_validation_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = input.readString().value;
            this.success.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_validation_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter9 in this.success) {
        if (this.success.hasOwnProperty(iter9)) {
          iter9 = this.success[iter9];
          output.writeString(iter9);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_removeScriptDictionary_args = class {
  constructor(args) {
    this.token = null;
    this.id = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = new CompositeId(args.id);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.id = new CompositeId();
          this.id.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_removeScriptDictionary_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRUCT, 2);
      this.id.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryService_removeScriptDictionary_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ScriptDictionaryService_removeScriptDictionary_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ScriptDictionaryServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllScriptDictionaries (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllScriptDictionaries(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllScriptDictionaries (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new ScriptDictionaryService_getAllScriptDictionaries_args(params);
    try {
      this.output.writeMessageBegin('getAllScriptDictionaries', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllScriptDictionaries();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllScriptDictionaries () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ScriptDictionaryService_getAllScriptDictionaries_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllScriptDictionaries failed: unknown result';
  }

  getScriptDictionaryById (token, id, withContext) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getScriptDictionaryById(token, id, withContext, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getScriptDictionaryById (token, id, withContext, callback) {
    const params = {
      token: token,
      id: id,
      withContext: withContext
    };
    const args = new ScriptDictionaryService_getScriptDictionaryById_args(params);
    try {
      this.output.writeMessageBegin('getScriptDictionaryById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getScriptDictionaryById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getScriptDictionaryById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ScriptDictionaryService_getScriptDictionaryById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getScriptDictionaryById failed: unknown result';
  }

  createOrUpdateScriptDictionary (token, scriptDictionary) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateScriptDictionary(token, scriptDictionary, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateScriptDictionary (token, scriptDictionary, callback) {
    const params = {
      token: token,
      scriptDictionary: scriptDictionary
    };
    const args = new ScriptDictionaryService_createOrUpdateScriptDictionary_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateScriptDictionary', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateScriptDictionary();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateScriptDictionary () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ScriptDictionaryService_createOrUpdateScriptDictionary_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateScriptDictionary failed: unknown result';
  }

  validation (token, scriptDictionary) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_validation(token, scriptDictionary, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_validation (token, scriptDictionary, callback) {
    const params = {
      token: token,
      scriptDictionary: scriptDictionary
    };
    const args = new ScriptDictionaryService_validation_args(params);
    try {
      this.output.writeMessageBegin('validation', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_validation();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_validation () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ScriptDictionaryService_validation_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'validation failed: unknown result';
  }

  removeScriptDictionary (token, id) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeScriptDictionary(token, id, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeScriptDictionary (token, id, callback) {
    const params = {
      token: token,
      id: id
    };
    const args = new ScriptDictionaryService_removeScriptDictionary_args(params);
    try {
      this.output.writeMessageBegin('removeScriptDictionary', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeScriptDictionary();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeScriptDictionary () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new ScriptDictionaryService_removeScriptDictionary_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeScriptDictionary failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

SecurityClassificationService_getAllSecurityClassification_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassification_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassification_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SecurityClassification]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new SecurityClassification();
            elem3.read(input);
            this.success.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter4 in this.success) {
        if (this.success.hasOwnProperty(iter4)) {
          iter4 = this.success[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getCountAllSecurityClassification_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getCountAllSecurityClassification_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getCountAllSecurityClassification_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getCountAllSecurityClassification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_createOrUpdateSecurityClassification_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassification = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassification !== undefined && args.securityClassification !== null) {
        this.securityClassification = new SecurityClassification(args.securityClassification);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.securityClassification = new SecurityClassification();
          this.securityClassification.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_createOrUpdateSecurityClassification_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassification !== null && this.securityClassification !== undefined) {
      output.writeFieldBegin('securityClassification', Thrift.Type.STRUCT, 2);
      this.securityClassification.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_createOrUpdateSecurityClassification_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new SecurityClassification(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new SecurityClassification();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_createOrUpdateSecurityClassification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassification_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationId !== undefined && args.securityClassificationId !== null) {
        this.securityClassificationId = args.securityClassificationId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.securityClassificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassification_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationId !== null && this.securityClassificationId !== undefined) {
      output.writeFieldBegin('securityClassificationId', Thrift.Type.STRING, 2);
      output.writeString(this.securityClassificationId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassification_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassification_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToUserGroups_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationIds = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationIds !== undefined && args.securityClassificationIds !== null) {
        this.securityClassificationIds = Thrift.copyList(args.securityClassificationIds, [null]);
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationIds = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = input.readString().value;
            this.securityClassificationIds.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp310 = input.readListBegin();
          const _size9 = _rtmp310.size || 0;
          for (let _i11 = 0; _i11 < _size9; ++_i11) {
            let elem12 = null;
            elem12 = new UserOrGroup();
            elem12.read(input);
            this.userOrGroups.push(elem12);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToUserGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationIds !== null && this.securityClassificationIds !== undefined) {
      output.writeFieldBegin('securityClassificationIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationIds.length);
      for (let iter13 in this.securityClassificationIds) {
        if (this.securityClassificationIds.hasOwnProperty(iter13)) {
          iter13 = this.securityClassificationIds[iter13];
          output.writeString(iter13);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter14 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter14)) {
          iter14 = this.userOrGroups[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToUserGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToUserGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromUserGroups_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationIds = null;
    this.userOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationIds !== undefined && args.securityClassificationIds !== null) {
        this.securityClassificationIds = Thrift.copyList(args.securityClassificationIds, [null]);
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationIds = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = input.readString().value;
            this.securityClassificationIds.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = new UserOrGroup();
            elem22.read(input);
            this.userOrGroups.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromUserGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationIds !== null && this.securityClassificationIds !== undefined) {
      output.writeFieldBegin('securityClassificationIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationIds.length);
      for (let iter23 in this.securityClassificationIds) {
        if (this.securityClassificationIds.hasOwnProperty(iter23)) {
          iter23 = this.securityClassificationIds[iter23];
          output.writeString(iter23);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter24 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter24)) {
          iter24 = this.userOrGroups[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromUserGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromUserGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_args = class {
  constructor(args) {
    this.token = null;
    this.type = null;
    this.userOrGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 2);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 3);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SecurityClassification]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new SecurityClassification();
            elem28.read(input);
            this.success.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter29 in this.success) {
        if (this.success.hasOwnProperty(iter29)) {
          iter29 = this.success[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationByPatternId_args = class {
  constructor(args) {
    this.token = null;
    this.patternId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationByPatternId_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationByPatternId_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SecurityClassification]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new SecurityClassification();
            elem33.read(input);
            this.success.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationByPatternId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter34 in this.success) {
        if (this.success.hasOwnProperty(iter34)) {
          iter34 = this.success[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationByDocumentId_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationByDocumentId_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationByDocumentId_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SecurityClassification]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new SecurityClassification();
            elem38.read(input);
            this.success.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationByDocumentId_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter39 in this.success) {
        if (this.success.hasOwnProperty(iter39)) {
          iter39 = this.success[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToDocPattern_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationsId = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = input.readString().value;
            this.securityClassificationsId.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToDocPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter44 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter44)) {
          iter44 = this.securityClassificationsId[iter44];
          output.writeString(iter44);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 3);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToDocPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToDocPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromDocPattern_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationsId = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp346 = input.readListBegin();
          const _size45 = _rtmp346.size || 0;
          for (let _i47 = 0; _i47 < _size45; ++_i47) {
            let elem48 = null;
            elem48 = input.readString().value;
            this.securityClassificationsId.push(elem48);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromDocPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter49 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter49)) {
          iter49 = this.securityClassificationsId[iter49];
          output.writeString(iter49);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 3);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromDocPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromDocPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationsId = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp351 = input.readListBegin();
          const _size50 = _rtmp351.size || 0;
          for (let _i52 = 0; _i52 < _size50; ++_i52) {
            let elem53 = null;
            elem53 = input.readString().value;
            this.securityClassificationsId.push(elem53);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter54 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter54)) {
          iter54 = this.securityClassificationsId[iter54];
          output.writeString(iter54);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_changeSecurityClassificationsForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.addedSecurityClassificationsId = null;
    this.removedSecurityClassificationsId = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.addedSecurityClassificationsId !== undefined && args.addedSecurityClassificationsId !== null) {
        this.addedSecurityClassificationsId = Thrift.copyList(args.addedSecurityClassificationsId, [null]);
      }
      if (args.removedSecurityClassificationsId !== undefined && args.removedSecurityClassificationsId !== null) {
        this.removedSecurityClassificationsId = Thrift.copyList(args.removedSecurityClassificationsId, [null]);
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.addedSecurityClassificationsId = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = input.readString().value;
            this.addedSecurityClassificationsId.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.removedSecurityClassificationsId = [];
          const _rtmp360 = input.readListBegin();
          const _size59 = _rtmp360.size || 0;
          for (let _i61 = 0; _i61 < _size59; ++_i61) {
            let elem62 = null;
            elem62 = input.readString().value;
            this.removedSecurityClassificationsId.push(elem62);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_changeSecurityClassificationsForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.addedSecurityClassificationsId !== null && this.addedSecurityClassificationsId !== undefined) {
      output.writeFieldBegin('addedSecurityClassificationsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.addedSecurityClassificationsId.length);
      for (let iter63 in this.addedSecurityClassificationsId) {
        if (this.addedSecurityClassificationsId.hasOwnProperty(iter63)) {
          iter63 = this.addedSecurityClassificationsId[iter63];
          output.writeString(iter63);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedSecurityClassificationsId !== null && this.removedSecurityClassificationsId !== undefined) {
      output.writeFieldBegin('removedSecurityClassificationsId', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.removedSecurityClassificationsId.length);
      for (let iter64 in this.removedSecurityClassificationsId) {
        if (this.removedSecurityClassificationsId.hasOwnProperty(iter64)) {
          iter64 = this.removedSecurityClassificationsId[iter64];
          output.writeString(iter64);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 4);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_changeSecurityClassificationsForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_changeSecurityClassificationsForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromDocument_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationsId = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp366 = input.readListBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = input.readString().value;
            this.securityClassificationsId.push(elem68);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter69 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter69)) {
          iter69 = this.securityClassificationsId[iter69];
          output.writeString(iter69);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationsFromDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationsFromDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationDependencies_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationId !== undefined && args.securityClassificationId !== null) {
        this.securityClassificationId = args.securityClassificationId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.securityClassificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationDependencies_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationId !== null && this.securityClassificationId !== undefined) {
      output.writeFieldBegin('securityClassificationId', Thrift.Type.STRING, 2);
      output.writeString(this.securityClassificationId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_getAllSecurityClassificationDependencies_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [SecurityClassification]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = new SecurityClassification();
            elem73.read(input);
            this.success.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_getAllSecurityClassificationDependencies_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter74 in this.success) {
        if (this.success.hasOwnProperty(iter74)) {
          iter74 = this.success[iter74];
          iter74.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationDependencies_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationId = null;
    this.securityClassificationsId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationId !== undefined && args.securityClassificationId !== null) {
        this.securityClassificationId = args.securityClassificationId;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.securityClassificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp376 = input.readListBegin();
          const _size75 = _rtmp376.size || 0;
          for (let _i77 = 0; _i77 < _size75; ++_i77) {
            let elem78 = null;
            elem78 = input.readString().value;
            this.securityClassificationsId.push(elem78);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationDependencies_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationId !== null && this.securityClassificationId !== undefined) {
      output.writeFieldBegin('securityClassificationId', Thrift.Type.STRING, 2);
      output.writeString(this.securityClassificationId);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter79 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter79)) {
          iter79 = this.securityClassificationsId[iter79];
          output.writeString(iter79);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_addSecurityClassificationDependencies_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_addSecurityClassificationDependencies_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationDependencies_args = class {
  constructor(args) {
    this.token = null;
    this.securityClassificationId = null;
    this.securityClassificationsId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.securityClassificationId !== undefined && args.securityClassificationId !== null) {
        this.securityClassificationId = args.securityClassificationId;
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.securityClassificationId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.securityClassificationsId = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = input.readString().value;
            this.securityClassificationsId.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationDependencies_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.securityClassificationId !== null && this.securityClassificationId !== undefined) {
      output.writeFieldBegin('securityClassificationId', Thrift.Type.STRING, 2);
      output.writeString(this.securityClassificationId);
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter84 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter84)) {
          iter84 = this.securityClassificationsId[iter84];
          output.writeString(iter84);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationService_removeSecurityClassificationDependencies_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassificationService_removeSecurityClassificationDependencies_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassificationServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getAllSecurityClassification (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSecurityClassification(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSecurityClassification (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new SecurityClassificationService_getAllSecurityClassification_args(params);
    try {
      this.output.writeMessageBegin('getAllSecurityClassification', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSecurityClassification();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSecurityClassification () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getAllSecurityClassification_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSecurityClassification failed: unknown result';
  }

  getCountAllSecurityClassification (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllSecurityClassification(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllSecurityClassification (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new SecurityClassificationService_getCountAllSecurityClassification_args(params);
    try {
      this.output.writeMessageBegin('getCountAllSecurityClassification', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllSecurityClassification();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllSecurityClassification () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getCountAllSecurityClassification_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllSecurityClassification failed: unknown result';
  }

  createOrUpdateSecurityClassification (token, securityClassification) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateSecurityClassification(token, securityClassification, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateSecurityClassification (token, securityClassification, callback) {
    const params = {
      token: token,
      securityClassification: securityClassification
    };
    const args = new SecurityClassificationService_createOrUpdateSecurityClassification_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateSecurityClassification', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateSecurityClassification();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateSecurityClassification () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_createOrUpdateSecurityClassification_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateSecurityClassification failed: unknown result';
  }

  removeSecurityClassification (token, securityClassificationId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeSecurityClassification(token, securityClassificationId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeSecurityClassification (token, securityClassificationId, callback) {
    const params = {
      token: token,
      securityClassificationId: securityClassificationId
    };
    const args = new SecurityClassificationService_removeSecurityClassification_args(params);
    try {
      this.output.writeMessageBegin('removeSecurityClassification', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeSecurityClassification();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeSecurityClassification () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_removeSecurityClassification_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeSecurityClassification failed: unknown result';
  }

  addSecurityClassificationsToUserGroups (token, securityClassificationIds, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addSecurityClassificationsToUserGroups(token, securityClassificationIds, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addSecurityClassificationsToUserGroups (token, securityClassificationIds, userOrGroups, callback) {
    const params = {
      token: token,
      securityClassificationIds: securityClassificationIds,
      userOrGroups: userOrGroups
    };
    const args = new SecurityClassificationService_addSecurityClassificationsToUserGroups_args(params);
    try {
      this.output.writeMessageBegin('addSecurityClassificationsToUserGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addSecurityClassificationsToUserGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addSecurityClassificationsToUserGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_addSecurityClassificationsToUserGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addSecurityClassificationsToUserGroups failed: unknown result';
  }

  removeSecurityClassificationsFromUserGroups (token, securityClassificationIds, userOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeSecurityClassificationsFromUserGroups(token, securityClassificationIds, userOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeSecurityClassificationsFromUserGroups (token, securityClassificationIds, userOrGroups, callback) {
    const params = {
      token: token,
      securityClassificationIds: securityClassificationIds,
      userOrGroups: userOrGroups
    };
    const args = new SecurityClassificationService_removeSecurityClassificationsFromUserGroups_args(params);
    try {
      this.output.writeMessageBegin('removeSecurityClassificationsFromUserGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeSecurityClassificationsFromUserGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeSecurityClassificationsFromUserGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_removeSecurityClassificationsFromUserGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeSecurityClassificationsFromUserGroups failed: unknown result';
  }

  getAllSecurityClassificationsByUserOrGroup (token, type, userOrGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSecurityClassificationsByUserOrGroup(token, type, userOrGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSecurityClassificationsByUserOrGroup (token, type, userOrGroupId, filter, callback) {
    const params = {
      token: token,
      type: type,
      userOrGroupId: userOrGroupId,
      filter: filter
    };
    const args = new SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_args(params);
    try {
      this.output.writeMessageBegin('getAllSecurityClassificationsByUserOrGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSecurityClassificationsByUserOrGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSecurityClassificationsByUserOrGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getAllSecurityClassificationsByUserOrGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSecurityClassificationsByUserOrGroup failed: unknown result';
  }

  getAllSecurityClassificationByPatternId (token, patternId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSecurityClassificationByPatternId(token, patternId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSecurityClassificationByPatternId (token, patternId, filter, callback) {
    const params = {
      token: token,
      patternId: patternId,
      filter: filter
    };
    const args = new SecurityClassificationService_getAllSecurityClassificationByPatternId_args(params);
    try {
      this.output.writeMessageBegin('getAllSecurityClassificationByPatternId', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSecurityClassificationByPatternId();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSecurityClassificationByPatternId () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getAllSecurityClassificationByPatternId_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSecurityClassificationByPatternId failed: unknown result';
  }

  getAllSecurityClassificationByDocumentId (token, documentId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSecurityClassificationByDocumentId(token, documentId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSecurityClassificationByDocumentId (token, documentId, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter
    };
    const args = new SecurityClassificationService_getAllSecurityClassificationByDocumentId_args(params);
    try {
      this.output.writeMessageBegin('getAllSecurityClassificationByDocumentId', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSecurityClassificationByDocumentId();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSecurityClassificationByDocumentId () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getAllSecurityClassificationByDocumentId_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSecurityClassificationByDocumentId failed: unknown result';
  }

  addSecurityClassificationsToDocPattern (token, securityClassificationsId, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addSecurityClassificationsToDocPattern(token, securityClassificationsId, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addSecurityClassificationsToDocPattern (token, securityClassificationsId, docPatternId, callback) {
    const params = {
      token: token,
      securityClassificationsId: securityClassificationsId,
      docPatternId: docPatternId
    };
    const args = new SecurityClassificationService_addSecurityClassificationsToDocPattern_args(params);
    try {
      this.output.writeMessageBegin('addSecurityClassificationsToDocPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addSecurityClassificationsToDocPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addSecurityClassificationsToDocPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_addSecurityClassificationsToDocPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addSecurityClassificationsToDocPattern failed: unknown result';
  }

  removeSecurityClassificationsFromDocPattern (token, securityClassificationsId, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeSecurityClassificationsFromDocPattern(token, securityClassificationsId, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeSecurityClassificationsFromDocPattern (token, securityClassificationsId, docPatternId, callback) {
    const params = {
      token: token,
      securityClassificationsId: securityClassificationsId,
      docPatternId: docPatternId
    };
    const args = new SecurityClassificationService_removeSecurityClassificationsFromDocPattern_args(params);
    try {
      this.output.writeMessageBegin('removeSecurityClassificationsFromDocPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeSecurityClassificationsFromDocPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeSecurityClassificationsFromDocPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_removeSecurityClassificationsFromDocPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeSecurityClassificationsFromDocPattern failed: unknown result';
  }

  addSecurityClassificationsToDocument (token, securityClassificationsId, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addSecurityClassificationsToDocument(token, securityClassificationsId, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addSecurityClassificationsToDocument (token, securityClassificationsId, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      securityClassificationsId: securityClassificationsId,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new SecurityClassificationService_addSecurityClassificationsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addSecurityClassificationsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addSecurityClassificationsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addSecurityClassificationsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_addSecurityClassificationsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addSecurityClassificationsToDocument failed: unknown result';
  }

  changeSecurityClassificationsForDocument (token, addedSecurityClassificationsId, removedSecurityClassificationsId, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeSecurityClassificationsForDocument(token, addedSecurityClassificationsId, removedSecurityClassificationsId, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeSecurityClassificationsForDocument (token, addedSecurityClassificationsId, removedSecurityClassificationsId, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      addedSecurityClassificationsId: addedSecurityClassificationsId,
      removedSecurityClassificationsId: removedSecurityClassificationsId,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new SecurityClassificationService_changeSecurityClassificationsForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeSecurityClassificationsForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeSecurityClassificationsForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeSecurityClassificationsForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_changeSecurityClassificationsForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeSecurityClassificationsForDocument failed: unknown result';
  }

  removeSecurityClassificationsFromDocument (token, securityClassificationsId, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeSecurityClassificationsFromDocument(token, securityClassificationsId, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeSecurityClassificationsFromDocument (token, securityClassificationsId, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      securityClassificationsId: securityClassificationsId,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new SecurityClassificationService_removeSecurityClassificationsFromDocument_args(params);
    try {
      this.output.writeMessageBegin('removeSecurityClassificationsFromDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeSecurityClassificationsFromDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeSecurityClassificationsFromDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_removeSecurityClassificationsFromDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeSecurityClassificationsFromDocument failed: unknown result';
  }

  getAllSecurityClassificationDependencies (token, securityClassificationId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllSecurityClassificationDependencies(token, securityClassificationId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllSecurityClassificationDependencies (token, securityClassificationId, filter, callback) {
    const params = {
      token: token,
      securityClassificationId: securityClassificationId,
      filter: filter
    };
    const args = new SecurityClassificationService_getAllSecurityClassificationDependencies_args(params);
    try {
      this.output.writeMessageBegin('getAllSecurityClassificationDependencies', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllSecurityClassificationDependencies();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllSecurityClassificationDependencies () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_getAllSecurityClassificationDependencies_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllSecurityClassificationDependencies failed: unknown result';
  }

  addSecurityClassificationDependencies (token, securityClassificationId, securityClassificationsId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addSecurityClassificationDependencies(token, securityClassificationId, securityClassificationsId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addSecurityClassificationDependencies (token, securityClassificationId, securityClassificationsId, callback) {
    const params = {
      token: token,
      securityClassificationId: securityClassificationId,
      securityClassificationsId: securityClassificationsId
    };
    const args = new SecurityClassificationService_addSecurityClassificationDependencies_args(params);
    try {
      this.output.writeMessageBegin('addSecurityClassificationDependencies', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addSecurityClassificationDependencies();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addSecurityClassificationDependencies () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_addSecurityClassificationDependencies_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addSecurityClassificationDependencies failed: unknown result';
  }

  removeSecurityClassificationDependencies (token, securityClassificationId, securityClassificationsId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeSecurityClassificationDependencies(token, securityClassificationId, securityClassificationsId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeSecurityClassificationDependencies (token, securityClassificationId, securityClassificationsId, callback) {
    const params = {
      token: token,
      securityClassificationId: securityClassificationId,
      securityClassificationsId: securityClassificationsId
    };
    const args = new SecurityClassificationService_removeSecurityClassificationDependencies_args(params);
    try {
      this.output.writeMessageBegin('removeSecurityClassificationDependencies', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeSecurityClassificationDependencies();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeSecurityClassificationDependencies () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new SecurityClassificationService_removeSecurityClassificationDependencies_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeSecurityClassificationDependencies failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

UserManagementService_getUserOrGroup_args = class {
  constructor(args) {
    this.token = null;
    this.userOrGroupId = null;
    this.userOrGroupType = null;
    this.userVersion = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.userOrGroupType !== undefined && args.userOrGroupType !== null) {
        this.userOrGroupType = args.userOrGroupType;
      }
      if (args.userVersion !== undefined && args.userVersion !== null) {
        this.userVersion = args.userVersion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.userOrGroupType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.userVersion = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserOrGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.userOrGroupType !== null && this.userOrGroupType !== undefined) {
      output.writeFieldBegin('userOrGroupType', Thrift.Type.I32, 3);
      output.writeI32(this.userOrGroupType);
      output.writeFieldEnd();
    }
    if (this.userVersion !== null && this.userVersion !== undefined) {
      output.writeFieldBegin('userVersion', Thrift.Type.STRING, 4);
      output.writeString(this.userVersion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserOrGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new UserOrGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new UserOrGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserOrGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsersAndGroups_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsersAndGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsersAndGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new UserOrGroup();
            elem13.read(input);
            this.success.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsersAndGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter14 in this.success) {
        if (this.success.hasOwnProperty(iter14)) {
          iter14 = this.success[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsersAndGroups_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsersAndGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsersAndGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsersAndGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsersByGroup_args = class {
  constructor(args) {
    this.token = null;
    this.groupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsersByGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsersByGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new UserOrGroup();
            elem18.read(input);
            this.success.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsersByGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter19 in this.success) {
        if (this.success.hasOwnProperty(iter19)) {
          iter19 = this.success[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsersByGroup_args = class {
  constructor(args) {
    this.token = null;
    this.groupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsersByGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsersByGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsersByGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsers_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUsers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new UserOrGroup();
            elem23.read(input);
            this.success.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUsers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter24 in this.success) {
        if (this.success.hasOwnProperty(iter24)) {
          iter24 = this.success[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsers_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUsers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUsers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllGroups_args = class {
  constructor(args) {
    this.token = null;
    this.groupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new UserOrGroup();
            elem28.read(input);
            this.success.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter29 in this.success) {
        if (this.success.hasOwnProperty(iter29)) {
          iter29 = this.success[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllGroups_args = class {
  constructor(args) {
    this.token = null;
    this.groupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupId !== undefined && args.groupId !== null) {
        this.groupId = args.groupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.groupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupId !== null && this.groupId !== undefined) {
      output.writeFieldBegin('groupId', Thrift.Type.STRING, 2);
      output.writeString(this.groupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getRolesByUserOrGroup_args = class {
  constructor(args) {
    this.token = null;
    this.type = null;
    this.userOrGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getRolesByUserOrGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 2);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 3);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getRolesByUserOrGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp331 = input.readSetBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = input.readString().value;
            this.success.push(elem33);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getRolesByUserOrGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRING, this.success.length);
      for (let iter34 in this.success) {
        if (this.success.hasOwnProperty(iter34)) {
          iter34 = this.success[iter34];
          output.writeString(iter34);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserOrGroupsByRole_args = class {
  constructor(args) {
    this.token = null;
    this.role = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.role !== undefined && args.role !== null) {
        this.role = args.role;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.role = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserOrGroupsByRole_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.role !== null && this.role !== undefined) {
      output.writeFieldBegin('role', Thrift.Type.STRING, 2);
      output.writeString(this.role);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserOrGroupsByRole_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new UserOrGroup();
            elem38.read(input);
            this.success.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserOrGroupsByRole_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter39 in this.success) {
        if (this.success.hasOwnProperty(iter39)) {
          iter39 = this.success[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrUpdateUserGroup_args = class {
  constructor(args) {
    this.token = null;
    this.userGroup = null;
    this.accountId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userGroup !== undefined && args.userGroup !== null) {
        this.userGroup = new UserOrGroup(args.userGroup);
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.userGroup = new UserOrGroup();
          this.userGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrUpdateUserGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userGroup !== null && this.userGroup !== undefined) {
      output.writeFieldBegin('userGroup', Thrift.Type.STRUCT, 2);
      this.userGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrUpdateUserGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new UserOrGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new UserOrGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrUpdateUserGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_addUsersToGroups_args = class {
  constructor(args) {
    this.token = null;
    this.groupsId = null;
    this.usersId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupsId !== undefined && args.groupsId !== null) {
        this.groupsId = Thrift.copyList(args.groupsId, [null]);
      }
      if (args.usersId !== undefined && args.usersId !== null) {
        this.usersId = Thrift.copyList(args.usersId, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupsId = [];
          const _rtmp341 = input.readListBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            let elem43 = null;
            elem43 = input.readString().value;
            this.groupsId.push(elem43);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersId = [];
          const _rtmp345 = input.readListBegin();
          const _size44 = _rtmp345.size || 0;
          for (let _i46 = 0; _i46 < _size44; ++_i46) {
            let elem47 = null;
            elem47 = input.readString().value;
            this.usersId.push(elem47);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_addUsersToGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupsId !== null && this.groupsId !== undefined) {
      output.writeFieldBegin('groupsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupsId.length);
      for (let iter48 in this.groupsId) {
        if (this.groupsId.hasOwnProperty(iter48)) {
          iter48 = this.groupsId[iter48];
          output.writeString(iter48);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.usersId !== null && this.usersId !== undefined) {
      output.writeFieldBegin('usersId', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.usersId.length);
      for (let iter49 in this.usersId) {
        if (this.usersId.hasOwnProperty(iter49)) {
          iter49 = this.usersId[iter49];
          output.writeString(iter49);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_addUsersToGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_addUsersToGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrUpdateUser_args = class {
  constructor(args) {
    this.token = null;
    this.user = null;
    this.login = null;
    this.password = null;
    this.accountGroupId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrUpdateUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 2);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 3);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 4);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 5);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrUpdateUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new UserOrGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new UserOrGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrUpdateUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeClient_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.reasonForRemoval = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.reasonForRemoval !== undefined && args.reasonForRemoval !== null) {
        this.reasonForRemoval = args.reasonForRemoval;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reasonForRemoval = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeClient_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.reasonForRemoval !== null && this.reasonForRemoval !== undefined) {
      output.writeFieldBegin('reasonForRemoval', Thrift.Type.STRING, 3);
      output.writeString(this.reasonForRemoval);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeClient_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeClient_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeUsersFromGroups_args = class {
  constructor(args) {
    this.token = null;
    this.groupsId = null;
    this.usersId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupsId !== undefined && args.groupsId !== null) {
        this.groupsId = Thrift.copyList(args.groupsId, [null]);
      }
      if (args.usersId !== undefined && args.usersId !== null) {
        this.usersId = Thrift.copyList(args.usersId, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupsId = [];
          const _rtmp351 = input.readListBegin();
          const _size50 = _rtmp351.size || 0;
          for (let _i52 = 0; _i52 < _size50; ++_i52) {
            let elem53 = null;
            elem53 = input.readString().value;
            this.groupsId.push(elem53);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersId = [];
          const _rtmp355 = input.readListBegin();
          const _size54 = _rtmp355.size || 0;
          for (let _i56 = 0; _i56 < _size54; ++_i56) {
            let elem57 = null;
            elem57 = input.readString().value;
            this.usersId.push(elem57);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeUsersFromGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupsId !== null && this.groupsId !== undefined) {
      output.writeFieldBegin('groupsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupsId.length);
      for (let iter58 in this.groupsId) {
        if (this.groupsId.hasOwnProperty(iter58)) {
          iter58 = this.groupsId[iter58];
          output.writeString(iter58);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.usersId !== null && this.usersId !== undefined) {
      output.writeFieldBegin('usersId', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.usersId.length);
      for (let iter59 in this.usersId) {
        if (this.usersId.hasOwnProperty(iter59)) {
          iter59 = this.usersId[iter59];
          output.writeString(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeUsersFromGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeUsersFromGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeGroup_args = class {
  constructor(args) {
    this.token = null;
    this.groupsId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.groupsId !== undefined && args.groupsId !== null) {
        this.groupsId = Thrift.copyList(args.groupsId, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.groupsId = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = input.readString().value;
            this.groupsId.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeGroup_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.groupsId !== null && this.groupsId !== undefined) {
      output.writeFieldBegin('groupsId', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.groupsId.length);
      for (let iter64 in this.groupsId) {
        if (this.groupsId.hasOwnProperty(iter64)) {
          iter64 = this.groupsId[iter64];
          output.writeString(iter64);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_removeGroup_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_removeGroup_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_blockUsers_args = class {
  constructor(args) {
    this.token = null;
    this.userIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp366 = input.readListBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = input.readString().value;
            this.userIds.push(elem68);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_blockUsers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter69 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter69)) {
          iter69 = this.userIds[iter69];
          output.writeString(iter69);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_blockUsers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_blockUsers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_unBlockUsers_args = class {
  constructor(args) {
    this.token = null;
    this.userIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userIds !== undefined && args.userIds !== null) {
        this.userIds = Thrift.copyList(args.userIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.userIds = [];
          const _rtmp371 = input.readListBegin();
          const _size70 = _rtmp371.size || 0;
          for (let _i72 = 0; _i72 < _size70; ++_i72) {
            let elem73 = null;
            elem73 = input.readString().value;
            this.userIds.push(elem73);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_unBlockUsers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userIds !== null && this.userIds !== undefined) {
      output.writeFieldBegin('userIds', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.userIds.length);
      for (let iter74 in this.userIds) {
        if (this.userIds.hasOwnProperty(iter74)) {
          iter74 = this.userIds[iter74];
          output.writeString(iter74);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_unBlockUsers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_unBlockUsers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllExistingRoles_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllExistingRoles_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllExistingRoles_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp376 = input.readListBegin();
          const _size75 = _rtmp376.size || 0;
          for (let _i77 = 0; _i77 < _size75; ++_i77) {
            let elem78 = null;
            elem78 = input.readString().value;
            this.success.push(elem78);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllExistingRoles_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRING, this.success.length);
      for (let iter79 in this.success) {
        if (this.success.hasOwnProperty(iter79)) {
          iter79 = this.success[iter79];
          output.writeString(iter79);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_addRolesToUsersOrGroups_args = class {
  constructor(args) {
    this.token = null;
    this.usersOrGroups = null;
    this.roles = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp381 = input.readListBegin();
          const _size80 = _rtmp381.size || 0;
          for (let _i82 = 0; _i82 < _size80; ++_i82) {
            let elem83 = null;
            elem83 = new UserOrGroup();
            elem83.read(input);
            this.usersOrGroups.push(elem83);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.roles = [];
          const _rtmp385 = input.readListBegin();
          const _size84 = _rtmp385.size || 0;
          for (let _i86 = 0; _i86 < _size84; ++_i86) {
            let elem87 = null;
            elem87 = input.readString().value;
            this.roles.push(elem87);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_addRolesToUsersOrGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter88 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter88)) {
          iter88 = this.usersOrGroups[iter88];
          iter88.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.roles.length);
      for (let iter89 in this.roles) {
        if (this.roles.hasOwnProperty(iter89)) {
          iter89 = this.roles[iter89];
          output.writeString(iter89);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_addRolesToUsersOrGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_addRolesToUsersOrGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_revokeRolesFromUsersOrGroups_args = class {
  constructor(args) {
    this.token = null;
    this.usersOrGroups = null;
    this.roles = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp391 = input.readListBegin();
          const _size90 = _rtmp391.size || 0;
          for (let _i92 = 0; _i92 < _size90; ++_i92) {
            let elem93 = null;
            elem93 = new UserOrGroup();
            elem93.read(input);
            this.usersOrGroups.push(elem93);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.roles = [];
          const _rtmp395 = input.readListBegin();
          const _size94 = _rtmp395.size || 0;
          for (let _i96 = 0; _i96 < _size94; ++_i96) {
            let elem97 = null;
            elem97 = input.readString().value;
            this.roles.push(elem97);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_revokeRolesFromUsersOrGroups_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter98 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter98)) {
          iter98 = this.usersOrGroups[iter98];
          iter98.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.roles.length);
      for (let iter99 in this.roles) {
        if (this.roles.hasOwnProperty(iter99)) {
          iter99 = this.roles[iter99];
          output.writeString(iter99);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_revokeRolesFromUsersOrGroups_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_revokeRolesFromUsersOrGroups_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getRolesByUser_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getRolesByUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getRolesByUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [RoleScHelper]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3101 = input.readMapBegin();
          const _size100 = _rtmp3101.size || 0;
          for (let _i102 = 0; _i102 < _size100; ++_i102) {
            if (_i102 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key103 = null;
            let val104 = null;
            key103 = input.readString().value;
            val104 = new RoleScHelper();
            val104.read(input);
            this.success[key103] = val104;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getRolesByUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter105 in this.success) {
        if (this.success.hasOwnProperty(kiter105)) {
          let viter106 = this.success[kiter105];
          output.writeString(kiter105);
          viter106.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_loadUserPublicKey_args = class {
  constructor(args) {
    this.token = null;
    this.publicKey = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = args.publicKey;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.publicKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_loadUserPublicKey_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRING, 2);
      output.writeString(this.publicKey);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 3);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_loadUserPublicKey_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_loadUserPublicKey_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUserPublicKeyInfo_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUserPublicKeyInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllUserPublicKeyInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserKeyData]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3108 = input.readListBegin();
          const _size107 = _rtmp3108.size || 0;
          for (let _i109 = 0; _i109 < _size107; ++_i109) {
            let elem110 = null;
            elem110 = new UserKeyData();
            elem110.read(input);
            this.success.push(elem110);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllUserPublicKeyInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter111 in this.success) {
        if (this.success.hasOwnProperty(iter111)) {
          iter111 = this.success[iter111];
          iter111.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUserPublicKeyInfo_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUserPublicKeyInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getCountAllUserPublicKeyInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getCountAllUserPublicKeyInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_changeClientDelegateDetailsInfo_args = class {
  constructor(args) {
    this.token = null;
    this.clientDelegateInfo = null;
    this.listDetailsToAdd = null;
    this.listDetailIdsToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.clientDelegateInfo !== undefined && args.clientDelegateInfo !== null) {
        this.clientDelegateInfo = new ClientDelegateInfo(args.clientDelegateInfo);
      }
      if (args.listDetailsToAdd !== undefined && args.listDetailsToAdd !== null) {
        this.listDetailsToAdd = Thrift.copyList(args.listDetailsToAdd, [ClientDelegateDetails]);
      }
      if (args.listDetailIdsToRemove !== undefined && args.listDetailIdsToRemove !== null) {
        this.listDetailIdsToRemove = Thrift.copyList(args.listDetailIdsToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.clientDelegateInfo = new ClientDelegateInfo();
          this.clientDelegateInfo.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.listDetailsToAdd = [];
          const _rtmp3113 = input.readListBegin();
          const _size112 = _rtmp3113.size || 0;
          for (let _i114 = 0; _i114 < _size112; ++_i114) {
            let elem115 = null;
            elem115 = new ClientDelegateDetails();
            elem115.read(input);
            this.listDetailsToAdd.push(elem115);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.listDetailIdsToRemove = [];
          const _rtmp3117 = input.readListBegin();
          const _size116 = _rtmp3117.size || 0;
          for (let _i118 = 0; _i118 < _size116; ++_i118) {
            let elem119 = null;
            elem119 = input.readString().value;
            this.listDetailIdsToRemove.push(elem119);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_changeClientDelegateDetailsInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.clientDelegateInfo !== null && this.clientDelegateInfo !== undefined) {
      output.writeFieldBegin('clientDelegateInfo', Thrift.Type.STRUCT, 2);
      this.clientDelegateInfo.write(output);
      output.writeFieldEnd();
    }
    if (this.listDetailsToAdd !== null && this.listDetailsToAdd !== undefined) {
      output.writeFieldBegin('listDetailsToAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.listDetailsToAdd.length);
      for (let iter120 in this.listDetailsToAdd) {
        if (this.listDetailsToAdd.hasOwnProperty(iter120)) {
          iter120 = this.listDetailsToAdd[iter120];
          iter120.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.listDetailIdsToRemove !== null && this.listDetailIdsToRemove !== undefined) {
      output.writeFieldBegin('listDetailIdsToRemove', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.listDetailIdsToRemove.length);
      for (let iter121 in this.listDetailIdsToRemove) {
        if (this.listDetailIdsToRemove.hasOwnProperty(iter121)) {
          iter121 = this.listDetailIdsToRemove[iter121];
          output.writeString(iter121);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_changeClientDelegateDetailsInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ClientDelegateDetails]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3123 = input.readListBegin();
          const _size122 = _rtmp3123.size || 0;
          for (let _i124 = 0; _i124 < _size122; ++_i124) {
            let elem125 = null;
            elem125 = new ClientDelegateDetails();
            elem125.read(input);
            this.success.push(elem125);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_changeClientDelegateDetailsInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter126 in this.success) {
        if (this.success.hasOwnProperty(iter126)) {
          iter126 = this.success[iter126];
          iter126.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_revokeClientDelegates_args = class {
  constructor(args) {
    this.token = null;
    this.clientDelegateId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.clientDelegateId !== undefined && args.clientDelegateId !== null) {
        this.clientDelegateId = args.clientDelegateId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.clientDelegateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_revokeClientDelegates_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.clientDelegateId !== null && this.clientDelegateId !== undefined) {
      output.writeFieldBegin('clientDelegateId', Thrift.Type.STRING, 2);
      output.writeString(this.clientDelegateId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_revokeClientDelegates_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_revokeClientDelegates_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientDelegatesInfoList_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientDelegatesInfoList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientDelegatesInfoList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ClientDelegateInfo]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3128 = input.readListBegin();
          const _size127 = _rtmp3128.size || 0;
          for (let _i129 = 0; _i129 < _size127; ++_i129) {
            let elem130 = null;
            elem130 = new ClientDelegateInfo();
            elem130.read(input);
            this.success.push(elem130);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientDelegatesInfoList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter131 in this.success) {
        if (this.success.hasOwnProperty(iter131)) {
          iter131 = this.success[iter131];
          iter131.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientDelegatesDetails_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientDelegatesDetails_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientDelegatesDetails_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ClientDelegateDetails]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3133 = input.readListBegin();
          const _size132 = _rtmp3133.size || 0;
          for (let _i134 = 0; _i134 < _size132; ++_i134) {
            let elem135 = null;
            elem135 = new ClientDelegateDetails();
            elem135.read(input);
            this.success.push(elem135);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientDelegatesDetails_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter136 in this.success) {
        if (this.success.hasOwnProperty(iter136)) {
          iter136 = this.success[iter136];
          iter136.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getClientDelegateDetails_args = class {
  constructor(args) {
    this.token = null;
    this.clientDelegateInfoId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.clientDelegateInfoId !== undefined && args.clientDelegateInfoId !== null) {
        this.clientDelegateInfoId = args.clientDelegateInfoId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.clientDelegateInfoId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getClientDelegateDetails_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.clientDelegateInfoId !== null && this.clientDelegateInfoId !== undefined) {
      output.writeFieldBegin('clientDelegateInfoId', Thrift.Type.STRING, 2);
      output.writeString(this.clientDelegateInfoId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getClientDelegateDetails_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ClientDelegateDetails]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3138 = input.readListBegin();
          const _size137 = _rtmp3138.size || 0;
          for (let _i139 = 0; _i139 < _size137; ++_i139) {
            let elem140 = null;
            elem140 = new ClientDelegateDetails();
            elem140.read(input);
            this.success.push(elem140);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getClientDelegateDetails_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter141 in this.success) {
        if (this.success.hasOwnProperty(iter141)) {
          iter141 = this.success[iter141];
          iter141.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientsForDelegate_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.reverse = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.reverse !== undefined && args.reverse !== null) {
        this.reverse = args.reverse;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.reverse = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientsForDelegate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.reverse !== null && this.reverse !== undefined) {
      output.writeFieldBegin('reverse', Thrift.Type.BOOL, 3);
      output.writeBool(this.reverse);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 4);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllClientsForDelegate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3143 = input.readListBegin();
          const _size142 = _rtmp3143.size || 0;
          for (let _i144 = 0; _i144 < _size142; ++_i144) {
            let elem145 = null;
            elem145 = new UserOrGroup();
            elem145.read(input);
            this.success.push(elem145);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllClientsForDelegate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter146 in this.success) {
        if (this.success.hasOwnProperty(iter146)) {
          iter146 = this.success[iter146];
          iter146.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllNotificationsForDelegate_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllNotificationsForDelegate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAllNotificationsForDelegate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3148 = input.readMapBegin();
          const _size147 = _rtmp3148.size || 0;
          for (let _i149 = 0; _i149 < _size147; ++_i149) {
            if (_i149 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key150 = null;
            let val151 = null;
            key150 = input.readString().value;
            val151 = input.readI32().value;
            this.success[key150] = val151;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAllNotificationsForDelegate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter152 in this.success) {
        if (this.success.hasOwnProperty(kiter152)) {
          let viter153 = this.success[kiter152];
          output.writeString(kiter152);
          output.writeI32(viter153);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Account]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3155 = input.readListBegin();
          const _size154 = _rtmp3155.size || 0;
          for (let _i156 = 0; _i156 < _size154; ++_i156) {
            let elem157 = null;
            elem157 = new Account();
            elem157.read(input);
            this.success.push(elem157);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter158 in this.success) {
        if (this.success.hasOwnProperty(iter158)) {
          iter158 = this.success[iter158];
          iter158.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getSecurityClassificationsByUser_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getSecurityClassificationsByUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getSecurityClassificationsByUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [RoleScHelper]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3160 = input.readMapBegin();
          const _size159 = _rtmp3160.size || 0;
          for (let _i161 = 0; _i161 < _size159; ++_i161) {
            if (_i161 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key162 = null;
            let val163 = null;
            key162 = input.readString().value;
            val163 = new RoleScHelper();
            val163.read(input);
            this.success[key162] = val163;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getSecurityClassificationsByUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.success));
      for (let kiter164 in this.success) {
        if (this.success.hasOwnProperty(kiter164)) {
          let viter165 = this.success[kiter164];
          output.writeString(kiter164);
          viter165.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserChief_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    this.level = null;
    this.userTypes = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.level !== undefined && args.level !== null) {
        this.level = args.level;
      }
      if (args.userTypes !== undefined && args.userTypes !== null) {
        this.userTypes = Thrift.copyList(args.userTypes, [null]);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.level = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.SET) {
          this.userTypes = [];
          const _rtmp3167 = input.readSetBegin();
          const _size166 = _rtmp3167.size || 0;
          for (let _i168 = 0; _i168 < _size166; ++_i168) {
            let elem169 = null;
            elem169 = input.readI32().value;
            this.userTypes.push(elem169);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserChief_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.level !== null && this.level !== undefined) {
      output.writeFieldBegin('level', Thrift.Type.I32, 3);
      output.writeI32(this.level);
      output.writeFieldEnd();
    }
    if (this.userTypes !== null && this.userTypes !== undefined) {
      output.writeFieldBegin('userTypes', Thrift.Type.SET, 4);
      output.writeSetBegin(Thrift.Type.I32, this.userTypes.length);
      for (let iter170 in this.userTypes) {
        if (this.userTypes.hasOwnProperty(iter170)) {
          iter170 = this.userTypes[iter170];
          output.writeI32(iter170);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserChief_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3172 = input.readListBegin();
          const _size171 = _rtmp3172.size || 0;
          for (let _i173 = 0; _i173 < _size171; ++_i173) {
            let elem174 = null;
            elem174 = new UserOrGroup();
            elem174.read(input);
            this.success.push(elem174);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserChief_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter175 in this.success) {
        if (this.success.hasOwnProperty(iter175)) {
          iter175 = this.success[iter175];
          iter175.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_updateUserInfo_args = class {
  constructor(args) {
    this.token = null;
    this.user = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_updateUserInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 2);
      this.user.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_updateUserInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new UserOrGroup(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new UserOrGroup();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_updateUserInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserPreferences_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserPreferences_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_getUserPreferences_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new UserPreferences(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new UserPreferences();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_getUserPreferences_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_updateUserPreferences_args = class {
  constructor(args) {
    this.token = null;
    this.preferences = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.preferences !== undefined && args.preferences !== null) {
        this.preferences = new UserPreferences(args.preferences);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.preferences = new UserPreferences();
          this.preferences.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_updateUserPreferences_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.preferences !== null && this.preferences !== undefined) {
      output.writeFieldBegin('preferences', Thrift.Type.STRUCT, 2);
      this.preferences.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_updateUserPreferences_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_updateUserPreferences_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrRemoveFavoriteUsers_args = class {
  constructor(args) {
    this.token = null;
    this.userIdsToAdd = null;
    this.userIdsToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userIdsToAdd !== undefined && args.userIdsToAdd !== null) {
        this.userIdsToAdd = Thrift.copyList(args.userIdsToAdd, [null]);
      }
      if (args.userIdsToRemove !== undefined && args.userIdsToRemove !== null) {
        this.userIdsToRemove = Thrift.copyList(args.userIdsToRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.userIdsToAdd = [];
          const _rtmp3177 = input.readListBegin();
          const _size176 = _rtmp3177.size || 0;
          for (let _i178 = 0; _i178 < _size176; ++_i178) {
            let elem179 = null;
            elem179 = input.readString().value;
            this.userIdsToAdd.push(elem179);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.userIdsToRemove = [];
          const _rtmp3181 = input.readListBegin();
          const _size180 = _rtmp3181.size || 0;
          for (let _i182 = 0; _i182 < _size180; ++_i182) {
            let elem183 = null;
            elem183 = input.readString().value;
            this.userIdsToRemove.push(elem183);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrRemoveFavoriteUsers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userIdsToAdd !== null && this.userIdsToAdd !== undefined) {
      output.writeFieldBegin('userIdsToAdd', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.userIdsToAdd.length);
      for (let iter184 in this.userIdsToAdd) {
        if (this.userIdsToAdd.hasOwnProperty(iter184)) {
          iter184 = this.userIdsToAdd[iter184];
          output.writeString(iter184);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.userIdsToRemove !== null && this.userIdsToRemove !== undefined) {
      output.writeFieldBegin('userIdsToRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.userIdsToRemove.length);
      for (let iter185 in this.userIdsToRemove) {
        if (this.userIdsToRemove.hasOwnProperty(iter185)) {
          iter185 = this.userIdsToRemove[iter185];
          output.writeString(iter185);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementService_createOrRemoveFavoriteUsers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserManagementService_createOrRemoveFavoriteUsers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
UserManagementServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getUserOrGroup (token, userOrGroupId, userOrGroupType, userVersion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUserOrGroup(token, userOrGroupId, userOrGroupType, userVersion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUserOrGroup (token, userOrGroupId, userOrGroupType, userVersion, callback) {
    const params = {
      token: token,
      userOrGroupId: userOrGroupId,
      userOrGroupType: userOrGroupType,
      userVersion: userVersion
    };
    const args = new UserManagementService_getUserOrGroup_args(params);
    try {
      this.output.writeMessageBegin('getUserOrGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUserOrGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUserOrGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getUserOrGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUserOrGroup failed: unknown result';
  }

  getAllUsersAndGroups (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUsersAndGroups(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUsersAndGroups (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllUsersAndGroups_args(params);
    try {
      this.output.writeMessageBegin('getAllUsersAndGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUsersAndGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUsersAndGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllUsersAndGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUsersAndGroups failed: unknown result';
  }

  getCountAllUsersAndGroups (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUsersAndGroups(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUsersAndGroups (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getCountAllUsersAndGroups_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUsersAndGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUsersAndGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUsersAndGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getCountAllUsersAndGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUsersAndGroups failed: unknown result';
  }

  getAllUsersByGroup (token, groupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUsersByGroup(token, groupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUsersByGroup (token, groupId, filter, callback) {
    const params = {
      token: token,
      groupId: groupId,
      filter: filter
    };
    const args = new UserManagementService_getAllUsersByGroup_args(params);
    try {
      this.output.writeMessageBegin('getAllUsersByGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUsersByGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUsersByGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllUsersByGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUsersByGroup failed: unknown result';
  }

  getCountAllUsersByGroup (token, groupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUsersByGroup(token, groupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUsersByGroup (token, groupId, filter, callback) {
    const params = {
      token: token,
      groupId: groupId,
      filter: filter
    };
    const args = new UserManagementService_getCountAllUsersByGroup_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUsersByGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUsersByGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUsersByGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getCountAllUsersByGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUsersByGroup failed: unknown result';
  }

  getAllUsers (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUsers(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUsers (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllUsers_args(params);
    try {
      this.output.writeMessageBegin('getAllUsers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUsers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUsers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllUsers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUsers failed: unknown result';
  }

  getCountAllUsers (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUsers(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUsers (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getCountAllUsers_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUsers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUsers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUsers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getCountAllUsers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUsers failed: unknown result';
  }

  getAllGroups (token, groupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllGroups(token, groupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllGroups (token, groupId, filter, callback) {
    const params = {
      token: token,
      groupId: groupId,
      filter: filter
    };
    const args = new UserManagementService_getAllGroups_args(params);
    try {
      this.output.writeMessageBegin('getAllGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllGroups failed: unknown result';
  }

  getCountAllGroups (token, groupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllGroups(token, groupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllGroups (token, groupId, filter, callback) {
    const params = {
      token: token,
      groupId: groupId,
      filter: filter
    };
    const args = new UserManagementService_getCountAllGroups_args(params);
    try {
      this.output.writeMessageBegin('getCountAllGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getCountAllGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllGroups failed: unknown result';
  }

  getRolesByUserOrGroup (token, type, userOrGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getRolesByUserOrGroup(token, type, userOrGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getRolesByUserOrGroup (token, type, userOrGroupId, filter, callback) {
    const params = {
      token: token,
      type: type,
      userOrGroupId: userOrGroupId,
      filter: filter
    };
    const args = new UserManagementService_getRolesByUserOrGroup_args(params);
    try {
      this.output.writeMessageBegin('getRolesByUserOrGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getRolesByUserOrGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getRolesByUserOrGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getRolesByUserOrGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getRolesByUserOrGroup failed: unknown result';
  }

  getUserOrGroupsByRole (token, role, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUserOrGroupsByRole(token, role, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUserOrGroupsByRole (token, role, filter, callback) {
    const params = {
      token: token,
      role: role,
      filter: filter
    };
    const args = new UserManagementService_getUserOrGroupsByRole_args(params);
    try {
      this.output.writeMessageBegin('getUserOrGroupsByRole', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUserOrGroupsByRole();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUserOrGroupsByRole () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getUserOrGroupsByRole_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUserOrGroupsByRole failed: unknown result';
  }

  createOrUpdateUserGroup (token, userGroup, accountId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateUserGroup(token, userGroup, accountId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateUserGroup (token, userGroup, accountId, callback) {
    const params = {
      token: token,
      userGroup: userGroup,
      accountId: accountId
    };
    const args = new UserManagementService_createOrUpdateUserGroup_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateUserGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateUserGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateUserGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_createOrUpdateUserGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateUserGroup failed: unknown result';
  }

  addUsersToGroups (token, groupsId, usersId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addUsersToGroups(token, groupsId, usersId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addUsersToGroups (token, groupsId, usersId, callback) {
    const params = {
      token: token,
      groupsId: groupsId,
      usersId: usersId
    };
    const args = new UserManagementService_addUsersToGroups_args(params);
    try {
      this.output.writeMessageBegin('addUsersToGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addUsersToGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addUsersToGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_addUsersToGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addUsersToGroups failed: unknown result';
  }

  createOrUpdateUser (token, user, login, password, accountGroupId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateUser(token, user, login, password, accountGroupId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateUser (token, user, login, password, accountGroupId, callback) {
    const params = {
      token: token,
      user: user,
      login: login,
      password: password,
      accountGroupId: accountGroupId
    };
    const args = new UserManagementService_createOrUpdateUser_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_createOrUpdateUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateUser failed: unknown result';
  }

  removeClient (token, userId, reasonForRemoval) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeClient(token, userId, reasonForRemoval, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeClient (token, userId, reasonForRemoval, callback) {
    const params = {
      token: token,
      userId: userId,
      reasonForRemoval: reasonForRemoval
    };
    const args = new UserManagementService_removeClient_args(params);
    try {
      this.output.writeMessageBegin('removeClient', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeClient();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeClient () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_removeClient_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeClient failed: unknown result';
  }

  removeUsersFromGroups (token, groupsId, usersId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeUsersFromGroups(token, groupsId, usersId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeUsersFromGroups (token, groupsId, usersId, callback) {
    const params = {
      token: token,
      groupsId: groupsId,
      usersId: usersId
    };
    const args = new UserManagementService_removeUsersFromGroups_args(params);
    try {
      this.output.writeMessageBegin('removeUsersFromGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeUsersFromGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeUsersFromGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_removeUsersFromGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeUsersFromGroups failed: unknown result';
  }

  removeGroup (token, groupsId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeGroup(token, groupsId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeGroup (token, groupsId, callback) {
    const params = {
      token: token,
      groupsId: groupsId
    };
    const args = new UserManagementService_removeGroup_args(params);
    try {
      this.output.writeMessageBegin('removeGroup', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeGroup();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeGroup () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_removeGroup_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeGroup failed: unknown result';
  }

  blockUsers (token, userIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_blockUsers(token, userIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_blockUsers (token, userIds, callback) {
    const params = {
      token: token,
      userIds: userIds
    };
    const args = new UserManagementService_blockUsers_args(params);
    try {
      this.output.writeMessageBegin('blockUsers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_blockUsers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_blockUsers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_blockUsers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'blockUsers failed: unknown result';
  }

  unBlockUsers (token, userIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_unBlockUsers(token, userIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_unBlockUsers (token, userIds, callback) {
    const params = {
      token: token,
      userIds: userIds
    };
    const args = new UserManagementService_unBlockUsers_args(params);
    try {
      this.output.writeMessageBegin('unBlockUsers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_unBlockUsers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_unBlockUsers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_unBlockUsers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'unBlockUsers failed: unknown result';
  }

  getAllExistingRoles (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllExistingRoles(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllExistingRoles (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllExistingRoles_args(params);
    try {
      this.output.writeMessageBegin('getAllExistingRoles', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllExistingRoles();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllExistingRoles () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllExistingRoles_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllExistingRoles failed: unknown result';
  }

  addRolesToUsersOrGroups (token, usersOrGroups, roles) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addRolesToUsersOrGroups(token, usersOrGroups, roles, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addRolesToUsersOrGroups (token, usersOrGroups, roles, callback) {
    const params = {
      token: token,
      usersOrGroups: usersOrGroups,
      roles: roles
    };
    const args = new UserManagementService_addRolesToUsersOrGroups_args(params);
    try {
      this.output.writeMessageBegin('addRolesToUsersOrGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addRolesToUsersOrGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addRolesToUsersOrGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_addRolesToUsersOrGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addRolesToUsersOrGroups failed: unknown result';
  }

  revokeRolesFromUsersOrGroups (token, usersOrGroups, roles) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeRolesFromUsersOrGroups(token, usersOrGroups, roles, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeRolesFromUsersOrGroups (token, usersOrGroups, roles, callback) {
    const params = {
      token: token,
      usersOrGroups: usersOrGroups,
      roles: roles
    };
    const args = new UserManagementService_revokeRolesFromUsersOrGroups_args(params);
    try {
      this.output.writeMessageBegin('revokeRolesFromUsersOrGroups', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeRolesFromUsersOrGroups();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeRolesFromUsersOrGroups () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_revokeRolesFromUsersOrGroups_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeRolesFromUsersOrGroups failed: unknown result';
  }

  getRolesByUser (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getRolesByUser(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getRolesByUser (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new UserManagementService_getRolesByUser_args(params);
    try {
      this.output.writeMessageBegin('getRolesByUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getRolesByUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getRolesByUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getRolesByUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getRolesByUser failed: unknown result';
  }

  loadUserPublicKey (token, publicKey, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_loadUserPublicKey(token, publicKey, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_loadUserPublicKey (token, publicKey, signature, callback) {
    const params = {
      token: token,
      publicKey: publicKey,
      signature: signature
    };
    const args = new UserManagementService_loadUserPublicKey_args(params);
    try {
      this.output.writeMessageBegin('loadUserPublicKey', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_loadUserPublicKey();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_loadUserPublicKey () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_loadUserPublicKey_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'loadUserPublicKey failed: unknown result';
  }

  getAllUserPublicKeyInfo (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllUserPublicKeyInfo(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllUserPublicKeyInfo (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllUserPublicKeyInfo_args(params);
    try {
      this.output.writeMessageBegin('getAllUserPublicKeyInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllUserPublicKeyInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllUserPublicKeyInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllUserPublicKeyInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllUserPublicKeyInfo failed: unknown result';
  }

  getCountAllUserPublicKeyInfo (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllUserPublicKeyInfo(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllUserPublicKeyInfo (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getCountAllUserPublicKeyInfo_args(params);
    try {
      this.output.writeMessageBegin('getCountAllUserPublicKeyInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllUserPublicKeyInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllUserPublicKeyInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getCountAllUserPublicKeyInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllUserPublicKeyInfo failed: unknown result';
  }

  changeClientDelegateDetailsInfo (token, clientDelegateInfo, listDetailsToAdd, listDetailIdsToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeClientDelegateDetailsInfo(token, clientDelegateInfo, listDetailsToAdd, listDetailIdsToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeClientDelegateDetailsInfo (token, clientDelegateInfo, listDetailsToAdd, listDetailIdsToRemove, callback) {
    const params = {
      token: token,
      clientDelegateInfo: clientDelegateInfo,
      listDetailsToAdd: listDetailsToAdd,
      listDetailIdsToRemove: listDetailIdsToRemove
    };
    const args = new UserManagementService_changeClientDelegateDetailsInfo_args(params);
    try {
      this.output.writeMessageBegin('changeClientDelegateDetailsInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeClientDelegateDetailsInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeClientDelegateDetailsInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_changeClientDelegateDetailsInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeClientDelegateDetailsInfo failed: unknown result';
  }

  revokeClientDelegates (token, clientDelegateId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeClientDelegates(token, clientDelegateId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeClientDelegates (token, clientDelegateId, callback) {
    const params = {
      token: token,
      clientDelegateId: clientDelegateId
    };
    const args = new UserManagementService_revokeClientDelegates_args(params);
    try {
      this.output.writeMessageBegin('revokeClientDelegates', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeClientDelegates();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeClientDelegates () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_revokeClientDelegates_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeClientDelegates failed: unknown result';
  }

  getAllClientDelegatesInfoList (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllClientDelegatesInfoList(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllClientDelegatesInfoList (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllClientDelegatesInfoList_args(params);
    try {
      this.output.writeMessageBegin('getAllClientDelegatesInfoList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllClientDelegatesInfoList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllClientDelegatesInfoList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllClientDelegatesInfoList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllClientDelegatesInfoList failed: unknown result';
  }

  getAllClientDelegatesDetails (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllClientDelegatesDetails(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllClientDelegatesDetails (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAllClientDelegatesDetails_args(params);
    try {
      this.output.writeMessageBegin('getAllClientDelegatesDetails', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllClientDelegatesDetails();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllClientDelegatesDetails () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllClientDelegatesDetails_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllClientDelegatesDetails failed: unknown result';
  }

  getClientDelegateDetails (token, clientDelegateInfoId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getClientDelegateDetails(token, clientDelegateInfoId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getClientDelegateDetails (token, clientDelegateInfoId, callback) {
    const params = {
      token: token,
      clientDelegateInfoId: clientDelegateInfoId
    };
    const args = new UserManagementService_getClientDelegateDetails_args(params);
    try {
      this.output.writeMessageBegin('getClientDelegateDetails', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getClientDelegateDetails();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getClientDelegateDetails () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getClientDelegateDetails_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getClientDelegateDetails failed: unknown result';
  }

  getAllClientsForDelegate (token, userId, reverse, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllClientsForDelegate(token, userId, reverse, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllClientsForDelegate (token, userId, reverse, documentId, callback) {
    const params = {
      token: token,
      userId: userId,
      reverse: reverse,
      documentId: documentId
    };
    const args = new UserManagementService_getAllClientsForDelegate_args(params);
    try {
      this.output.writeMessageBegin('getAllClientsForDelegate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllClientsForDelegate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllClientsForDelegate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllClientsForDelegate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllClientsForDelegate failed: unknown result';
  }

  getAllNotificationsForDelegate (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNotificationsForDelegate(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNotificationsForDelegate (token, callback) {
    const params = {
      token: token
    };
    const args = new UserManagementService_getAllNotificationsForDelegate_args(params);
    try {
      this.output.writeMessageBegin('getAllNotificationsForDelegate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNotificationsForDelegate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNotificationsForDelegate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAllNotificationsForDelegate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNotificationsForDelegate failed: unknown result';
  }

  getAccounts (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAccounts(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAccounts (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new UserManagementService_getAccounts_args(params);
    try {
      this.output.writeMessageBegin('getAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAccounts failed: unknown result';
  }

  getSecurityClassificationsByUser (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getSecurityClassificationsByUser(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getSecurityClassificationsByUser (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new UserManagementService_getSecurityClassificationsByUser_args(params);
    try {
      this.output.writeMessageBegin('getSecurityClassificationsByUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getSecurityClassificationsByUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getSecurityClassificationsByUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getSecurityClassificationsByUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getSecurityClassificationsByUser failed: unknown result';
  }

  getUserChief (token, userId, level, userTypes, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUserChief(token, userId, level, userTypes, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUserChief (token, userId, level, userTypes, filter, callback) {
    const params = {
      token: token,
      userId: userId,
      level: level,
      userTypes: userTypes,
      filter: filter
    };
    const args = new UserManagementService_getUserChief_args(params);
    try {
      this.output.writeMessageBegin('getUserChief', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUserChief();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUserChief () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getUserChief_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUserChief failed: unknown result';
  }

  updateUserInfo (token, user) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateUserInfo(token, user, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateUserInfo (token, user, callback) {
    const params = {
      token: token,
      user: user
    };
    const args = new UserManagementService_updateUserInfo_args(params);
    try {
      this.output.writeMessageBegin('updateUserInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateUserInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateUserInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_updateUserInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateUserInfo failed: unknown result';
  }

  getUserPreferences (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getUserPreferences(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getUserPreferences (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new UserManagementService_getUserPreferences_args(params);
    try {
      this.output.writeMessageBegin('getUserPreferences', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getUserPreferences();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getUserPreferences () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_getUserPreferences_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getUserPreferences failed: unknown result';
  }

  updateUserPreferences (token, preferences) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateUserPreferences(token, preferences, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateUserPreferences (token, preferences, callback) {
    const params = {
      token: token,
      preferences: preferences
    };
    const args = new UserManagementService_updateUserPreferences_args(params);
    try {
      this.output.writeMessageBegin('updateUserPreferences', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateUserPreferences();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateUserPreferences () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_updateUserPreferences_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateUserPreferences failed: unknown result';
  }

  createOrRemoveFavoriteUsers (token, userIdsToAdd, userIdsToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrRemoveFavoriteUsers(token, userIdsToAdd, userIdsToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrRemoveFavoriteUsers (token, userIdsToAdd, userIdsToRemove, callback) {
    const params = {
      token: token,
      userIdsToAdd: userIdsToAdd,
      userIdsToRemove: userIdsToRemove
    };
    const args = new UserManagementService_createOrRemoveFavoriteUsers_args(params);
    try {
      this.output.writeMessageBegin('createOrRemoveFavoriteUsers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrRemoveFavoriteUsers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrRemoveFavoriteUsers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new UserManagementService_createOrRemoveFavoriteUsers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrRemoveFavoriteUsers failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


MaterialResourceType = {
  'PREMISES' : 0,
  'EQUIPMENT' : 1
};
MeetingStatus = {
  'DRAFT' : 0,
  'PRE_VOTE' : 1,
  'PREPARE' : 2,
  'VOTE' : 3,
  'CLOSED' : 4,
  'PROTOCOLLED' : 5
};
StageState = {
  'ACTIVE' : 0,
  'PENDING' : 1
};
Area = class {
  constructor(args) {
    this.id = null;
    this.nameArea = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameArea !== undefined && args.nameArea !== null) {
        this.nameArea = args.nameArea;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameArea = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Area');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameArea !== null && this.nameArea !== undefined) {
      output.writeFieldBegin('nameArea', Thrift.Type.STRING, 2);
      output.writeString(this.nameArea);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MaterialResource = class {
  constructor(args) {
    this.id = null;
    this.nameMaterRes = null;
    this.type = null;
    this.areaId = null;
    this.countPersons = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameMaterRes !== undefined && args.nameMaterRes !== null) {
        this.nameMaterRes = args.nameMaterRes;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.areaId !== undefined && args.areaId !== null) {
        this.areaId = args.areaId;
      }
      if (args.countPersons !== undefined && args.countPersons !== null) {
        this.countPersons = args.countPersons;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameMaterRes = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.areaId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.countPersons = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MaterialResource');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameMaterRes !== null && this.nameMaterRes !== undefined) {
      output.writeFieldBegin('nameMaterRes', Thrift.Type.STRING, 2);
      output.writeString(this.nameMaterRes);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.areaId !== null && this.areaId !== undefined) {
      output.writeFieldBegin('areaId', Thrift.Type.STRING, 4);
      output.writeString(this.areaId);
      output.writeFieldEnd();
    }
    if (this.countPersons !== null && this.countPersons !== undefined) {
      output.writeFieldBegin('countPersons', Thrift.Type.I64, 5);
      output.writeI64(this.countPersons);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Meeting = class {
  constructor(args) {
    this.id = null;
    this.vesion = null;
    this.nameMeeting = null;
    this.agenda = null;
    this.address = null;
    this.dateStart = null;
    this.dateEnd = null;
    this.allowSuggestTime = null;
    this.protocolDocumentId = null;
    this.author = null;
    this.color = null;
    this.viewed = null;
    this.participants = null;
    this.resources = null;
    this.canModifyResource = null;
    this.canModifyVote = null;
    this.protocolAttachmentId = null;
    this.freezePatternId = null;
    this.freezeStageId = null;
    this.patternGroupName = null;
    this.patternName = null;
    this.meetingStatus = null;
    this.stageState = null;
    this.freezeNextStageId = null;
    this.originalUser = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.vesion !== undefined && args.vesion !== null) {
        this.vesion = args.vesion;
      }
      if (args.nameMeeting !== undefined && args.nameMeeting !== null) {
        this.nameMeeting = args.nameMeeting;
      }
      if (args.agenda !== undefined && args.agenda !== null) {
        this.agenda = args.agenda;
      }
      if (args.address !== undefined && args.address !== null) {
        this.address = args.address;
      }
      if (args.dateStart !== undefined && args.dateStart !== null) {
        this.dateStart = args.dateStart;
      }
      if (args.dateEnd !== undefined && args.dateEnd !== null) {
        this.dateEnd = args.dateEnd;
      }
      if (args.allowSuggestTime !== undefined && args.allowSuggestTime !== null) {
        this.allowSuggestTime = args.allowSuggestTime;
      }
      if (args.protocolDocumentId !== undefined && args.protocolDocumentId !== null) {
        this.protocolDocumentId = args.protocolDocumentId;
      }
      if (args.author !== undefined && args.author !== null) {
        this.author = new UserOrGroup(args.author);
      }
      if (args.color !== undefined && args.color !== null) {
        this.color = args.color;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.participants !== undefined && args.participants !== null) {
        this.participants = Thrift.copyList(args.participants, [null]);
      }
      if (args.resources !== undefined && args.resources !== null) {
        this.resources = Thrift.copyList(args.resources, [MaterialResource]);
      }
      if (args.canModifyResource !== undefined && args.canModifyResource !== null) {
        this.canModifyResource = args.canModifyResource;
      }
      if (args.canModifyVote !== undefined && args.canModifyVote !== null) {
        this.canModifyVote = args.canModifyVote;
      }
      if (args.protocolAttachmentId !== undefined && args.protocolAttachmentId !== null) {
        this.protocolAttachmentId = args.protocolAttachmentId;
      }
      if (args.freezePatternId !== undefined && args.freezePatternId !== null) {
        this.freezePatternId = args.freezePatternId;
      }
      if (args.freezeStageId !== undefined && args.freezeStageId !== null) {
        this.freezeStageId = args.freezeStageId;
      }
      if (args.patternGroupName !== undefined && args.patternGroupName !== null) {
        this.patternGroupName = args.patternGroupName;
      }
      if (args.patternName !== undefined && args.patternName !== null) {
        this.patternName = args.patternName;
      }
      if (args.meetingStatus !== undefined && args.meetingStatus !== null) {
        this.meetingStatus = args.meetingStatus;
      }
      if (args.stageState !== undefined && args.stageState !== null) {
        this.stageState = args.stageState;
      }
      if (args.freezeNextStageId !== undefined && args.freezeNextStageId !== null) {
        this.freezeNextStageId = args.freezeNextStageId;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.vesion = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nameMeeting = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.agenda = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.address = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.dateStart = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.dateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.allowSuggestTime = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.protocolDocumentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.author = new UserOrGroup();
          this.author.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.color = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.LIST) {
          this.participants = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new MeetingParticipant();
            elem3.read(input);
            this.participants.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.LIST) {
          this.resources = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = new MaterialResource();
            elem7.read(input);
            this.resources.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.canModifyResource = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.canModifyVote = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.protocolAttachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.freezePatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.freezeStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.patternGroupName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.patternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.I32) {
          this.meetingStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I32) {
          this.stageState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRING) {
          this.freezeNextStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Meeting');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.vesion !== null && this.vesion !== undefined) {
      output.writeFieldBegin('vesion', Thrift.Type.I64, 2);
      output.writeI64(this.vesion);
      output.writeFieldEnd();
    }
    if (this.nameMeeting !== null && this.nameMeeting !== undefined) {
      output.writeFieldBegin('nameMeeting', Thrift.Type.STRING, 3);
      output.writeString(this.nameMeeting);
      output.writeFieldEnd();
    }
    if (this.agenda !== null && this.agenda !== undefined) {
      output.writeFieldBegin('agenda', Thrift.Type.STRING, 4);
      output.writeString(this.agenda);
      output.writeFieldEnd();
    }
    if (this.address !== null && this.address !== undefined) {
      output.writeFieldBegin('address', Thrift.Type.STRING, 5);
      output.writeString(this.address);
      output.writeFieldEnd();
    }
    if (this.dateStart !== null && this.dateStart !== undefined) {
      output.writeFieldBegin('dateStart', Thrift.Type.I64, 6);
      output.writeI64(this.dateStart);
      output.writeFieldEnd();
    }
    if (this.dateEnd !== null && this.dateEnd !== undefined) {
      output.writeFieldBegin('dateEnd', Thrift.Type.I64, 7);
      output.writeI64(this.dateEnd);
      output.writeFieldEnd();
    }
    if (this.allowSuggestTime !== null && this.allowSuggestTime !== undefined) {
      output.writeFieldBegin('allowSuggestTime', Thrift.Type.BOOL, 8);
      output.writeBool(this.allowSuggestTime);
      output.writeFieldEnd();
    }
    if (this.protocolDocumentId !== null && this.protocolDocumentId !== undefined) {
      output.writeFieldBegin('protocolDocumentId', Thrift.Type.STRING, 9);
      output.writeString(this.protocolDocumentId);
      output.writeFieldEnd();
    }
    if (this.author !== null && this.author !== undefined) {
      output.writeFieldBegin('author', Thrift.Type.STRUCT, 10);
      this.author.write(output);
      output.writeFieldEnd();
    }
    if (this.color !== null && this.color !== undefined) {
      output.writeFieldBegin('color', Thrift.Type.STRING, 11);
      output.writeString(this.color);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 12);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.participants !== null && this.participants !== undefined) {
      output.writeFieldBegin('participants', Thrift.Type.LIST, 13);
      output.writeListBegin(Thrift.Type.STRUCT, this.participants.length);
      for (let iter8 in this.participants) {
        if (this.participants.hasOwnProperty(iter8)) {
          iter8 = this.participants[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.resources !== null && this.resources !== undefined) {
      output.writeFieldBegin('resources', Thrift.Type.LIST, 14);
      output.writeListBegin(Thrift.Type.STRUCT, this.resources.length);
      for (let iter9 in this.resources) {
        if (this.resources.hasOwnProperty(iter9)) {
          iter9 = this.resources[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.canModifyResource !== null && this.canModifyResource !== undefined) {
      output.writeFieldBegin('canModifyResource', Thrift.Type.BOOL, 15);
      output.writeBool(this.canModifyResource);
      output.writeFieldEnd();
    }
    if (this.canModifyVote !== null && this.canModifyVote !== undefined) {
      output.writeFieldBegin('canModifyVote', Thrift.Type.BOOL, 16);
      output.writeBool(this.canModifyVote);
      output.writeFieldEnd();
    }
    if (this.protocolAttachmentId !== null && this.protocolAttachmentId !== undefined) {
      output.writeFieldBegin('protocolAttachmentId', Thrift.Type.STRING, 17);
      output.writeString(this.protocolAttachmentId);
      output.writeFieldEnd();
    }
    if (this.freezePatternId !== null && this.freezePatternId !== undefined) {
      output.writeFieldBegin('freezePatternId', Thrift.Type.STRING, 18);
      output.writeString(this.freezePatternId);
      output.writeFieldEnd();
    }
    if (this.freezeStageId !== null && this.freezeStageId !== undefined) {
      output.writeFieldBegin('freezeStageId', Thrift.Type.STRING, 19);
      output.writeString(this.freezeStageId);
      output.writeFieldEnd();
    }
    if (this.patternGroupName !== null && this.patternGroupName !== undefined) {
      output.writeFieldBegin('patternGroupName', Thrift.Type.STRING, 20);
      output.writeString(this.patternGroupName);
      output.writeFieldEnd();
    }
    if (this.patternName !== null && this.patternName !== undefined) {
      output.writeFieldBegin('patternName', Thrift.Type.STRING, 21);
      output.writeString(this.patternName);
      output.writeFieldEnd();
    }
    if (this.meetingStatus !== null && this.meetingStatus !== undefined) {
      output.writeFieldBegin('meetingStatus', Thrift.Type.I32, 22);
      output.writeI32(this.meetingStatus);
      output.writeFieldEnd();
    }
    if (this.stageState !== null && this.stageState !== undefined) {
      output.writeFieldBegin('stageState', Thrift.Type.I32, 23);
      output.writeI32(this.stageState);
      output.writeFieldEnd();
    }
    if (this.freezeNextStageId !== null && this.freezeNextStageId !== undefined) {
      output.writeFieldBegin('freezeNextStageId', Thrift.Type.STRING, 24);
      output.writeString(this.freezeNextStageId);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 25);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MeetingParticipant = class {
  constructor(args) {
    this.id = null;
    this.userOrGroup = null;
    this.decision = null;
    this.proposedBeginDate = null;
    this.proposedEndDate = null;
    this.author = null;
    this.secretary = null;
    this.speaker = null;
    this.canVote = null;
    this.chairman = null;
    this.location = null;
    this.present = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.proposedBeginDate !== undefined && args.proposedBeginDate !== null) {
        this.proposedBeginDate = args.proposedBeginDate;
      }
      if (args.proposedEndDate !== undefined && args.proposedEndDate !== null) {
        this.proposedEndDate = args.proposedEndDate;
      }
      if (args.author !== undefined && args.author !== null) {
        this.author = args.author;
      }
      if (args.secretary !== undefined && args.secretary !== null) {
        this.secretary = args.secretary;
      }
      if (args.speaker !== undefined && args.speaker !== null) {
        this.speaker = args.speaker;
      }
      if (args.canVote !== undefined && args.canVote !== null) {
        this.canVote = args.canVote;
      }
      if (args.chairman !== undefined && args.chairman !== null) {
        this.chairman = args.chairman;
      }
      if (args.location !== undefined && args.location !== null) {
        this.location = args.location;
      }
      if (args.present !== undefined && args.present !== null) {
        this.present = args.present;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.decision = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.proposedBeginDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.proposedEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.author = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.secretary = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.speaker = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.canVote = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.chairman = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.location = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.present = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MeetingParticipant');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 2);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.I32, 3);
      output.writeI32(this.decision);
      output.writeFieldEnd();
    }
    if (this.proposedBeginDate !== null && this.proposedBeginDate !== undefined) {
      output.writeFieldBegin('proposedBeginDate', Thrift.Type.I64, 4);
      output.writeI64(this.proposedBeginDate);
      output.writeFieldEnd();
    }
    if (this.proposedEndDate !== null && this.proposedEndDate !== undefined) {
      output.writeFieldBegin('proposedEndDate', Thrift.Type.I64, 5);
      output.writeI64(this.proposedEndDate);
      output.writeFieldEnd();
    }
    if (this.author !== null && this.author !== undefined) {
      output.writeFieldBegin('author', Thrift.Type.BOOL, 6);
      output.writeBool(this.author);
      output.writeFieldEnd();
    }
    if (this.secretary !== null && this.secretary !== undefined) {
      output.writeFieldBegin('secretary', Thrift.Type.BOOL, 7);
      output.writeBool(this.secretary);
      output.writeFieldEnd();
    }
    if (this.speaker !== null && this.speaker !== undefined) {
      output.writeFieldBegin('speaker', Thrift.Type.BOOL, 8);
      output.writeBool(this.speaker);
      output.writeFieldEnd();
    }
    if (this.canVote !== null && this.canVote !== undefined) {
      output.writeFieldBegin('canVote', Thrift.Type.BOOL, 9);
      output.writeBool(this.canVote);
      output.writeFieldEnd();
    }
    if (this.chairman !== null && this.chairman !== undefined) {
      output.writeFieldBegin('chairman', Thrift.Type.BOOL, 10);
      output.writeBool(this.chairman);
      output.writeFieldEnd();
    }
    if (this.location !== null && this.location !== undefined) {
      output.writeFieldBegin('location', Thrift.Type.STRING, 11);
      output.writeString(this.location);
      output.writeFieldEnd();
    }
    if (this.present !== null && this.present !== undefined) {
      output.writeFieldBegin('present', Thrift.Type.BOOL, 12);
      output.writeBool(this.present);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


UserOrGroupType = {
  'USER' : 0,
  'GROUP' : 1,
  'USER_GUEST' : 2,
  'PROCESS_ROLE' : 3
};
GroupSelector = {
  'ALL' : 0,
  'MAX_FREE' : 1,
  'LAST_EXEC' : 2,
  'ANY' : 3
};
UserType = {
  'CHIEF' : 0,
  'DEPUTY' : 1,
  'EMPLOYEE' : 2,
  'TECHNICAL' : 3,
  'SYSTEM' : 4
};
AttachmentStatus = {
  'CREATED' : 0,
  'LOADED' : 1,
  'PUBLISHED' : 2,
  'REBUILD' : 3,
  'PROCESSED' : 4,
  'FAIL' : 5,
  'PROCESSING' : 6
};
FileType = {
  'PICTURE' : 0,
  'PDF' : 1,
  'OFFICE' : 2,
  'OTHER' : 3
};
AttachmentEditMode = {
  'SINGLE' : 0,
  'MULTIPLE' : 1,
  'PUBLISHED' : 2
};
SignProviderType = {
  'UA_SIGN' : 0,
  'KAZ_SIGN' : 1
};
DecisionType = {
  'NULL' : 0,
  'YES' : 1,
  'NO' : 2,
  'OTHER_TIME' : 3
};
RemoveActionType = {
  'IGNORE' : 0,
  'CASCADE' : 1
};
UserOrGroup = class {
  constructor(args) {
    this.type = null;
    this.userOrGroupId = null;
    this.nameGroup = null;
    this.descriptionGroup = null;
    this.userFirstName = null;
    this.userLastName = null;
    this.userMiddleName = null;
    this.attrs = null;
    this.deleteDate = null;
    this.avatarUrl = null;
    this.groupSelector = null;
    this.position = null;
    this.userCount = null;
    this.email = null;
    this.workPhone = null;
    this.haveAccess = null;
    this.scMask = null;
    this.employeeNumber = null;
    this.departments = null;
    this.fixed = null;
    this.endlessPassword = null;
    this.needChangePassword = null;
    this.accountIdGroup = null;
    this.userType = null;
    this.id = null;
    this.ldapId = null;
    this.company = null;
    this.mobilePhone = null;
    this.favorite = null;
    this.remark = null;
    this.fixedExec = null;
    this.chiefId = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.nameGroup !== undefined && args.nameGroup !== null) {
        this.nameGroup = args.nameGroup;
      }
      if (args.descriptionGroup !== undefined && args.descriptionGroup !== null) {
        this.descriptionGroup = args.descriptionGroup;
      }
      if (args.userFirstName !== undefined && args.userFirstName !== null) {
        this.userFirstName = args.userFirstName;
      }
      if (args.userLastName !== undefined && args.userLastName !== null) {
        this.userLastName = args.userLastName;
      }
      if (args.userMiddleName !== undefined && args.userMiddleName !== null) {
        this.userMiddleName = args.userMiddleName;
      }
      if (args.attrs !== undefined && args.attrs !== null) {
        this.attrs = Thrift.copyMap(args.attrs, [null]);
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.avatarUrl !== undefined && args.avatarUrl !== null) {
        this.avatarUrl = args.avatarUrl;
      }
      if (args.groupSelector !== undefined && args.groupSelector !== null) {
        this.groupSelector = args.groupSelector;
      }
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
      if (args.userCount !== undefined && args.userCount !== null) {
        this.userCount = args.userCount;
      }
      if (args.email !== undefined && args.email !== null) {
        this.email = args.email;
      }
      if (args.workPhone !== undefined && args.workPhone !== null) {
        this.workPhone = args.workPhone;
      }
      if (args.haveAccess !== undefined && args.haveAccess !== null) {
        this.haveAccess = args.haveAccess;
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.employeeNumber !== undefined && args.employeeNumber !== null) {
        this.employeeNumber = args.employeeNumber;
      }
      if (args.departments !== undefined && args.departments !== null) {
        this.departments = Thrift.copyList(args.departments, [null]);
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.endlessPassword !== undefined && args.endlessPassword !== null) {
        this.endlessPassword = args.endlessPassword;
      }
      if (args.needChangePassword !== undefined && args.needChangePassword !== null) {
        this.needChangePassword = args.needChangePassword;
      }
      if (args.accountIdGroup !== undefined && args.accountIdGroup !== null) {
        this.accountIdGroup = args.accountIdGroup;
      }
      if (args.userType !== undefined && args.userType !== null) {
        this.userType = args.userType;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.ldapId !== undefined && args.ldapId !== null) {
        this.ldapId = args.ldapId;
      }
      if (args.company !== undefined && args.company !== null) {
        this.company = args.company;
      }
      if (args.mobilePhone !== undefined && args.mobilePhone !== null) {
        this.mobilePhone = args.mobilePhone;
      }
      if (args.favorite !== undefined && args.favorite !== null) {
        this.favorite = args.favorite;
      }
      if (args.remark !== undefined && args.remark !== null) {
        this.remark = args.remark;
      }
      if (args.fixedExec !== undefined && args.fixedExec !== null) {
        this.fixedExec = args.fixedExec;
      }
      if (args.chiefId !== undefined && args.chiefId !== null) {
        this.chiefId = args.chiefId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nameGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.userFirstName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.userLastName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.userMiddleName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.MAP) {
          this.attrs = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readString().value;
            val4 = input.readString().value;
            this.attrs[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.avatarUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.groupSelector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.position = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.userCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.email = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.workPhone = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.haveAccess = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.employeeNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.LIST) {
          this.departments = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new Department();
            elem8.read(input);
            this.departments.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.BOOL) {
          this.endlessPassword = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.needChangePassword = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.STRING) {
          this.accountIdGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.userType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.ldapId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.company = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.mobilePhone = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.BOOL) {
          this.favorite = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.remark = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.fixedExec = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRING) {
          this.chiefId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserOrGroup');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.nameGroup !== null && this.nameGroup !== undefined) {
      output.writeFieldBegin('nameGroup', Thrift.Type.STRING, 3);
      output.writeString(this.nameGroup);
      output.writeFieldEnd();
    }
    if (this.descriptionGroup !== null && this.descriptionGroup !== undefined) {
      output.writeFieldBegin('descriptionGroup', Thrift.Type.STRING, 4);
      output.writeString(this.descriptionGroup);
      output.writeFieldEnd();
    }
    if (this.userFirstName !== null && this.userFirstName !== undefined) {
      output.writeFieldBegin('userFirstName', Thrift.Type.STRING, 5);
      output.writeString(this.userFirstName);
      output.writeFieldEnd();
    }
    if (this.userLastName !== null && this.userLastName !== undefined) {
      output.writeFieldBegin('userLastName', Thrift.Type.STRING, 6);
      output.writeString(this.userLastName);
      output.writeFieldEnd();
    }
    if (this.userMiddleName !== null && this.userMiddleName !== undefined) {
      output.writeFieldBegin('userMiddleName', Thrift.Type.STRING, 7);
      output.writeString(this.userMiddleName);
      output.writeFieldEnd();
    }
    if (this.attrs !== null && this.attrs !== undefined) {
      output.writeFieldBegin('attrs', Thrift.Type.MAP, 8);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attrs));
      for (let kiter9 in this.attrs) {
        if (this.attrs.hasOwnProperty(kiter9)) {
          let viter10 = this.attrs[kiter9];
          output.writeString(kiter9);
          output.writeString(viter10);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 9);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.avatarUrl !== null && this.avatarUrl !== undefined) {
      output.writeFieldBegin('avatarUrl', Thrift.Type.STRING, 10);
      output.writeString(this.avatarUrl);
      output.writeFieldEnd();
    }
    if (this.groupSelector !== null && this.groupSelector !== undefined) {
      output.writeFieldBegin('groupSelector', Thrift.Type.I32, 11);
      output.writeI32(this.groupSelector);
      output.writeFieldEnd();
    }
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.STRING, 12);
      output.writeString(this.position);
      output.writeFieldEnd();
    }
    if (this.userCount !== null && this.userCount !== undefined) {
      output.writeFieldBegin('userCount', Thrift.Type.I32, 13);
      output.writeI32(this.userCount);
      output.writeFieldEnd();
    }
    if (this.email !== null && this.email !== undefined) {
      output.writeFieldBegin('email', Thrift.Type.STRING, 14);
      output.writeString(this.email);
      output.writeFieldEnd();
    }
    if (this.workPhone !== null && this.workPhone !== undefined) {
      output.writeFieldBegin('workPhone', Thrift.Type.STRING, 15);
      output.writeString(this.workPhone);
      output.writeFieldEnd();
    }
    if (this.haveAccess !== null && this.haveAccess !== undefined) {
      output.writeFieldBegin('haveAccess', Thrift.Type.BOOL, 16);
      output.writeBool(this.haveAccess);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 17);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.employeeNumber !== null && this.employeeNumber !== undefined) {
      output.writeFieldBegin('employeeNumber', Thrift.Type.STRING, 18);
      output.writeString(this.employeeNumber);
      output.writeFieldEnd();
    }
    if (this.departments !== null && this.departments !== undefined) {
      output.writeFieldBegin('departments', Thrift.Type.LIST, 19);
      output.writeListBegin(Thrift.Type.STRUCT, this.departments.length);
      for (let iter11 in this.departments) {
        if (this.departments.hasOwnProperty(iter11)) {
          iter11 = this.departments[iter11];
          iter11.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 20);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.endlessPassword !== null && this.endlessPassword !== undefined) {
      output.writeFieldBegin('endlessPassword', Thrift.Type.BOOL, 21);
      output.writeBool(this.endlessPassword);
      output.writeFieldEnd();
    }
    if (this.needChangePassword !== null && this.needChangePassword !== undefined) {
      output.writeFieldBegin('needChangePassword', Thrift.Type.BOOL, 22);
      output.writeBool(this.needChangePassword);
      output.writeFieldEnd();
    }
    if (this.accountIdGroup !== null && this.accountIdGroup !== undefined) {
      output.writeFieldBegin('accountIdGroup', Thrift.Type.STRING, 23);
      output.writeString(this.accountIdGroup);
      output.writeFieldEnd();
    }
    if (this.userType !== null && this.userType !== undefined) {
      output.writeFieldBegin('userType', Thrift.Type.I32, 24);
      output.writeI32(this.userType);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 25);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.ldapId !== null && this.ldapId !== undefined) {
      output.writeFieldBegin('ldapId', Thrift.Type.STRING, 26);
      output.writeString(this.ldapId);
      output.writeFieldEnd();
    }
    if (this.company !== null && this.company !== undefined) {
      output.writeFieldBegin('company', Thrift.Type.STRING, 27);
      output.writeString(this.company);
      output.writeFieldEnd();
    }
    if (this.mobilePhone !== null && this.mobilePhone !== undefined) {
      output.writeFieldBegin('mobilePhone', Thrift.Type.STRING, 28);
      output.writeString(this.mobilePhone);
      output.writeFieldEnd();
    }
    if (this.favorite !== null && this.favorite !== undefined) {
      output.writeFieldBegin('favorite', Thrift.Type.BOOL, 29);
      output.writeBool(this.favorite);
      output.writeFieldEnd();
    }
    if (this.remark !== null && this.remark !== undefined) {
      output.writeFieldBegin('remark', Thrift.Type.STRING, 30);
      output.writeString(this.remark);
      output.writeFieldEnd();
    }
    if (this.fixedExec !== null && this.fixedExec !== undefined) {
      output.writeFieldBegin('fixedExec', Thrift.Type.BOOL, 31);
      output.writeBool(this.fixedExec);
      output.writeFieldEnd();
    }
    if (this.chiefId !== null && this.chiefId !== undefined) {
      output.writeFieldBegin('chiefId', Thrift.Type.STRING, 32);
      output.writeString(this.chiefId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
OrgStructure = class {
  constructor(args) {
    this.id = null;
    this.accountGroupId = null;
    this.name = null;
    this.order = null;
    this.main = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('OrgStructure');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 4);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 5);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Department = class {
  constructor(args) {
    this.id = null;
    this.parentId = null;
    this.name = null;
    this.orgStructureCode = null;
    this.orgStructureId = null;
    this.userCount = null;
    this.path = null;
    this.main = null;
    this.order = null;
    this.rank = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.orgStructureCode !== undefined && args.orgStructureCode !== null) {
        this.orgStructureCode = args.orgStructureCode;
      }
      if (args.orgStructureId !== undefined && args.orgStructureId !== null) {
        this.orgStructureId = args.orgStructureId;
      }
      if (args.userCount !== undefined && args.userCount !== null) {
        this.userCount = args.userCount;
      }
      if (args.path !== undefined && args.path !== null) {
        this.path = args.path;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.rank !== undefined && args.rank !== null) {
        this.rank = args.rank;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.orgStructureCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.orgStructureId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.userCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.path = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.rank = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Department');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 2);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.orgStructureCode !== null && this.orgStructureCode !== undefined) {
      output.writeFieldBegin('orgStructureCode', Thrift.Type.STRING, 4);
      output.writeString(this.orgStructureCode);
      output.writeFieldEnd();
    }
    if (this.orgStructureId !== null && this.orgStructureId !== undefined) {
      output.writeFieldBegin('orgStructureId', Thrift.Type.STRING, 5);
      output.writeString(this.orgStructureId);
      output.writeFieldEnd();
    }
    if (this.userCount !== null && this.userCount !== undefined) {
      output.writeFieldBegin('userCount', Thrift.Type.I64, 6);
      output.writeI64(this.userCount);
      output.writeFieldEnd();
    }
    if (this.path !== null && this.path !== undefined) {
      output.writeFieldBegin('path', Thrift.Type.STRING, 7);
      output.writeString(this.path);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 8);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 9);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.rank !== null && this.rank !== undefined) {
      output.writeFieldBegin('rank', Thrift.Type.I32, 10);
      output.writeI32(this.rank);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CompositeId = class {
  constructor(args) {
    this.id = null;
    this.version = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CompositeId');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 2);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ServerException = class {
  constructor(args) {
    this.serverExceptionKey = null;
    if (args) {
      if (args.serverExceptionKey !== undefined && args.serverExceptionKey !== null) {
        this.serverExceptionKey = args.serverExceptionKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.serverExceptionKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ServerException');
    if (this.serverExceptionKey !== null && this.serverExceptionKey !== undefined) {
      output.writeFieldBegin('serverExceptionKey', Thrift.Type.STRING, 1);
      output.writeString(this.serverExceptionKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PreconditionException = class {
  constructor(args) {
    this.preconditionExceptionKey = null;
    this.params = null;
    this.message = null;
    this.verWarnining = null;
    if (args) {
      if (args.preconditionExceptionKey !== undefined && args.preconditionExceptionKey !== null) {
        this.preconditionExceptionKey = args.preconditionExceptionKey;
      }
      if (args.params !== undefined && args.params !== null) {
        this.params = Thrift.copyList(args.params, [null]);
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = args.message;
      }
      if (args.verWarnining !== undefined && args.verWarnining !== null) {
        this.verWarnining = args.verWarnining;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.preconditionExceptionKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.params = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString().value;
            this.params.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.message = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.verWarnining = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PreconditionException');
    if (this.preconditionExceptionKey !== null && this.preconditionExceptionKey !== undefined) {
      output.writeFieldBegin('preconditionExceptionKey', Thrift.Type.STRING, 1);
      output.writeString(this.preconditionExceptionKey);
      output.writeFieldEnd();
    }
    if (this.params !== null && this.params !== undefined) {
      output.writeFieldBegin('params', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.params.length);
      for (let iter4 in this.params) {
        if (this.params.hasOwnProperty(iter4)) {
          iter4 = this.params[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRING, 3);
      output.writeString(this.message);
      output.writeFieldEnd();
    }
    if (this.verWarnining !== null && this.verWarnining !== undefined) {
      output.writeFieldBegin('verWarnining', Thrift.Type.BOOL, 4);
      output.writeBool(this.verWarnining);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


FilterFieldType = {
  'STRING' : 0,
  'NUMBER' : 1,
  'DATE' : 2,
  'BOOLEAN' : 3,
  'ENUMERATED' : 4,
  'DOUBLE' : 5,
  'STRING_FOR_REPLACE' : 6
};
FilterCondition = {
  'EQUAL' : 0,
  'NOT_EQUAL' : 1,
  'CONTAIN' : 2,
  'NOT_CONTAIN' : 3,
  'LESS' : 4,
  'LESS_OR_EQUAL' : 5,
  'MORE' : 6,
  'MORE_OR_EQUAL' : 7,
  'IN' : 8,
  'NOT_IN' : 9,
  'NULL' : 10,
  'NOT_NULL' : 11,
  'BETWEEN' : 12,
  'SEMANTIC_ANY' : 13
};
FilterItem = class {
  constructor(args) {
    this.field = null;
    this.fType = null;
    this.condition = null;
    this.value = null;
    this.additionValue = null;
    this.additionValue1 = null;
    this.additionValue2 = null;
    if (args) {
      if (args.field !== undefined && args.field !== null) {
        this.field = args.field;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.condition !== undefined && args.condition !== null) {
        this.condition = args.condition;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.additionValue !== undefined && args.additionValue !== null) {
        this.additionValue = args.additionValue;
      }
      if (args.additionValue1 !== undefined && args.additionValue1 !== null) {
        this.additionValue1 = args.additionValue1;
      }
      if (args.additionValue2 !== undefined && args.additionValue2 !== null) {
        this.additionValue2 = args.additionValue2;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.field = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.condition = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.additionValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.additionValue1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.additionValue2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterItem');
    if (this.field !== null && this.field !== undefined) {
      output.writeFieldBegin('field', Thrift.Type.STRING, 1);
      output.writeString(this.field);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 2);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.condition !== null && this.condition !== undefined) {
      output.writeFieldBegin('condition', Thrift.Type.I32, 3);
      output.writeI32(this.condition);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 4);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.additionValue !== null && this.additionValue !== undefined) {
      output.writeFieldBegin('additionValue', Thrift.Type.STRING, 5);
      output.writeString(this.additionValue);
      output.writeFieldEnd();
    }
    if (this.additionValue1 !== null && this.additionValue1 !== undefined) {
      output.writeFieldBegin('additionValue1', Thrift.Type.STRING, 6);
      output.writeString(this.additionValue1);
      output.writeFieldEnd();
    }
    if (this.additionValue2 !== null && this.additionValue2 !== undefined) {
      output.writeFieldBegin('additionValue2', Thrift.Type.STRING, 7);
      output.writeString(this.additionValue2);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
KazFilter = class {
  constructor(args) {
    this.position = null;
    this.countFilter = null;
    this.items = null;
    this.orders = null;
    if (args) {
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
      if (args.countFilter !== undefined && args.countFilter !== null) {
        this.countFilter = args.countFilter;
      }
      if (args.items !== undefined && args.items !== null) {
        this.items = Thrift.copyList(args.items, [FilterItem]);
      }
      if (args.orders !== undefined && args.orders !== null) {
        this.orders = Thrift.copyList(args.orders, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.position = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.countFilter = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.items = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new FilterItem();
            elem3.read(input);
            this.items.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.orders = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = input.readString().value;
            this.orders.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('KazFilter');
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.I32, 1);
      output.writeI32(this.position);
      output.writeFieldEnd();
    }
    if (this.countFilter !== null && this.countFilter !== undefined) {
      output.writeFieldBegin('countFilter', Thrift.Type.I32, 2);
      output.writeI32(this.countFilter);
      output.writeFieldEnd();
    }
    if (this.items !== null && this.items !== undefined) {
      output.writeFieldBegin('items', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
      for (let iter8 in this.items) {
        if (this.items.hasOwnProperty(iter8)) {
          iter8 = this.items[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.orders !== null && this.orders !== undefined) {
      output.writeFieldBegin('orders', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.orders.length);
      for (let iter9 in this.orders) {
        if (this.orders.hasOwnProperty(iter9)) {
          iter9 = this.orders[iter9];
          output.writeString(iter9);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
